<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anakinliu&#39;s</title>
  
  <subtitle>学而不思则亡，思而不学则殆。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kouder.cn/"/>
  <updated>2022-03-31T14:08:45.701Z</updated>
  <id>https://kouder.cn/</id>
  
  <author>
    <name>AnakinLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深入理解 ES6-ch4 扩展对象的功能性</title>
    <link href="https://kouder.cn/2022/03/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-ch4%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/"/>
    <id>https://kouder.cn/2022/03/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-ch4%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/</id>
    <published>2022-03-31T14:04:20.000Z</published>
    <updated>2022-03-31T14:08:45.701Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h2><p>现在，属性可以在字面量中直接写</p><pre><code class="javascript">let p = &quot;a b c&quot;;let a = {[p]: &#39;123&#39;;}</code></pre><p>ES5 不能直接写，只能这么写：</p><pre><code class="javascript">var p = &quot;a b c&quot;;var a = { };a[p] = &#39;1 2 3&#39;;</code></pre><h2 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h2><h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>严格相等运算 <code>===</code> 不会触发强制类型转换，但是也有不准确的时候。</p><pre><code class="javascript">+0 === -0 // trueNaN === NaN // false</code></pre><p>在 JS 中，<code>-0</code> 和 <code>+0</code> 是不同的实体。应该是 false。NaN 与自身比较应该是 true。</p><p>ES6 引入了 <code>Object.is()</code> 弥补全局运算符的不准确。</p><p><code>===</code> 与 <code>Object.is()</code> 的唯一区别就是 <code>+0,-0 ,NaN</code> 这两种情况。</p><pre><code class="javascript">Object.is(+0, -0) //falseObject.is(NaN, NaN) // true</code></pre><p>当你的严格相等代码中，有可能出现以上两种情况，考虑使用 Object.is</p><h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h5><p>混合（mixin）是 JS 中对象组合的常见模式。</p><p>例如</p><pre><code class="javascript">function mixin(receiver, supplier){    Object.keys(supplier).forEach(function(key)) {        receiver[key] = supplier[key];    });    return receiver;}</code></pre><p>mixin 函数遍历 supplier 的自有属性并复制到 receiver 中（浅复制）。使得 receiver 可以不通过继承，获得属性。</p><pre><code class="javascript">function EventTarget() {}EventTarget.prototype = {    constructor: EventTarget,    emit: function(){},    on: function(){}};var myObj = {};mixin(myObj, EventTarget.prototype);myObj.emit(&quot;somethingChanged&quot;);</code></pre><p>这里，myObj 接收了 EventTarget.prototype 对象的所有行为，从而可以使用 emit 发布事件，可以通过 on 订阅事件。</p><p>ES6 的 <code>Object.assign</code> 方法实现了上面的 mixin 的功能</p><pre><code class="javascript">Object.assign(接收对象，源对象 1，源对象 2，源对象 3。。。)</code></pre><p>注意，assign 不能复制访问器属性（getter 和 setter），并且访问器属性的 <code>enumerable</code> 是 true 时才能被 assign 方法发现，如下所示：</p><pre><code class="javascript">// assign 不能复制访问器属性let supplier = {    age: 18,}Object.defineProperty(supplier, &#39;year&#39;, {    get() {        console.log(&#39;调用了 get&#39;);        return this.age;    },    set(value) {        console.log(&#39;set 被调用了&#39;);        this.age = value;    },    enumerable: true,})supplier.year = 2022;// 都改成了 2022console.log(supplier.age);console.log(supplier.year);let myObj = {};Object.assign(myObj, supplier);console.log(myObj.age);console.log(myObj.year);myObj.year = 2021;// age 没有变，说明 assign 没有复制访问器属性（getter 和 setter）console.log(myObj.age);console.log(myObj.year);</code></pre><p>supplier 的访问器属性会变为接收器对象的一个数据属性。不再是访问器属性。</p><p>assign 可以接 N 个源对象，排名靠后的对象会覆盖前面的同名属性。</p><h5 id="字面量对象的重复属性"><a href="#字面量对象的重复属性" class="headerlink" title="字面量对象的重复属性"></a>字面量对象的重复属性</h5><p>ES6 字面量中重复定义的属性，不会报错，不管是严格和非严格模式。</p><p>值取最后定义的。</p><h5 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h5><p>ES6 严格规定明确了自有属性被枚举时的返回顺序。</p><p>被影响的方法：Obejct.assign, Object.getOwnPropertyNames,Reflect.ownKeys 等等。</p><p>ES6 没有明确  <code>for-in</code> 循环的属性枚举顺序。Object.keys 和 JSON.stringify 与 for-in 顺序相同，因此 ES6 也没有明确。(Chrome V100 的顺序与 ES 的枚举顺序一致)</p><p>顺序规则：</p><ol><li>数字 key 按升序排序</li><li>字符串 key 按照 ** 被加入对象的顺序 ** 排序</li><li>所有 symbol 按照 ** 被加入对象的顺序 ** 排序</li></ol><pre><code class="javascript">let obj = {    0: 1,    3: 1,    bz: 1,    b: 1,    bb: 1,    az: 1,    ab: 1,    1: 1,    &quot;-2&quot;: 1,    &quot;-1&quot;: 1}obj[2] = 1;obj[-0] = 1;obj[-1] = 1;console.log(Object.getOwnPropertyNames(obj).join(&#39;-&#39;));// Chrome 100 结果：0-1-2-3-bz-b-bb-az-ab--2--1-a</code></pre><ul><li>对于数字，在枚举时被重新排序。</li><li>字符串键在数字键后面。顺序是声明顺序和插入对象的顺序。</li><li>负数只按照前面的 “-” 排序，视为字符串。</li></ul><h5 id="增强的对象原型"><a href="#增强的对象原型" class="headerlink" title="增强的对象原型"></a>增强的对象原型</h5><p>一般情况，无论是构造函数，还是 Object.create 方法创建的对象，原型都是在对象被创建时指定的。</p><p>ES5 的原则是，在实例化之后，对象原型保持不变。但是 ES5 缺少实例化后改变原型的标准方法。ES5 的 <code>Object.getPrototypeOf()</code> 用来返回指定对象的原型。</p><p>在 ES6，又新增了 <code>Obejct.setPrototypeOf()</code> 方法，用来改变指定对象的原型。</p><p>代码如下：</p><pre><code class="javascript">let person = {    getGreeting() {        return &#39;hello&#39;;    }}let dog = {    getGreeting() {        return &#39;baibai&#39;;    }}let friend = Object.create(person);console.log(friend.getGreeting());  // helloconsole.log(Object.getPrototypeOf(friend) === person);  //trueObject.setPrototypeOf(friend, dog);console.log(friend.getGreeting());  // baibaiconsole.log(Object.getPrototypeOf(friend) === dog);  //true</code></pre><h5 id="用来简化原型访问的-Super"><a href="#用来简化原型访问的-Super" class="headerlink" title="用来简化原型访问的 Super"></a>用来简化原型访问的 Super</h5><p>在 ES5，你想重写对象实例的方法，又需要调用与它同名的原型方法，代码如下：</p><pre><code class="javascript">// 在 ES5，你想重写对象实例的方法，又需要调用与它同名的原型方法，代码如下：let person = {    id: &#39;#human&#39;,    getGreeting() {        return this.id + &#39;hello&#39;;    }}let dog = {    id: &#39;animal&#39;,    getGreeting() {        return this.id + &#39;baibai&#39;;    }}let friend = {    id: &#39;#friend&#39;,    getGreeting() {        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;    }}Object.setPrototypeOf(friend, person);console.log(friend.getGreeting());  // #friend hello, hi!</code></pre><p><code>Object.getPrototypeOf(this)</code> 确保得到的是 this（friend）的原型 –person。后面的 call 可以确保 this 的指向的是 friend。如果不加 call，最后打印 <code>#human hello, hi!</code></p><p>ES6 的 super 引用相当于指向对象原型的指针，相当于 <code>Object.getPrototypeOf(this)，</code> 代码如下：</p><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting() {        return super.getGreeting() + &quot;, hi!&quot;;    }}Object.setPrototypeOf(friend, person);console.log(friend.getGreeting());  // #friend hello, hi!</code></pre><blockquote><p>super 不能在非简写方法中使用，会报错 <code>SyntaxError: &#39;super&#39; keyword unexpected here</code>：</p></blockquote><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting: function () {        return super.getGreeting() + &quot;, hi!&quot;;    }}</code></pre><p>多重继承时，用 ES5 的 Object.getPrototypeOf(this)会出现循环引用的问题，代码如下：</p><pre><code class="javascript">// super 对于多重继承很有用let friend = {    id: &#39;#friend&#39;,    getGreeting() {        // ES5 的方式在多重继承时会有问题，造成循环调用        console.log(this.id);        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;   }}Object.setPrototypeOf(friend, person);// relative 原型是 friendlet relative = Object.create(friend);console.log(relative.getGreeting());</code></pre><p>RangeError: Maximum call stack size exceeded。</p><p>因为 <code>relative.getGreeting()</code> 是调用的 <code>friend</code> 的 <code>getGreeting</code> 方法，<code>Object.getPrototypeOf(this)</code> 中的 <code>this</code> 指向的是 <code>relative</code>，调用 <code>Object.getPrototypeOf(this)</code> 的结果返回的就是 <code>friend</code> 对象，此时造成 <code>friend.getGreeting</code> 的循环调用。</p><p>使用 super，以上问题迎刃而解，代码如下：</p><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting() {        // ES5 的方式在多重继承时会有问题，造成循环调用        console.log(this.id);        return super.getGreeting() + &quot;, hi!&quot;;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可计算属性名&quot;&gt;&lt;a href=&quot;#可计算属性名&quot; class=&quot;headerlink&quot; title=&quot;可计算属性名&quot;&gt;&lt;/a&gt;可计算属性名&lt;/h2&gt;&lt;p&gt;现在，属性可以在字面量中直接写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let 
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://kouder.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>排序稳定性有什么用</title>
    <link href="https://kouder.cn/2021/09/05/pai-xu-wen-ding-xing-you-shi-me-yong/"/>
    <id>https://kouder.cn/2021/09/05/pai-xu-wen-ding-xing-you-shi-me-yong/</id>
    <published>2021-09-05T11:38:25.000Z</published>
    <updated>2022-04-01T02:38:05.990Z</updated>
    
    <content type="html"><![CDATA[<p>稳定性还是有用的。</p><a id="more"></a><h1 id="什么是排序算法稳定性"><a href="#什么是排序算法稳定性" class="headerlink" title="什么是排序算法稳定性"></a>什么是排序算法稳定性</h1><p>两个相等元素的相对位置不变，在前的在排序后还是在前，后前的在排序后还是在后。</p><h1 id="稳定性有什么用"><a href="#稳定性有什么用" class="headerlink" title="稳定性有什么用"></a>稳定性有什么用</h1><p>直接举个例子：<br>有四个同学站一起，身高已经按照升序排列：</p><pre><code>zhang san 1.7zhang wu 1.8 li san 1.7li wu 1.8</code></pre><p>此时，你想将这四个同学再按照姓氏的拼音首字母安装升序排序，同时保持身高排序不变。<br>要达到的最终的排序结果应该是：</p><pre><code>li san 1.7li wu 1.8zhang san 1.7zhang wu 1.8</code></pre><p>如果使用非稳定排序算法，例如选择排序，进行排序的结果为：</p><pre><code>li san 1.7li wu 1.8zhang wu 1.8zhang san 1.7</code></pre><p>你会发现，<code>zhang san 1.7</code> 跑到了 <code>zhang wu 1.8</code> 后面去了。<br>而稳定排序就不会出现这种情况。</p><p>总得来说，这个稳定性排序的作用就是在当前排序规则下，不破坏之前的排序规则产生的对当前规则而言相同的元素的相对顺序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;稳定性还是有用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="https://kouder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>2048 游戏</title>
    <link href="https://kouder.cn/2021/08/19/2048-you-xi/"/>
    <id>https://kouder.cn/2021/08/19/2048-you-xi/</id>
    <published>2021-08-19T07:43:10.000Z</published>
    <updated>2021-12-31T07:20:19.282Z</updated>
    
    <content type="html"><![CDATA[<p>自己心血来潮，写的一个 2048。<br>仓库地址：<a href="https://github.com/Anakinliu/2048_Game" target="_blank" rel="noopener">https://github.com/Anakinliu/2048_Game</a><br>在线 Play：/images/game/2048/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自己心血来潮，写的一个 2048。&lt;br&gt;仓库地址：&lt;a href=&quot;https://github.com/Anakinliu/2048_Game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Anakinliu/20
      
    
    </summary>
    
    
    
      <category term="游戏" scheme="https://kouder.cn/tags/%E6%B8%B8%E6%88%8F/"/>
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>动态规划系列 2</title>
    <link href="https://kouder.cn/2021/08/07/dong-tai-gui-hua-xi-lie-2/"/>
    <id>https://kouder.cn/2021/08/07/dong-tai-gui-hua-xi-lie-2/</id>
    <published>2021-08-07T13:58:45.000Z</published>
    <updated>2022-04-01T02:30:35.085Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h1 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h1><h3 id="leetcode-55"><a href="#leetcode-55" class="headerlink" title="leetcode 55"></a>leetcode 55</h3><blockquote><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p></blockquote><p>子问题是, 看能不能跳到 i 位置,<code>i</code> 位置跳不到, 后面的必定更跳不到<br>由于初始站在索引 <code>0</code> 位置, 所以 <code>0</code> 位置是可以跳到的.<code>dp[0] = nums[0]</code><br><code>dp[i]</code> 表示子数组 <code>[0,i]</code> 内可跳的最远的位置<br>当索引到 k, 分两种情况:</p><ol><li><code>k &gt; dp[k - 1]</code>, 则此 <code>k</code> 索引位置不可达, 后面更不能到达, 退出返回 <code>false</code></li><li>更新 <code>dp[k]</code> 后, 若 <code>dp[k]</code> 已经包含最大索引, 则返回 <code>true</code></li></ol><p>JavaScript 代码如下：</p><pre><code class="javascript">var canJump = function (nums) {    // if (nums.length === 1) {    //     return true;    // }    let dp = Array(nums.length).fill(0);    dp[0] += nums[0];    let i = 1;    for (; i &lt; nums.length; i++) {        if (i &gt; dp[i - 1]) {            console.log(&#39;此时 i 为&#39;, i);            return false;        }        dp[i] = Math.max((i + nums[i]), dp[i - 1]);        console.log(dp[i]);        if (dp[i] &gt;= nums.length - 1) {            return true;        }    }    // 只有一个元素的情况直接返回 true    return true};</code></pre><h1 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a>Jump Game II</h1><h3 id="leetcode-45"><a href="#leetcode-45" class="headerlink" title="leetcode 45"></a>leetcode 45</h3><blockquote><p>给定一个非负整数数组 nums，初始时，你还是站在数组第一个元素位置。<br>元素的值表示在此元素位置可以跳的最大距离<br>你的目标是 ** 以最小的跳跃次数 ** 到达最后一个元素<br>你可以假设总能到达最后一个元素。</p></blockquote><h4 id="中文版的官方题解，解法一，贪心："><a href="#中文版的官方题解，解法一，贪心：" class="headerlink" title="中文版的官方题解，解法一，贪心："></a>中文版的官方题解，解法一，贪心：</h4><p>如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？<br>贪心</p><ol><li>从最后一步向前查找, 找哪一个元素可以一步到达最后一个元素</li><li>需要从左向右查找, 这样才能找到距离最后一个元素最远的位置,</li><li>继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。</li></ol><pre><code class="javascript">var jump1 = function (nums) {    let position = nums.length - 1;    let step = 0;    while (position &gt; 0) {        for (let i = 0; i &lt; position; i++) {            if (i + nums[i] &gt;= position) {                position = i;                step += 1;                break;            }        }    }    return step;};</code></pre><p>时间复杂度：当数组全是 1 时，显然是 On<br>空间复杂度：O1</p><h4 id="中文版的官方题解，解法二，贪心："><a href="#中文版的官方题解，解法二，贪心：" class="headerlink" title="中文版的官方题解，解法二，贪心："></a>中文版的官方题解，解法二，贪心：</h4><p>正向查找：</p><ol><li>索引 <code>i</code> 遍历数组</li><li>使用一个变量跟踪当前索引 <code>i</code> 位置可以到达的最大的索引位置。</li><li>当 <code>i</code> 索引到达此位置时，<code>step</code> 就加 <code>1</code>。</li></ol><p><img src="/images/post-images/1628326757211.png" alt=""></p><pre><code class="javascript">    let step = 0;    let maxPos = 0;    let end = 0;  // 边界, 索引到达边界时更新步数和边界    for (let i = 0; i &lt; nums.length - 1; i += 1) {        maxPos = Math.max(maxPos, nums[i] + i);        console.log(&#39;maxPos&#39;, maxPos);        // 边界内有更远的跳跃距离? 那也得建立在这个元素在之前的跳跃距离内这个前提下        // 所以, 需要步数加 1 和更新边界        if (i === end) {            end = maxPos;            step += 1;        }        console.log(step, i);    }    console.log(step);    return step;</code></pre><h1 id="不同路径-II-leetcode63"><a href="#不同路径-II-leetcode63" class="headerlink" title="不同路径 II-leetcode63"></a>不同路径 II-leetcode63</h1><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>动态规划解法：</p><pre><code class="javascript">var uniquePathsWithObstacles = function(obstacleGrid) {    let m = obstacleGrid.length;    let n = obstacleGrid[0].length;    let dp = Array.from(Array(m)).map(() =&gt; Array(n).fill(0));    for(let i=0; i&lt;m; i++) {        // 有障碍物，则后面的不可达        if (obstacleGrid[i][0] === 1) {            break;        }        dp[i][0] = 1;    }    for(let i=0; i&lt; n; i++) {         // 有障碍物，则后面的不可达        if (obstacleGrid[0][i] === 1) {            break;        }        dp[0][i] = 1;    }    for(let i=1; i&lt;m; i++) {        for(let j=1; j&lt; n; j++) {            if (obstacleGrid[i][j] === 1) { // 有障碍物，则不可达                dp[i][j] = 0;            } else {                dp[i][j] = dp[i-1][j] + dp[i][j-1];            }                    }    }    return dp[m-1][n-1];};</code></pre><p>没啥好说的，就是 leetcode62 不同路径加了几个判断。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;h1 id=&quot;Jump-Game&quot;&gt;&lt;a href=&quot;#Jump-Game&quot; class=&quot;headerlink&quot; title=&quot;Jump Game&quot;&gt;&lt;/a&gt;Jump Game&lt;/h1&gt;&lt;h3 id=&quot;leetcode-55&quot;&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="https://kouder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>键盘说明书</title>
    <link href="https://kouder.cn/2021/08/05/jian-pan-shuo-ming-shu/"/>
    <id>https://kouder.cn/2021/08/05/jian-pan-shuo-ming-shu/</id>
    <published>2021-08-05T10:41:15.000Z</published>
    <updated>2022-04-01T02:34:13.880Z</updated>
    
    <content type="html"><![CDATA[<ul><li>锁 win 键：<code>Fn+Win</code> 长按 3 秒</li><li>恢复出厂：<code>左 Win</code>+<code>右 Win</code> 长按 3 秒  </li></ul><p>宏定义：</p><ul><li>设置宏定义按键，需要先进入宏定义层</li><li>进入宏定义需要先进入自定义层，自定义层内可以使用定义好的宏定义按键</li><li><code>Fn + 左 Win</code> 长按 3 秒进入自定义层</li><li>再按 <code>Fn+Esc</code> 进入宏定义层</li><li>按 <code>Fn+a</code> 键就可以定义 a 键触发的宏（除了 win 和 fn 外，其他按键都能设置宏）</li><li>定义完宏后，按 <code>Fn+Esc</code> 退出宏定义层，就进入了自定义层，此时按 a 键就可以使用刚才的宏了</li><li><code>Fn + 左 Win</code> 长按 3 秒退出自定义层</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;锁 win 键：&lt;code&gt;Fn+Win&lt;/code&gt; 长按 3 秒&lt;/li&gt;
&lt;li&gt;恢复出厂：&lt;code&gt;左 Win&lt;/code&gt;+&lt;code&gt;右 Win&lt;/code&gt; 长按 3 秒  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;宏定义：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;设置宏
      
    
    </summary>
    
    
      <category term="备忘录" scheme="https://kouder.cn/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="生活" scheme="https://kouder.cn/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>面试</title>
    <link href="https://kouder.cn/2021/07/28/mian-shi/"/>
    <id>https://kouder.cn/2021/07/28/mian-shi/</id>
    <published>2021-07-28T13:12:17.000Z</published>
    <updated>2022-04-01T02:37:39.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字节提前批一面"><a href="#字节提前批一面" class="headerlink" title="字节提前批一面"></a>字节提前批一面</h1><p><img src="/images/post-images/1627480023579.png" alt=""></p><blockquote><p>😅戴了一小时痛苦面具</p></blockquote><p>面试官先来了自我介绍，好像姓李，名忘了，字节教育那一块的。<br>然后我的自我介绍</p><p>开始：</p><ol><li><p>拿出我的简历，问：说说项目难点，我想了想：没啥难点，之前看了点 session，就说这个吧。说了一堆后，感觉表述混乱了，因为面试官一脸懵逼。又反复问了 session 怎么处理的，没问出个所以然来。面试官最后直接问：说说 session 和 cookie 的区别，cookie 不安全，session 就一定安全？怎么做安全防范？</p></li><li><p>HTTP 和 HTTPS，能够详细说一下 HTTPS，加密过程吗？HTTPS 是否只用了对称加密？</p></li><li><p>TCP 为什么需要三次握手，而不是两次，四次？被怼了好久，都感觉自己背的八股到底对不对了</p></li><li><p>经典问题，GET 和 POST 区别。</p></li><li><p>了解 HTTP1.0 和 2.0 吗？说说区别？</p></li><li><p>开始 JS 的题目了。</p></li><li><p>ES6 的 <code>extends</code> 用过吗？</p></li><li><p>说说 <code>prototype</code> 和 <code>__proto__</code></p><pre><code> function test(){ } let obj = {}</code></pre><p> 以上面代码为例，说说上面 test 和 obj 的 <code>prototype</code> 和 <code>__proto__</code></p></li><li><p>给定代码，写继承</p><pre><code> function father(){     this.test = ()=&gt;{         console.log(1)     } } function son(){} let obj = new son() obj.test()</code></pre><p> 让 <code>son</code> 继承 <code>father</code></p></li><li><p>number 类型的数字过大存不下怎么办？是显示 Infinitely 还是截断截取？学过 C 语言和 Java 没有？它们的数值有没有相关问题？</p></li><li><p><code>0.1+0.2</code> 的结果（数值相关的问题追着问我了好久）</p></li><li><p>使用 JS 实现一个 repeat 方法，</p><pre><code>function repeat (func, times, wait) {}，const repeatFunc = repeat(alert, 4, 3000),</code></pre><p>调用这个 repeatedFunc(“hellworld”)，<br>会 <code>alert</code>4 次 helloworld, 每次间隔 3 秒<br>我写的代码：不知道对不对。。。先粘这</p><pre><code>function repeat(func, times, wait) {let t = times;let lock = null;return (arg) =&gt; {        while (times &gt; 0) {            if (lock !== null &amp;&amp; times &gt; 0) {                lock = setInterval(() =&gt;{                func(arg);                times -= 1;                lock = null;            }, wait)            }        }    }}</code></pre></li><li><p>说说基本类型，我写了六个，面试官提示有七个，我说还有 BigInt，只知道存储大整数的。</p></li><li><p>apply,call,bind 的区别</p></li><li><p>你说熟悉 balabala 数据结构，挑一个数据结构，我出个题。我挑的数组。给的是求数组最大序列和，与 leetcode 不同，要求给出最大序列和的具体索引。<br>我当时写的代码：是不对的，先粘这</p><pre><code>function solu(arr) {    let pre = arr[0];    let maxAns = arr[0];    let q = [0];    for (let idx = 1; idx &lt; arr.length; idx++) {        pre = Math.max(pre + arr[idx], arr[idx]);        if (pre === arr[idx]) {            q = [];            q.push(idx);        } else {            q.push(idx-1);            q.push(idx);        }        maxAns = Math.max(pre, maxAns);    }    let res = [];    for (let i of q) {        res.push(arr[i]);    }    return res;}</code></pre></li><li><p>反问，技术栈？我需要补充哪些知识？</p><blockquote><p>面试官： 大部分是 React，也有 Vue，看具体场景。你的基础知识不好。我感觉对应届生来说，上来就要你多少多少框架的公司并不好。计网，HTTP，TCP，JS 的基础问题是面试必定会问的，要多看。基础，JS 基础要多看多练，闭包和原形是重点，原形又会引入继承。框架不用太深入。工作两三年的我才会问框架问题。</p></blockquote></li></ol><ul><li>面试官男的，胖胖的，看起来年纪比我大，或者说老成？全程表情感觉没啥变化。我笑的时候他没表情，感觉很尴尬😅*</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Q T M D 八股文，平时感觉记得好，一到了面试时会结结巴巴，看来还是要尽量理解才能记得准，记得牢。</li><li>JS 砖头书要拿起来啃，但是感觉来不及了啊。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字节提前批一面&quot;&gt;&lt;a href=&quot;#字节提前批一面&quot; class=&quot;headerlink&quot; title=&quot;字节提前批一面&quot;&gt;&lt;/a&gt;字节提前批一面&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;/images/post-images/1627480023579.png&quot; a
      
    
    </summary>
    
    
      <category term="备忘录" scheme="https://kouder.cn/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
      <category term="工作" scheme="https://kouder.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>又停运了</title>
    <link href="https://kouder.cn/2021/07/21/you-ting-yun-liao/"/>
    <id>https://kouder.cn/2021/07/21/you-ting-yun-liao/</id>
    <published>2021-07-21T03:44:18.000Z</published>
    <updated>2022-04-01T02:43:18.240Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>来的时候停运，走的时候又停运，刚才 12306 发短信，列车停运，要我退票了。<br>今年的暴雨是不是有点多啊。。。</p><p><img src="/images/post-images/1626839114729.png" alt=""></p><p>郑州好像是几十年一遇的大雨。。。<br>祝大家平安吧</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;

&lt;p&gt;来的时候停运，走的时候又停运，刚才 12306 发短信，列车停运，要我退票了。&lt;br&gt;今年的暴雨是不是有点多啊。。。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/post-images/1626839114729.png&quot; alt
      
    
    </summary>
    
    
      <category term="备忘录" scheme="https://kouder.cn/categories/%E5%A4%87%E5%BF%98%E5%BD%95/"/>
    
    
  </entry>
  
  <entry>
    <title>位运算</title>
    <link href="https://kouder.cn/2021/07/14/wei-yun-suan/"/>
    <id>https://kouder.cn/2021/07/14/wei-yun-suan/</id>
    <published>2021-07-14T12:24:25.000Z</published>
    <updated>2022-04-01T02:42:17.290Z</updated>
    
    <content type="html"><![CDATA[<p>涉及到位运算的数据结构与算法题。</p><a id="more"></a><h1 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h1><blockquote><p>该题很容易出现在各大厂的面试中，属于必须掌握的题型。</p></blockquote><p>题目描述：</p><blockquote><p>求 1 至 n 连续 n 个数的和。要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。<br>1 &lt;= n &lt;= 10000</p></blockquote><p>解法一：<br>直接等差求和公式显然不行，因为包含乘除法。不行。吗？逻辑右移搞定！</p><p>代码：</p><pre><code>// 套公式加位运算function sumF(n) {    return (Math.pow(n, 2) + n) &gt;&gt;&gt; 1;  // 无符号右移，不过这里有没有符号都一样，因为 n 是正整数}</code></pre><p>解法二：</p><p>递归要有终止条件，需要 if 判断，也不行。吗？可以使用逻辑判断运算符绕过！嘻嘻</p><p>为了对比，先写一个无限制的递归版吧：</p><pre><code>// 正常递归版function sumN(n) {    if (n &lt;= 0) {        return 0;    }    return n + sumN(n - 1);}</code></pre><p>使用逻辑或运算：</p><pre><code>// 使用逻辑运算function sumH(n) {    return n &gt; 0 &amp;&amp; (n + (sumH(n - 1)));}</code></pre><p>这里利用了 JavaScript 逻辑运算的特殊性。即逻辑运算返回值保持表达式原值！</p><h1 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h1><blockquote><p>给定一个整数 n，编写一个函数来判断它是否是 2 的幂次方。<br>$-2^{31} &lt;= n &lt;= 2^{31} - 1$<br>进阶：你能够不使用循环 / 递归解决此问题吗？</p></blockquote><p>解法一：<br>利用位运算中的按位或运算。2 的幂都是首 1 全 0 的二进制。<br>while 循环加位运算：</p><pre><code>function is2(n) {    if (n &lt;= 0) {        return false;    }    while (true) {        if (n === 1) {            return true;        }        if (n &amp; 1 === 1) {            // 说明 n 的二进制表示中最后一个二进制位是 1            return false;        }        n = n &gt;&gt;&gt; 1;    }}</code></pre><p>解法二：<br>利用 2 的幂的二进制，减去一，是全 1 的二进制。</p><pre><code>var isPowerOfTwo = function(n) {    return n &gt; 0 &amp;&amp; (n &amp; (n-1)) === 0;};</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>和小浩学算法. pdf</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;涉及到位运算的数据结构与算法题。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="https://kouder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="https://kouder.cn/2021/07/13/pai-xu/"/>
    <id>https://kouder.cn/2021/07/13/pai-xu/</id>
    <published>2021-07-13T13:22:56.000Z</published>
    <updated>2022-04-01T02:37:50.822Z</updated>
    
    <content type="html"><![CDATA[<p>一直学，一直忘。希望这此能记牢。。</p><a id="more"></a><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><p>分两个函数。</p><p>一个函数用来进行分区。<br><img src="/images/post-images/1626182880904.png" alt=""></p><p>当递归到区间只有一个元素时，就可以视作排序完成而返回了。此时 p 两边的数组区间就排好序了。<br><img src="/images/post-images/1626182792717.png" alt=""></p><p>另一个函数被递归调用，以对分区进行排序。<br><img src="/images/post-images/1626183064779.gif" alt=""></p><p>分区函数中，哨兵元素可以随机取 <code>[l,r]</code> 内的值。取区间最右的值比较方便。<br>可以理解为分为四个区间：<br><img src="/images/post-images/1626183975710.png" alt=""></p><p>上图中，<code>[left, i)</code> 为小于哨兵的元素，图中为蓝色区间。<code>[i,j}</code> 为大于哨兵的元素，红色区间。<code>[j,r)</code> 为待比较元素，灰色区间。哨兵自己构成一个区间。</p><ul><li>当前比较的元素小于哨兵时，交换当前比较的元素与 <code>i</code> 指向的元素，并且 <code>i</code>，<code>j</code>，都加 1。</li><li>当前比较的元素大于哨兵时，只需 <code>j</code> 加 1 即可。</li></ul><p>JavaScript 完整代码：</p><pre><code>function quickSort(arr, l, r) {    if (r &lt;= l) {        return    }    let q = partition(arr, l, r);    console.log(q);    quickSort(arr, l, q - 1);    quickSort(arr, q + 1, r);}function partition(arr, l, r) {    let p = r;  // 可以随机选取 [l,r] 内的值, 这里选取最右作为哨兵索引    // 将哨兵放到最右边, 便于排序.    // 由于这里选取的是 r, 所以不用交换了    // [arr[p], arr[r]] = [arr[r], arr[p]];    let i = l;    for (let j = l; j &lt;= r - 1;) {        if (arr[j] &lt;= arr[r]) {            [arr[i], arr[j]] = [arr[j], arr[i]];            i += 1;        }         j += 1;    }    // 交换哨兵和比哨兵大的元素, 此时哨兵的位置就是最终位置了    [arr[i], arr[r]] = [arr[r], arr[i]];    return i;}</code></pre><p>递归版的参考视频，图片来源：<br><a href="https://www.bilibili.com/video/BV1rV411j7f6" target="_blank" rel="noopener">五点七边</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一直学，一直忘。希望这此能记牢。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="https://kouder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>查找</title>
    <link href="https://kouder.cn/2021/07/12/cha-zhao/"/>
    <id>https://kouder.cn/2021/07/12/cha-zhao/</id>
    <published>2021-07-12T11:36:03.000Z</published>
    <updated>2022-04-01T02:29:10.617Z</updated>
    
    <content type="html"><![CDATA[<p>找出一个数，这个数需要去按照某种规则查找。</p><a id="more"></a><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>尤其常用来在递增或递减区间中搜索目标值。</p><p>2021-7-13 补充 - 开始：<br>讲解视频：<a href="https://www.bilibili.com/video/BV1d54y1q7k7" target="_blank" rel="noopener">五点七边</a><br>新的角度：<br>视频中，二分查找的目的就是，找出蓝红边界出来：<br><img src="/images/post-images/1626178992983.png" alt=""><br>求出的未知数 k or k-1 就是解。<br>需要注意，视频的算法与晚上流传的代码不同：</p><ol><li>两侧的指针是从 <code>数组之外</code> 的地方作为初始值，向内移动的。<br><img src="/images/post-images/1626179230225.png" alt=""></li><li>修改 left 与 right 时，都是直接赋值为 m。</li><li>返回值根据实际情况设置为 left 或者 right。</li></ol><p>伪代码：<br><img src="/images/post-images/1626179331019.png" alt=""><br>查找流程动图（动图有点大）：<br><img src="/images/post-images/1626179616183.gif" alt=""></p><p>问 1：<br>为什么不初始化 left 为数组第一个值 0 或者 right 初始化为 N-1 呢？<br>答：考虑数组全是红色的情况，如果全为红色，left 指向的是蓝色元素，这就矛盾了。right 同理。<br>问 2：<br>中间的 mid 值是否始终在 <code>[0,N)</code> 内取值？<br>答：YES。看图<br><img src="/images/post-images/1626179940434.png" alt=""><br>问 3：<br>更新 left 或者 right 时，能不能写成 <code>mid=left+1</code>or<code>mid=right-1</code>?<br>答：可以但没必要。不容易理解并且容易犯错。当 mid 正好在边界时，不好理解怎么 left 或者 righ 更新。<br><img src="/images/post-images/1626180182746.png" alt=""><br>问 4：<br>程序会死循环吗？<br>答：不会。首先，left + 1 === right 时，退出循环。<br>left + 2 === right 时，left 或者 right 更新后变为 left + 1 === right。<br>left+3 === right 时，left 或者 right 更新后变为 left + 2 === right。<br>以此类推<br><img src="/images/post-images/1626180481853.png" alt=""></p><p>总结：二分的一般流程。<br><img src="/images/post-images/1626180642667.png" alt=""></p><p>2021-7-13 补充 - 结束</p><p>在最简单的形式中，二分查找对具有指定左索引和右索引的连续序列进行操作。我们也称之为查找空间。二分查找维护查找空间的左、右和中间指示符，并比较查找目标；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。<br>当然，一般题目不太可能给你一个如此现成的题型，让你上手就可以使用二分，所以我们需要思考如何构造一个成功的二分查找：</p><ul><li>预处理过程（大部分场景就是对未排序的集合进行排序）</li><li>二分查找过程（找到合适的循环条件，每一次将查找空间一分为二）</li><li>后处理过程（在剩余的空间中，找到合适的目标值）</li></ul><p>实现二分查找解决题目时注意：</p><ul><li>初始条件</li><li>终止</li><li>向左查找</li><li>向右查找</li></ul><p>二分查找的题目，基本逃不出三种：找特定值，找大于特定值的元素（上界），找小于特定值的元素（下<br>界）。而根据这三种，代码又最终会转化为以下这些问题：</p><ul><li>low，high 要初始化为 0、n-1 还是 0、n 又或者是 1，n？</li><li>循环的判定条件是 <code>low&lt;high</code> 还是 <code>low &lt;= high</code>?</li><li>if 的判定条件应该怎么写？</li><li>if 条件正确时，应该移动哪边的边界？</li><li>更新 low 和 high 时，mid 如何处理？</li></ul><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p><a href="https://leetcode.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">leetcode 875</a></p><blockquote><p>这里总共有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。 阿珂可以决定她吃香蕉的速度 K （单位：根 / 小时），每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 H 小时内吃掉所有香蕉的最小<br>速度 K（K 为整数）。</p></blockquote><p>示例：</p><blockquote><p>输入: piles = [3,6,7,11], H = 8<br>输出: 4<br>输入: piles = [30,11,23,4,20], H = 5<br>输出: 30<br>输入: piles = [30,11,23,4,20], H = 6<br>输出: 23</p></blockquote><p>解答：化为二分查找问题。初始时，下边界就是每次吃一个，上边界就是每次吃数组最大值。要求的 k 就是每次吃 k 个，每次吃 k 个需要的小时数大于等于 h（因为 k 可能不是整数，但是题目显然要求整数，所以说解是大于等于 h 的）。</p><p><img src="/images/post-images/1626095717215.png" alt=""></p><p>Javascript 代码为：</p><pre><code>function eatBan(arr, h) {    function canEat(k) {        let sumH = 0;        for (let i = 0; i &lt; arr.length; i++) {            if (arr[i] % k === 0) {                sumH += arr[i] / k;            } else {                sumH += Math.ceil(arr[i] / k);            }        }        return sumH &gt; h;    }    let left = 1;  // 存在一种可能, 立马吃完: arr=[5], h=4    let right = Math.max(...arr);    // 版本一 while    while (left &lt; right) {        mid = Math.floor(left + (right - left) / 2);        if (canEat(mid)) {  // 全吃了需要的时间 sumH 大于警卫休息时间 h, 即吃不完, 所以每次要多吃点, 增加最小值            left = mid + 1;  // left 时可以取到与 right 相等的值的        } else {  // 需要的时间小于警卫休息时间, 慢慢吃, 缩减最大值            right = mid;  // 因为最后解出的 sumH 会大于等于 h, 所以这里不要 mid-1 !!!        }    }    // 版本二 while    while (left &lt;= right) {        mid = Math.floor(left + (right - left) / 2);        if (canEat(mid)) {              left = mid + 1;        } else {              right = mid - 1;        }}    // 两个版本都是返回 left    return left;}</code></pre><p>代码解释就看注释。</p><p>假如我们的阿珂就是笨笨的，将 low 初始化成了 0，high 变为 <code>max(...arr) + 1</code>，此时的循环条件应该如何写?</p><p>参考 b 站那个五点七边 up 的视频</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">leetcode 69</a></p><blockquote><p>给定一个非负整数 x，计算并返回 x 的平方根。<br>由于返回类型是整数，所以小数位被截断，只返回结果的整数部分。<br>注意：不允许使用任何内置指数函数或运算符。</p></blockquote><p>解答：很明显可以直接使用二分。不能用内置指数函数，乘法是可以用的。<br>不过要注意，由于是正整数，所以当 x 大于 1 时，sqrt(x) 取整后必定小于等于 <code>x/2</code>。故，若将上边界设为 <code>x/2</code>，对 1 和 0 进行特判即可。<br>JS 代码如下：</p><pre><code>// 把 mid*mid === x 与 mid*mid &lt; x 融合function mySqrt2(x) {    if (x === 1) {        return x;    }    let left = 2;    let right = Math.floor(x / 2);    // 版本一的 while，上取整    while (left &lt; right) {        let mid =  Math.ceil(left + (right - left) / 2);        if (mid * mid &gt; x) {            right = mid - 1;        } else {            left = mid;        }    }    // 版本二的 while，下取整    while (left &lt;= right) {        let mid = Math.floor(left + (right - left) / 2);        if (mid * mid &gt; x) {            right = mid - 1;        } else {            left = mid + 1;        }    }    // 两种版本都是返回 while    return right;  // 为什么是 right?}</code></pre><p>代码需要注意的地方：</p><ol><li><p>代码二的 left 是需要搭配 <code>left&lt;=right</code>，这也导致也进一步扩大了搜索空间。有些数，代码二要比代码一多计算一次。</p></li><li><p>出循环时，代码二的 right 永远是比 left 小 1 的。代码一则情况不一。</p></li><li><p>为什么返回值是 right? 就版本一来说：因为 <code>mid+1</code> 和 <code>mid-1</code> 中，若有满足条件的值，则只有可能是 mid-1.<br>答：</p><ul><li><p><code>mid * mid &lt; x</code>，假设 x 是 10，mid 是 3，解是 3，但是 <code>mid * mid &lt; x</code>，所以 <code>left = mid + 1</code> 后，left 就不是解了。</p></li><li><p><code>mid * mid &gt; x</code>，假设 x 是 10，mid 是 4，解是 3，但是 <code>mid * mid &gt; x</code>，所以 mid 变为 3，就是解。</p><p>我们通过不停的缩小搜索空间，最终 left 就变成我们要找的 mid 值，所以直接返回 left 就可以了。</p></li></ul></li></ol><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p><a href="https://leetcode.com/problems/first-bad-version/" target="_blank" rel="noopener">leetcode 278</a></p><blockquote><p>第一个错误的版本<br>假设你有 n 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。<br>题目给定 <code>isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。尽量减少对调用 API 的次数。</p></blockquote><p>解答：没啥好解释的。就是把比较大小直接变为了比较布尔值。。。</p><pre><code>var solution = function(isBadVersion) {    /**     * @param {integer} n Total versions     * @return {integer} The first bad version     */     return function(n) {        let left = 1;        let right = n;        while (left &lt; right) {            let mid = left + Math.floor((right - left) / 2);            if (isBadVersion(mid)) {                right = mid;            } else {                left = mid+1;            }        }        console.log(left, right)        return left;    };};</code></pre><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><p>剑指 Offer 的面试题三的题目二：<br>题目描述：</p><blockquote><ul><li>在长度为 1+n 的数组里，所有数字元素大小为 [1,n]，显然包含至少一个重复的数字。找出其中任一重复的数字。注意，不能修改输入的数组</li></ul></blockquote><p>使用额外数组的解法就不说了，因为不是二分思想。<br>二分思想的解法：<br>看看这个 1-n 这 n 个数字，对着 n 个有序数字进行二分，每次都对一个区间内的数字到输入数组中计数。例如，若 1-k 这连续的 k 个数字在输入数组中出现的次数大于 k 次，说明，1-k 内又重复数字，可以缩小范围继续搜索。</p><pre><code>function findDuplicate(arr) {    function counts(left, right) {        let count = 0;        for (let e of arr) {            if (e &gt;= left &amp;&amp; e &lt;= right) {                count += 1;            }        }        return count;    }    let left = 1    let right = arr.length - 1;    // 从 left 到 right 是有序的    while (left &lt;= right) {        let mid = left + Math.floor((right - left) / 2)        let count = counts(left, mid)        if (left === right) {            if (count &gt; 1) {                return left;            } else {                return -1            }        }        if (count &gt; (mid + 1 - left)) {            right = mid;        } else {            left = mid + 1;        }    }}</code></pre><p>按照 B 站视频的解法模板，代码显得又比较复杂了：</p><pre><code>function findDuplicate(arr) {    function counts(left, right) {        let count = 0;        for (let e of arr) {            if (e &gt;= left &amp;&amp; e &lt;= right) {                count += 1;            }        }        return count;    }    let left = 1;      let right = arr.length - 1;      // 从 left 到 right 是有序的    while (left + 1 !== right) {        let mid = left + Math.floor((right - left) / 2)        let count = counts(left, mid)        if (count &gt; (mid - left) + 1) {            right = mid;        } else {            left = mid;        }    }    // 确定返回 left 还是 right    if (counts(left, left) &gt; 1) {        return left    } else if (counts(right, right) &gt; 1) {        return right;    } else {        return -1;    }}</code></pre><ol><li>建模，红色区域和蓝色区域的意义：蓝色指针及其左边区域无重复数字；红色指针及其右边区域无重复数字。并确定用来判断的函数 <code>counts</code><br><img src="/images/post-images/1626852387545.png" alt=""></li><li>套用模板<br><img src="/images/post-images/1626852595463.png" alt=""></li><li>确定返回 left 还是 right</li></ol><h2 id="总结二分查找"><a href="#总结二分查找" class="headerlink" title="总结二分查找"></a>总结二分查找</h2><p>大家一定要明确 mid 的真正含义有两层</p><ol><li>我们通过 mid 值来收敛搜索空间。如题一</li><li>题目最后的 mid 值（或者说 left，right）就是我们要找的目标值。如题二</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>和小浩学算法. pdf</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;找出一个数，这个数需要去按照某种规则查找。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="https://kouder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LRU 缓存</title>
    <link href="https://kouder.cn/2021/07/05/lru-huan-cun/"/>
    <id>https://kouder.cn/2021/07/05/lru-huan-cun/</id>
    <published>2021-07-05T06:57:29.000Z</published>
    <updated>2022-04-01T02:36:49.565Z</updated>
    
    <content type="html"><![CDATA[<p>如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：<code>get</code> 和 <code>put</code>。</p><ul><li><code>get(key)</code>- 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</li><li><code>put(key, value)</code> - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。</li></ul><blockquote><p>输入：<br>[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3<br>返回值：<br>[1,-1]<br>说明：<br>第一次操作后：最常使用的记录为(“1”, 1)<br>第二次操作后：最常使用的记录为 (“2”, 2)，(“1”, 1) 变为最不常用的<br>第三次操作后：最常使用的记录为 (“3”, 2)，(“1”, 1) 还是最不常用的<br>第四次操作后：最常用的记录为 (“1”, 1)，(“2”, 2) 变为最不常用的<br>第五次操作后：大小超过了 3，所以移除此时最不常使用的记录 (“2”, 2)，加入记录(“4”, 4)，并且为最常使用的记录，然后(“3”, 2) 变为最不常使用的记录</p></blockquote><h2 id="使用单链表"><a href="#使用单链表" class="headerlink" title="使用单链表"></a>使用单链表</h2><p>单链表便于频繁的插入删除操作。<br>只需要在链表头部插入，尾部删除。<br>为了在头部插入方便，代码使用了无数据的头结点 head。</p><pre><code>/** * lru design * @param operators int 整型二维数组 the ops * @param k int 整型 the k * @return int 整型一维数组 */function LRU(operators, limit) {    // 定义链表数据结构    class Node {        constructor(key, value, next = null) {            this.key = key;            this.value = value;            this.next = next;        }    }    // head 不计入链表总个数，其 next 指向第一个 node    let head = new Node(Number.MIN_VALUE, Number.MIN_VALUE);    const resArr = [];    for (const [op, k, v] of operators) {        let temp = head.next;        let pre = head;        if (v) { // put            while (temp) {                // key 已经存在                if (temp.key === k) {                    let node = new Node(k, v);                    // 删除此节点                    pre.next = temp.next;                    // 插入新节点                    let t = head.next;                    head.next = node;                    node.next = t;                    break;                }                pre = pre.next;                temp = temp.next;            }            if (temp === null) {  // key 不存在，插入这个 key 的节点时，需要判断整个链表是否是满的！                let node = new Node(k, v);                let t = head.next;                head.next = node;                node.next = t;            }        } else { // get 操作            while (temp) {                // key 存在                if (temp.key === k) {                    // console.log(temp.value);                    resArr.push(temp.value);                    let node = new Node(k, temp.value);                    // 删除此节点                    pre.next = temp.next;                    // 插入新节点                    let t = head.next;                    head.next = node;                    node.next = t;                    break;                }                pre = pre.next;                temp = temp.next;            }            // 没找到，返回 - 1            if (temp === null) {                // console.log(-1);                resArr.push(-1);            }        }        // 截断链表        let i = 1;        temp = head;        while (i &lt;= limit &amp;&amp; temp) {            temp = temp.next;            i += 1;        }        if (temp) {            temp.next = null;        }    }    return resArr;}</code></pre><p>时间复杂度：O(N)，因为查找 key 需要遍历链表。<br>空间复杂度：O(limit)</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://juejin.cn/post/6844903855726002189" target="_blank" rel="noopener">https://juejin.cn/post/6844903855726002189</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="https://kouder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>我的世界模组</title>
    <link href="https://kouder.cn/2021/07/01/wo-de-shi-jie-mo-zu/"/>
    <id>https://kouder.cn/2021/07/01/wo-de-shi-jie-mo-zu/</id>
    <published>2021-07-01T11:24:06.000Z</published>
    <updated>2022-04-01T02:42:29.251Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><p>现在模组都推荐使用 Fabric 了啊，好久没玩了，以前都没听说过 Fabric。。。<br>启动器 HMCL 的官网也打不开了。。。<br>用了一个新的启动器：NsisoLauncher</p><p><img src="/images/post-images/1625148109077.png" alt=""></p><h1 id="2021-7-1"><a href="#2021-7-1" class="headerlink" title="2021-7-1"></a>2021-7-1</h1><ul><li>连锁采集。<a href="https://www.curseforge.com/minecraft/mc-mods/diggus-maximus" target="_blank" rel="noopener">Diggus Maximus</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;a id=&quot;more&quot;&gt;&lt;/a&gt;
&lt;p&gt;现在模组都推荐使用 Fabric 了啊，好久没玩了，以前都没听说过 Fabric。。。&lt;br&gt;启动器 HMCL 的官网也打不开了。。。&lt;br&gt;用了一个新的启动器：NsisoLauncher&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images
      
    
    </summary>
    
    
      <category term="GAME" scheme="https://kouder.cn/categories/GAME/"/>
    
    
      <category term="游戏" scheme="https://kouder.cn/tags/%E6%B8%B8%E6%88%8F/"/>
    
  </entry>
  
  <entry>
    <title>最小的 K 个数</title>
    <link href="https://kouder.cn/2021/06/30/zui-xiao-de-k-ge-shu/"/>
    <id>https://kouder.cn/2021/06/30/zui-xiao-de-k-ge-shu/</id>
    <published>2021-06-30T13:00:14.000Z</published>
    <updated>2022-04-01T02:44:44.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>给定一个数组，找出其中最小的 K 个数。例如数组元素是 4,5,1,6,2,7,3,8 这 8 个数字，则最小的 4 个数字是 1,2,3,4。如果 K &gt; 数组的长度，那么返回一个空的数组</p></blockquote><h2 id="复习-堆"><a href="#复习-堆" class="headerlink" title="复习 - 堆"></a>复习 - 堆</h2><p><a href="https://www.bilibili.com/video/BV1Eb41147dK" target="_blank" rel="noopener">详细图解参考 b 站视频</a></p><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><ol><li>是完全二叉树<blockquote><p>完全二叉树：从上到下，从左到右添加节点</p></blockquote></li><li>每一颗子树的父节点大于子节点</li></ol><h3 id="堆的表示"><a href="#堆的表示" class="headerlink" title="堆的表示"></a>堆的表示</h3><p>使用一维数组即可。数组元素顺序就是层次遍历堆的结果。<br>由于是完全二叉树，所以可以由一个节点的数组索引，准确定位其直接父节点和直接子节点。</p><pre><code>假设从 0 开始索引为 i 的元素在堆中对应的直接父节点为：Math.floor((i - 1) / 2)左孩子为：2 * i + 1右孩子为：2 * i + 2</code></pre><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>操作过程：从一个节点开始，将这个节点及其所有子节点构成的完全二叉树变为堆的过程。</p><blockquote><p>这个操作不用于整个完全二叉树完全打乱的状态。</p></blockquote><p>heapify 的实现：</p><pre><code>function heapify(arr, n, i) {    // n: 使用的 arr 长度, 从 0 开始    // i: 当前节点的索引位置    // arr: 一维数组表示的堆    // 递归的结束条件    if (i &gt;= n) {        return;    }    let max = i;    const left = 2 * i + 1;    const right = 2 * i + 2;    // 比较其左右节点与自身的三个值, 得到最大值    if (left &lt;= n &amp;&amp; arr[left] &gt; arr[max]) {        max = left;    }    if (right &lt;= n &amp;&amp; arr[right] &gt; arr[max]) {        max = right;    }    if (max !== i) {        swap(arr, i, max);        heapify(arr, n, max);    } else {        return  // max 就是 i 时不用解了, 退出    }}</code></pre><h3 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h3><p>用于将一整个完全打乱状态的完全二叉树变为堆。</p><p>从所有叶子节点的直接父节点开始，自底向上进行 heapify 操作。</p><p>整个完全二叉树的最后一个 / 两个叶子节点的父节点可以由上面的方法得到：</p><pre><code>Math.floor((n - 1) / 2)  // n 是数组最后元素下标。</code></pre><p>构建堆时，所有叶子节点的直接父节点就是依次减去 1. 直到为 0</p><p><img src="/images/post-images/1625106635696.png" alt=""></p><pre><code>function buildHeap(arr) {    // 需要借助 heapify 方法    let last = arr.length - 1;    last = Math.floor((last - 1) / 2);    while (last &gt;= 0) {        heapify(arr, arr.length - 1, last);        last -= 1;    }}</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>构建一个升序数组：<br>先构建堆，此时完全二叉树的根节点是整个数组的最大值，然后每次交换完全二叉树的根节点和完全二叉树的最后一个节点，然后忽略最后一个节点进行 heapify 操作，heapify 操作后完全二叉树的根节点成为了第二大值，依次类推，当只有一个数时，就是最小值了。。。</p><pre><code>function sortByHeap(arr) {    buildHeap(arr);    let n = arr.length - 1;    const sortedArr = [];    while (n &gt;= 0) {        sortedArr.push(arr[0]);        swap(arr, 0, n);        // 不用截断数组, 直接把 arr 长度 &quot;改掉&quot;        heapify(arr, n - 1, 0);        n -= 1;    }    return sortedArr;}</code></pre><h2 id="解法-1：直接排序"><a href="#解法-1：直接排序" class="headerlink" title="解法 1：直接排序"></a>解法 1：直接排序</h2><p>好家伙，直接排序 + 截取数组！</p><pre><code>function GetLeastNumbers_Solution(input, k){    // write code here    if (k &gt; input.length) {        return [];    }    let sortedArr = input.sort((a,b) =&gt; a-b);    return sortedArr.slice(0,k);}</code></pre><ul><li>时间复杂度：取决于 JavaScript 实现 sort 函数的方式，就算做 O(NlogN) 吧</li><li>空间复杂度：借助了辅助数组存储排序后的数组，明显是 O(N)</li></ul><p>估计面试这么写会让面试官感觉比较拉🤡</p><h2 id="解法-2：堆排序"><a href="#解法-2：堆排序" class="headerlink" title="解法 2：堆排序"></a>解法 2：堆排序</h2><p>注意题目是构建小根堆。</p><pre><code>function GetLeastNumbers_Solution(input, k) {    // write code here    if (k &gt; input.length) {        return [];    }    function swap(arr, i, j) {        const temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }    // 从一个节点, 开始自上至下    function heapify(arr, n, i) {        // n: 使用的 arr 长度, 从 0 开始        // i: 当前节点的索引位置        // arr: 一维数组表示的堆        // 递归的结束条件        if (i &gt;= n) {            return;        }        let min = i;        const left = 2 * i + 1;        const right = 2 * i + 2;        // 比较其左右节点与自身的三个值, 得到最大值        if (left &lt;= n &amp;&amp; arr[left] &lt; arr[min]) {            min = left;        }        if (right &lt;= n &amp;&amp; arr[right] &lt; arr[min]) {            min = right;        }        if (min !== i) {            swap(arr, i, min);            heapify(arr, n, min);        } else {            return  // min 就是 i 时不用解了, 退出        }    }    function buildHeap(arr) {        // 需要借助 heapify 方法        let last = arr.length - 1;        last = Math.floor((last - 1) / 2);        while (last &gt;= 0) {            heapify(arr, arr.length - 1, last);            last -= 1;        }    }    // 前 k 个    function sortByHeap(arr, k) {        buildHeap(arr);        let n = arr.length - 1;        const sortedArr = [];        const stop = n - k;        while (n &gt; stop) {            sortedArr.push(arr[0]);            swap(arr, 0, n);            // 不用截断数组, 直接把 arr 长度 &quot;改掉&quot;            heapify(arr, n - 1, 0);            n -= 1;        }        return sortedArr;    }    // console.log(sortByHeap(input, k));    return sortByHeap(input, k);}// const arr = [7, 9, 11, 15, 17, 6, 13];// GetLeastNumbers_Solution(arr, 3)</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;给定一个数组，找出其中最小的 K 个数。例如数组元素是 4,5,1,6,2,7,3,8 这 8 个
      
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="https://kouder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反转链表</title>
    <link href="https://kouder.cn/2021/06/30/fan-zhuan-lian-biao/"/>
    <id>https://kouder.cn/2021/06/30/fan-zhuan-lian-biao/</id>
    <published>2021-06-30T11:34:54.000Z</published>
    <updated>2022-04-01T02:31:28.960Z</updated>
    
    <content type="html"><![CDATA[<p>输入一个链表，反转链表后，输出新链表的表头。</p><a id="more"></a><p>从大一就开始学，学了忘，忘了学。。。<br>所有代码为 JavaScript 代码，牛客上运行通过。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><pre><code>function reverseList(Node head) {    let prev = null;    let curr = head;    while (curr) {        let next = curr.next;        curr.next = prev;        prev = curr;        curr = next;    }    return prev;}</code></pre><p><code>prev</code> 保存前一个节点（可以想象为虚的 val 无意义额定头结点，它的 next 指向链表第一个节点，这样好理解），<code>curr</code> 为当前要反转的节点，<code>next</code> 为后面的节点（下一次循环去反转的节点）。<br><img src="/images/post-images/1625055473869.png" alt=""><br>橙色和红色表示第一次，第二次循环。</p><ul><li>时间复杂度显然是链表长度 N</li><li>空间复杂度只用了两个额外的遍历，故为 O(1)</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>我可以看懂的伪递归：</p><pre><code>function ReverseList(head){    function reverse(prev, curr) {        if (curr === null) {            return prev;        }        let next = curr.next;        curr.next = prev;        return reverse(curr, next);    }    return reverse(null, head);}</code></pre><p>其实就是把迭代的变量用函数的参数保存了。所以说是 “伪递归”。<br>由于是在 return 中直接调用函数，所以是尾调用。<br>又因为尾调用函数是自身，所以是尾递归。。。</p><blockquote><p>调用及尾递归可以参考 <a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">阮一峰大佬的博客</a></p></blockquote><ul><li>时间复杂度：递归执行 N 次，故 O(N)</li><li>空间复杂度：递归执行 N 次，每次都要保存几个变量，O(mN)，m 为变量个数，故为 O(N)，尾递归优化后可能会降低空间复杂度。</li></ul><p>看不懂的递归：</p><pre><code>function ReverseList(head){    if (head === null || head.next === null) {        return head;    }    let p = ReverseList(head.next);    head.next.next = head;    head.next = null;    return p;}</code></pre><p>一段大佬的解释：</p><blockquote><p>关键就是理解 <code>p</code> 是反转后链表的表头，也就是原链表的最后一个节点。注意到从第一行的语句返回 <code>head</code> 之后，在以后的函数出栈过程中返回值 <code>p</code> 一直没有变，只是将当前函数的输入结点进行反转，就可以理解这个递归的过程了。</p></blockquote><p>一个运行过程模拟图：<br><img src="/images/post-images/1625057322087.png" alt=""><br>为什么 <code>head === null || head.next === null</code> 而不是只写一个判断 <code>head === null</code> 或者 <code>head.next === null</code>???</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;输入一个链表，反转链表后，输出新链表的表头。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="数据结构与算法" scheme="https://kouder.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Windows10 通过 Samba 连接树莓派的正确姿势</title>
    <link href="https://kouder.cn/2021/06/08/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>https://kouder.cn/2021/06/08/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</id>
    <published>2021-06-08T13:24:51.119Z</published>
    <updated>2021-12-31T07:20:19.284Z</updated>
    
    <content type="html"><![CDATA[<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>今天搜了一下午，要么说去 win10 的程序与功能那里打开什么服务的，要么说要打开什么组策略的，要开启什么什么服务的，全是 TM 扯淡。。。</p><p>在没有开启 SMB1.0 支持，没有修改组策略的情况下，</p><p>按照 <a href="https://pimylifeup.com/raspberry-pi-samba/" target="_blank" rel="noopener">这篇博客</a> 写的步骤很容易就成功了。。。</p><p>成功后的一些截图：</p><p>程序与功能没有打开 SMB：</p><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608215548461.png" alt="程序与功能没有打开 SMB"></p><p>操作系统版本也是比较新的版本：</p><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220315204.png" alt="image-20210608220315204"></p><p>而且文件管理器的网络选项内并没有出现树莓派：</p><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220326589.png" alt="image-20210608220326589"></p><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><p>关键是，要在 Win10 的这样设置！不要管什么网络，网络邻居啥的！</p><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220339787.png" alt="image-20210608220339787"></p><ol><li>点击后，弹出对话框：</li></ol><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220351431.png" alt="image-20210608220351431"></p><ol start="2"><li>上面的 <code>你自定义的</code> 就是你在 <code>/etc/samba/smb.conf</code> 文件里写的几行中的首行：</li></ol><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220410162.png" alt="image-20210608220410162"></p><ol start="3"><li>点击完成，需要你输入用户名密码，就是</li></ol><pre><code class="shell">sudo smbpasswd -a 用户名</code></pre><p>对应的用户名密码。</p><ol start="4"><li>然后，你会发现此电脑那里多了一个网络位置！</li></ol><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220501299.png" alt="image-20210608220501299"></p><ol start="5"><li>完成 samba 共享树莓派文件！</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;吐槽&quot;&gt;&lt;a href=&quot;#吐槽&quot; class=&quot;headerlink&quot; title=&quot;吐槽&quot;&gt;&lt;/a&gt;吐槽&lt;/h2&gt;&lt;p&gt;今天搜了一下午，要么说去 win10 的程序与功能那里打开什么服务的，要么说要打开什么组策略的，要开启什么什么服务的，全是 TM 扯淡。。。
      
    
    </summary>
    
    
      <category term="折腾树莓派" scheme="https://kouder.cn/categories/%E6%8A%98%E8%85%BE%E6%A0%91%E8%8E%93%E6%B4%BE/"/>
    
    
      <category term="Linux" scheme="https://kouder.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>更方便直观地查看文件大小的 Linux 命令</title>
    <link href="https://kouder.cn/2021/06/08/%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>https://kouder.cn/2021/06/08/%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</id>
    <published>2021-06-08T06:39:19.000Z</published>
    <updated>2021-12-31T07:20:19.285Z</updated>
    
    <content type="html"><![CDATA[<p>平时，用 <code>du</code>，<code>df</code>，<code>tree</code>，查看磁盘里文件大小，不能交互，用起来总感觉少了点什么。</p><p>今天发现了 <code>ncdu</code>，可以使用方向键交互，查看每个文件的大小。爽！</p><p><img src="/images/%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220236266.png" alt="image-20210608220236266"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;平时，用 &lt;code&gt;du&lt;/code&gt;，&lt;code&gt;df&lt;/code&gt;，&lt;code&gt;tree&lt;/code&gt;，查看磁盘里文件大小，不能交互，用起来总感觉少了点什么。&lt;/p&gt;
&lt;p&gt;今天发现了 &lt;code&gt;ncdu&lt;/code&gt;，可以使用方向键交互，查看每个文件的大小。爽！&lt;
      
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="https://kouder.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>安恒 2022 技术 C 笔试</title>
    <link href="https://kouder.cn/2021/06/03/%E5%AE%89%E6%81%922022%E6%8A%80%E6%9C%AFC%E7%AC%94%E8%AF%95/"/>
    <id>https://kouder.cn/2021/06/03/%E5%AE%89%E6%81%922022%E6%8A%80%E6%9C%AFC%E7%AC%94%E8%AF%95/</id>
    <published>2021-06-03T13:49:50.000Z</published>
    <updated>2021-12-31T07:20:19.284Z</updated>
    
    <content type="html"><![CDATA[<ol><li>简答题的最后一题（20 分）</li></ol><blockquote><p>简述黑客的攻击路径。</p></blockquote><p>我当时写的大概是：</p><ol><li>攻击系统应用软件，端口扫描发现软件漏洞</li><li>破解密码</li><li>钓鱼网站，邮件骗取用户的个人信息</li><li>恶意软件，诱导用户运行，获取用户系统权限</li></ol><p>刚才去网上找了找，发现写的还挺全：</p><p><a href="http://sxdofcom.shaanxi.gov.cn/newstyle/pub_newsshow.asp?id=29034582&chid=100520" target="_blank" rel="noopener">黑客攻击主要手段和方法</a></p><hr><ol start="2"><li>（多选题的其中一道）</li></ol><blockquote><p>OWASP Top 10 有哪些。</p></blockquote><p>当时瞎蒙的。。。</p><p>刚才去网上找了找</p><p><a href="https://owasp.org/www-project-top-ten/" target="_blank" rel="noopener">OWASP Top Ten Web Application Security Risks</a></p><p>依次为：</p><ol><li>注入</li><li>Broken Authentication / 破解验证？</li><li>敏感数据公开</li><li>XML 外部实体</li><li>破解访问控制</li><li>错误的安全配置</li><li>XSS / 跨站脚本</li><li>不安全的反序列化</li><li>利用了已有漏洞的组件</li><li>日志记录和监控的不够</li></ol><blockquote><p>OWASP 是什么</p><p>OWASP 是 Open Web Application Security Project 的缩写，这是一个在线社区，在 Web 应用安全领域发布文章、方法、文档、工具和技术。</p><p>Top 10 每三到四年更新一次，最新的 OWASP 漏洞列表在 2017 年发布。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;简答题的最后一题（20 分）&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;简述黑客的攻击路径。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我当时写的大概是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;攻击系统应用软件，端口扫描发现软件漏洞&lt;/li&gt;
&lt;li&gt;破解密码&lt;
      
    
    </summary>
    
    
      <category term="笔试记录" scheme="https://kouder.cn/categories/%E7%AC%94%E8%AF%95%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="安全" scheme="https://kouder.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Linux 终端下按需科学上网</title>
    <link href="https://kouder.cn/2021/05/31/Linux%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%8C%89%E9%9C%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
    <id>https://kouder.cn/2021/05/31/Linux%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%8C%89%E9%9C%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</id>
    <published>2021-05-31T03:27:23.000Z</published>
    <updated>2021-12-31T07:20:19.283Z</updated>
    
    <content type="html"><![CDATA[<h3 id="proxychains-方案"><a href="#proxychains-方案" class="headerlink" title="proxychains 方案"></a><code>proxychains</code> 方案</h3><p>前提当然是你已经配置好了 <code>v2ray</code> 的 <code>socks5</code> 代理。。。</p><p>需要连外网的命令比较少，此方案可以通过前缀加一个命令让所有软件都走代理。</p><p><a href="https://v2raytech.com/linux-cmd-set-proxy/" target="_blank" rel="noopener">此方案来自这里</a></p><blockquote><p>我用的这个 V2 的安装脚本：<code>https://github.com/v2fly/fhs-install-v2ray</code></p></blockquote><p>首先安装 <code>proxychains</code></p><p>然后编辑 <code>/etc/proxychains.conf</code> 文件，在最后的 <code>**[ProxyList]**</code> 一节中增加代理设置，例如：</p><pre><code>socks5 127.0.0.1 1080</code></pre><p>** 注意 **，这时要把 <code>socks4</code> 哪一行注释掉，不然，由于 <code>v2ray</code> 没有设置 <code>socks4</code>，会报错。</p><p>接下来，所有希望走代理的命令，前面增加 <code>proxychains</code> 即可，例如：</p><pre><code>proxychains wget https://www.google.com</code></pre><p>那些不直接支持 <code>socks5</code> 代理的软件应该都可以用了，因为</p><blockquote><p> 根据 [OSI 模型](<a href="https://zh.wikipedia.org/wiki/OSI" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/OSI</a> 模型)，SOCKS 是[会话层](<a href="https://zh.wikipedia.org/wiki" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki</a> / 会话层) 的协议，位于 [表示层](<a href="https://zh.wikipedia.org/wiki" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki</a> / 表示层) 与[传输层](<a href="https://zh.wikipedia.org/wiki" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki</a> / 传输层)之间。</p></blockquote><p>众所周知，HTTP 是应用层协议。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;proxychains-方案&quot;&gt;&lt;a href=&quot;#proxychains-方案&quot; class=&quot;headerlink&quot; title=&quot;proxychains 方案&quot;&gt;&lt;/a&gt;&lt;code&gt;proxychains&lt;/code&gt; 方案&lt;/h3&gt;&lt;p&gt;前提当然是你已经配
      
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="https://kouder.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>腾讯音乐娱乐测开笔试</title>
    <link href="https://kouder.cn/2021/04/15/%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%90%E5%A8%B1%E4%B9%90%E6%B5%8B%E5%BC%80%E7%AC%94%E8%AF%95/"/>
    <id>https://kouder.cn/2021/04/15/%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%90%E5%A8%B1%E4%B9%90%E6%B5%8B%E5%BC%80%E7%AC%94%E8%AF%95/</id>
    <published>2021-04-15T12:33:58.000Z</published>
    <updated>2021-12-31T07:20:19.284Z</updated>
    
    <content type="html"><![CDATA[<p>第一题做全了，第二题 45%，一直改，做到最后二十分钟竟然变为了 15%。。。第三题直接弃了。</p><h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><ul><li>输入一个整数 <code>n</code>，表示输入的整数数组数。输入这些数组。</li><li>输出每个数组内不重复的整数的最小值。意即最小数不得在数组内重复。</li></ul><pre><code>输入210 10 30 30 2099 98 98 输出2099</code></pre><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>“最小代价”</p><p>先输入一个正整数，表示后面的数组的长度。</p><p>再输入两个等长数组，两个数组内包含整数。</p><p>第二个数组对应的位置表示第一个数组内此位置的数 <code>+1</code> 需要的代价。</p><p>求使得第一个数组内各个数不同的最小代价。</p><pre><code>输入31 1 24 5 3输出7</code></pre><blockquote><p><code>1 1 2</code> 第一个元素加一，变为 <code>2 1</code>2，第三个元素再加一，变为 <code>2 1</code>3，此时代价为 <code>7</code>， 即最小代价</p></blockquote><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>好像和最短路径相关。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一题做全了，第二题 45%，一直改，做到最后二十分钟竟然变为了 15%。。。第三题直接弃了。&lt;/p&gt;
&lt;h1 id=&quot;第一题&quot;&gt;&lt;a href=&quot;#第一题&quot; class=&quot;headerlink&quot; title=&quot;第一题&quot;&gt;&lt;/a&gt;第一题&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;输入一个整
      
    
    </summary>
    
    
      <category term="笔试" scheme="https://kouder.cn/categories/%E7%AC%94%E8%AF%95/"/>
    
    
      <category term="算法" scheme="https://kouder.cn/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>靠谱的公司（技术胖）</title>
    <link href="https://kouder.cn/2020/03/15/%E6%89%BE%E5%88%B0%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8%EF%BC%88b%E7%AB%99%E6%8A%80%E6%9C%AF%E8%83%96%EF%BC%89/"/>
    <id>https://kouder.cn/2020/03/15/%E6%89%BE%E5%88%B0%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8%EF%BC%88b%E7%AB%99%E6%8A%80%E6%9C%AF%E8%83%96%EF%BC%89/</id>
    <published>2020-03-15T07:50:41.000Z</published>
    <updated>2021-12-31T07:20:19.284Z</updated>
    
    <content type="html"><![CDATA[<p>对于创业公司，面试前问清楚：</p><ul><li>面试前要对公司有一定的了解,  融资情况，CEO 背景，投资人背景，红色资本（国家注资）</li><li>盈利能力</li><li>政策风险，有无法律擦边球</li><li>技术发展</li></ul><p>面试通知后，面试中：</p><ul><li>问，自己进公司后去哪条产品线，哪个部门</li><li>技术可以带来更多价值的部门</li><li>技术是否与岗位对口</li><li>有没有人带，没有人带可能就是个大坑，因为上一届都干不下去了</li><li>问清除薪资，基本的，年终的，季度奖金，有无技术评级，<code>五险一金缴纳基数，高基数可以给自己减少房贷压力</code></li><li>下午茶陷阱，不要看得太重，不要用下午茶换薪资</li><li><code>期权</code>，上市的给的是股票，未上市的可能会给你期权，类似期房。<ul><li>注意：1 <code>期权发放比例</code>，例如你有 1 万股期权，公司总共发了 10 亿股，那你的那份就没多大价值</li><li>注意：2 <code>期权转现期限</code>，一般公司是 3，4 年之内，七八年之类的都在画大饼！！！</li><li>注意：3 <code>离职期权问题</code>，离职是否期权作废，或者强制以极低价格回收</li><li>注意：4 当前期权的 <code>公允价</code></li></ul></li></ul><p>面试通过，拿到 offer 后：</p><ul><li>及时给公司回复，避免公司面试其他人后选择别人。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;对于创业公司，面试前问清楚：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;面试前要对公司有一定的了解,  融资情况，CEO 背景，投资人背景，红色资本（国家注资）&lt;/li&gt;
&lt;li&gt;盈利能力&lt;/li&gt;
&lt;li&gt;政策风险，有无法律擦边球&lt;/li&gt;
&lt;li&gt;技术发展&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;
      
    
    </summary>
    
    
      <category term="经验" scheme="https://kouder.cn/categories/%E7%BB%8F%E9%AA%8C/"/>
    
    
      <category term="工作" scheme="https://kouder.cn/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
</feed>
