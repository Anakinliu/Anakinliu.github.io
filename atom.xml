<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Anakinliu&#39;s</title>
  
  <subtitle>学而不思则亡，思而不学则殆。</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://kouder.cn/"/>
  <updated>2022-04-04T09:24:24.503Z</updated>
  <id>https://kouder.cn/</id>
  
  <author>
    <name>AnakinLiu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>如何读 ECMAScript 规范（二）</title>
    <link href="https://kouder.cn/2022/04/04/%E5%A6%82%E4%BD%95%E8%AF%BBECMAScript%E8%A7%84%E8%8C%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>https://kouder.cn/2022/04/04/%E5%A6%82%E4%BD%95%E8%AF%BBECMAScript%E8%A7%84%E8%8C%83%EF%BC%88%E4%BA%8C%EF%BC%89/</id>
    <published>2022-04-04T09:23:47.000Z</published>
    <updated>2022-04-04T09:24:24.503Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文翻译自：</p><p><a href="https://timothygu.me/es-howto/" target="_blank" rel="noopener">https://timothygu.me/es-howto/</a></p><h2 id="运行时语义"><a href="#运行时语义" class="headerlink" title="运行时语义"></a>运行时语义</h2><p>语言和 api 的运行时语义是规范中最重要的部分，通常是人们最关心的问题。</p><p>总的来说，在规范中阅读这些章节是非常简单的。然而，该规范使用了大量的速记，这些速记刚刚开始 (至少对我来说) 是相当讨厌的。我将尝试解释其中的一些约定，然后将它们应用到一个通常的工作流程中，以弄清楚几件事情是如何工作的。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>ECMAScript 中的大多数运行时语义是由一系列算法步骤指定的，与伪代码没有什么不同，但形式精确得多。</p><p><img src="/images/WZwocpQ6T6KKkv5QjHIq_dHiST4igA9mdTQc5sMtasM.png" alt="image"></p><h3 id="抽象的操作"><a href="#抽象的操作" class="headerlink" title="抽象的操作"></a>抽象的操作</h3><p>您有时会在规范中看到调用类似函数的内容。</p><p>Boolean()函数：</p><p><img src="/images/mDVctygjTBWTqcJHD9AcpaD-WzfbHMdzei9ZCxLLBrU.png" alt="image"></p><p>“<a href="https://tc39.es/ecma262/#sec-toboolean" target="_blank" rel="noopener">ToBoolean</a>”函数被称为抽象的操作。抽象的原因是它实际上并没有作为 JavaScript 代码的函数公开。它只是一个规范作者发明的符号。</p><p><a href="https://tc39.es/ecma262/#sec-algorithm-conventions-abstract-operations" target="_blank" rel="noopener">抽象操作</a></p><h3 id="什么是-This"><a href="#什么是-This" class="headerlink" title="什么是 [[This]]"></a>什么是 [[This]]</h3><p>有时，您可能会看到 [[符号 ]]被使用，例如 “Let proto be obj.[[Prototype]]“。</p><p>从技术上讲，这种表示法可以表示几种不同的东西，这取决于它出现的上下文。要理解这种表示法指的是一些无法通过 JavaScript 代码观察到的内部属性。</p><p>确切地说，它可能意味着三种不同的东西，我将用规范中的示例来说明。但是，现在请随意跳过它们。</p><h4 id="记录-amp-字段"><a href="#记录-amp-字段" class="headerlink" title="记录 &amp; 字段"></a>记录 &amp; 字段</h4><p>ECMAScript 规范使用术语 <strong>Record</strong> 来指代具有一组固定键的键值映射 – 有点像类 C 语言中的 ** 结构体 **。</p><p>记录（Record）的每个键值对（key-value）称为一个 ** 字段 **（field）。由于记录只能出现在规范中，而不能出现在实际的 JavaScript 代码中，因此使用 <code>[[Notation]]</code> 来引用记录 (Record) 的字段(field)。</p><blockquote><p>值得注意的是，属性描述符还建模为具有 field: [[Value]]、[[Wwriteable]]、[[Get]]、[[Set]]、[[Enumerable]]和 [[Configurable]]的 Record。IsDataDescriptor 抽象操作广泛使用以下表示法：</p></blockquote><blockquote><p>当使用属性描述符 Desc 调用抽象操作 IsDataDescriptor 时，将执行以下步骤：</p></blockquote><blockquote><ol><li>如果 Desc 是 undefined，返回 false</li><li>如果 <code>Desc.[[Value]]</code> 和 <code>Desc.[[Writeable]]</code> 缺失，返回 false</li><li>返回 true</li></ol></blockquote><h4 id="JavaScript-对象的内部插槽"><a href="#JavaScript-对象的内部插槽" class="headerlink" title="JavaScript 对象的内部插槽"></a>JavaScript 对象的内部插槽</h4><p>JavaScript 对象可能具有所谓的内部插槽，规范使用这些插槽来保存其中的数据。</p><p>与记录字段一样，这些内部插槽也无法使用 JavaScript 进行观察，但其中一些可以通过特定于实现的工具（如 Google Chrome 的 DevTools）公开。因此，使用 <code>[[记号]]</code> 来描述内部插槽也是有意义的。</p><p>内部插槽的细节将在 § 2.5 JavaScript Objects 中介绍。现在，不要太担心它们的用途，但请注意以下示例。</p><blockquote><p>大多数 JavaScript 对象有一个内部插槽 [[Prototype]]，引用了它们所继承的对象。这个内部插槽的值通常是 <code>Object.getProrotypeOf()</code> 方法的返回值。在 OrdinaryGetPrototypeOf 抽象操作中，访问此内部插槽的值：</p></blockquote><blockquote><p>当使用对象 O 调用抽象操作 OrdinaryGetPrototypeOf 时，将执行以下步骤：</p></blockquote><blockquote><ol><li>返回 <code>O.[[Prototype]]</code></li></ol></blockquote><blockquote><p>注： “对象” 和 “记录” 字段的内部槽在外观上是相同的，但可以通过查看记号（点运算符之前的部分）来消除歧义，无论是对象还是记录。可以在上下文中看出。</p></blockquote><h4 id="JavaScript-对象的内部方法"><a href="#JavaScript-对象的内部方法" class="headerlink" title="JavaScript 对象的内部方法"></a>JavaScript 对象的内部方法</h4><p>JavaScript 对象也可能具有所谓的内部方法。与内部插槽一样，这些内部方法无法通过 JavaScript 直接观察到。</p><p>因此，使用 <code>[[记号]]</code> 来描述内部方法也是有意义的。</p><p>内部方法的细节将在 § 2.5 JavaScript Objects 中介绍。现在，不要太担心它们的用途，但请注意以下示例。</p><blockquote><p>所有的 JavaScript 函数都有一个内部方法 [[Call]]，它运行函数。<a href="https://tc39.es/ecma262/#sec-call" target="_blank" rel="noopener">Call 抽象操作</a></p></blockquote><h3 id="完成记录；-和！"><a href="#完成记录；-和！" class="headerlink" title="完成记录；? 和！"></a>完成记录；? 和！</h3><p>ECMAScript 规范中的每个运行时语义都显式或隐式返回一个报告其结果的完成记录（Completion Records）。此完成记录是具有三个可能字段的记录（Record）：</p><ul><li>一个 <code>[[Type]]</code> (normal, return,throw,break,contintue)</li><li>如果 <code>[[Type]]</code> 是 normal，return 或者 throw，它可以额外有一个 <code>[[Value]]</code> (返回 / 抛出了什么)</li><li>如果 <code>[[Type]]</code> 是 break 或者 continue，则它可以选择携带一个称为 <code>[[Target]]</code> 的标签，脚本执行会因为此运行时语义而中断 / 继续执行该标签。<blockquote><p>注意：<code>[[]]</code> 也用来表示记录 (Records) 的字段(fields)。</p></blockquote></li></ul><p><code>[[Type]]</code> 为 normal 时的完成记录称为 *<em>normal 完成 *</em>。其他 <code>[[Type]]</code> 的完成记录称为 *<em>abrupt 完成 *</em>。</p><p>大多数时候，你只会与 <code>[[Type]]</code> 为 throw 的 <strong>abrupt 完成 ** 打交道。其他三种（return，break，continue）</strong>abrupt 完成 ** 类型仅用于查看如何评估特定语法元素。</p><p>事实上，您将永远不会在内置函数的定义中看到 normal 和任何其他类型，因为中断 / 继续 / 返回不能跨函数边界工作。</p><blockquote><p><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type" target="_blank" rel="noopener">规范连接</a></p></blockquote><p>由于完成记录的定义，JavaScript 中的细微差别，如冒泡错误，直到尝试捕获块在规范中不存在。</p><p>事实上，错误（或更确切地说是 abrupt 完成）是显式处理的。</p><p>在没有任何速记的情况下，对抽象操作的普通调用的规范文本可能返回计算结果或引发错误，如下所示：</p><blockquote><p>调用抽象操作的几个步骤，该操作可能在没有任何速记的情况下抛出：</p></blockquote><blockquote><ol><li>设 resultCompletionRecord 是一个 AbstractOp()。<ol><li>注意，resultCompletionRecord 是一个完成记录</li></ol></li><li>如果 resultCompletionRecord 是一个 abrupt 记录，返回 resultCompletionRecord<ol><li>注意，这里，resultCompletionRecord 如果是 abrupt 完成，直接返回。换句话说，将在 AbstractOp 中引发错误，并中止其余步骤。</li></ol></li><li>设 result 是 <code>resultCompletionRecord.[[Value]]</code> <ol><li>注意，在确保我们获得正常完成之后，我们现在可以解开完成记录的包装，以获得我们需要的计算的实际结果。</li></ol></li><li>result 就是我们需要的结果。</li></ol></blockquote><p>这可能会让你想起 C 中的手动错误处理：</p><pre><code class="javascript">int result = abstractOp();              // Step 1if (result &lt; 0)                         // Step 2  return result;                        // Step 2 (continued)                                        // Step 3 is unneeded// func() succeeded; carrying on...     // Step 4</code></pre><p>但是为了减少这些步骤，ECMAScript 规范的编辑器添加了一些速记（shorthands）。</p><p>自 ES2016 起，相同的规范文本可以改为以以下两种等效方式编写：</p><blockquote><p>调用抽象操作的几个步骤可能抛出 <code>ReturnIfAbrupt</code> </p></blockquote><blockquote><ol><li>设 result 是 AbstractOp()。<ol><li>注意，这里，就像上面的 step1，result 是一个完成记录</li></ol></li><li><a href="https://tc39.es/ecma262/#sec-returnifabrupt" target="_blank" rel="noopener">ReturnIfAbrupt</a>(result)<ol><li>注意，ReturnIfAbrupt 通过转发来处理任何可能的 abrupt 完成，并自动将结果解包到其 <code>[[Value]]</code> 中。</li></ol></li><li>result 就是我们想要的结果。</li></ol></blockquote><p>或者，更简洁地说，用一个特殊的问号（？）表示法：</p><blockquote><p>调用抽象操作的几个步骤可能抛出 <code>问号标记(?)</code> </p></blockquote><blockquote><ol><li>设 result 是？AbstractOp()<ol><li>注意：在此表示法中，我们根本不处理完成记录。这个？速记为我们处理一切，结果可以立即使用。</li></ol></li><li>result 就是我们想要的结果。</li></ol></blockquote><p>有时，如果我们知道对 AbstractOp 的特定调用永远不会返回 abrupt 完成，它可以向读者传达有关规范意图的更多信息。在这些情况下，使用感叹号 （！）</p><blockquote><p>调用抽象操作的几个步骤永远不抛出的 <code>感叹号标记(!)</code> </p></blockquote><blockquote><ol><li>设 result 是! AbstractOp()<ol><li>注意，？可能会带来任何错误，而！断言我们这次调用永远不会得到任何 abrupt 完成，如果我们这样做，那将是规范中的一个错误。就像？的情况，我们完全不处理完成记录。result 在这之后是立即可用的。</li></ol></li><li>result 就是我们想要的结果。</li></ol></blockquote><p>注意，<code>!</code> 看起来像一个有效的 JavaScript 表达式，可能会变得非常混乱：<code>!ToBoolean(value)</code></p><p>在这里，！只是意味着我们确信对 ToBoolean 的调用永远不会返回异常，而不是布尔取反。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;本文翻译自：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://timothygu.me/es-howto/&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="转载记录" scheme="https://kouder.cn/categories/%E8%BD%AC%E8%BD%BD%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>动手给键盘加灯</title>
    <link href="https://kouder.cn/2022/04/04/%E5%8A%A8%E6%89%8B%E7%BB%99%E9%94%AE%E7%9B%98%E5%8A%A0%E7%81%AF/"/>
    <id>https://kouder.cn/2022/04/04/%E5%8A%A8%E6%89%8B%E7%BB%99%E9%94%AE%E7%9B%98%E5%8A%A0%E7%81%AF/</id>
    <published>2022-04-04T01:14:48.000Z</published>
    <updated>2022-04-04T01:18:22.856Z</updated>
    
    <content type="html"><![CDATA[<h2 id="所需材料："><a href="#所需材料：" class="headerlink" title="所需材料："></a>所需材料：</h2><ul><li>2x3x4 的脚长 18mm 的方灯珠，淘宝 8 块钱 110 个。</li><li>剪灯珠脚的钳子，五块钱左右。</li><li>键盘 &amp; 透光键帽</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要确定键盘的灯的插孔的正负极，这个键盘上面标了 +-。</p><p><img src="/images/kwiY0ssdRsPsDFGwmZnBWbjHQ8YayDlxeJHR1-YkkVg.jpg" alt=""></p><p>然后，灯珠的长腿是 +</p><p><img src="/images/OyFGgllzYPSGltgmxXGeef9YZuyOdMiZDS8FaQiF3Aw.png" alt=""></p><p>用钳子剪去多余的长度，插入键盘的灯孔里即可。</p><p><img src="/images/2oJVBePrCkB7rH1AsU4AB8-5izNogEPumZzjTj8_iXI.jpg" alt=""></p><p>需要用手折一下针脚，好让其正好撑住灯孔，避免键盘稍有震动造成接触不良。</p><p>最后，三个小时的成果：</p><p><img src="/images/0HWNfqaNy57eSmwI22YMqYa-A1m31zzXtKYbSi7DVqw.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;所需材料：&quot;&gt;&lt;a href=&quot;#所需材料：&quot; class=&quot;headerlink&quot; title=&quot;所需材料：&quot;&gt;&lt;/a&gt;所需材料：&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;2x3x4 的脚长 18mm 的方灯珠，淘宝 8 块钱 110 个。&lt;/li&gt;
&lt;li&gt;剪灯珠脚的钳子，
      
    
    </summary>
    
    
      <category term="软硬兼施" scheme="https://kouder.cn/categories/%E8%BD%AF%E7%A1%AC%E5%85%BC%E6%96%BD/"/>
    
    
  </entry>
  
  <entry>
    <title>如何读 ECMAScript 规范（一）</title>
    <link href="https://kouder.cn/2022/04/01/%E5%A6%82%E4%BD%95%E8%AF%BBECMAScript%E8%A7%84%E8%8C%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>https://kouder.cn/2022/04/01/%E5%A6%82%E4%BD%95%E8%AF%BBECMAScript%E8%A7%84%E8%8C%83%EF%BC%88%E4%B8%80%EF%BC%89/</id>
    <published>2022-04-01T11:03:00.000Z</published>
    <updated>2022-04-01T11:04:07.362Z</updated>
    
    <content type="html"><![CDATA[<h1 id="如何读-ECMAScript-规范（一）"><a href="#如何读-ECMAScript-规范（一）" class="headerlink" title="如何读 ECMAScript 规范（一）"></a>如何读 ECMAScript 规范（一）</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文翻译自：</p><p><a href="https://timothygu.me/es-howto/" target="_blank" rel="noopener">https://timothygu.me/es-howto/</a></p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在本文档中，我将仅使用术语 “ECMAScript” 来指代规范本身，而使用 “JavaScript” 来指代其他任何地方。但是，这两个术语都指同一事物。（ECMAScript 和 JavaScript 之间有一些历史上的区别，但讨论这超出了本文档的范围，你可以很容易地用谷歌搜索这种区别。</p><h3 id="我为什么读这个规范"><a href="#我为什么读这个规范" class="headerlink" title="我为什么读这个规范"></a>我为什么读这个规范</h3><p>ECMAScript 规范是所有 JavaScript 实现行为的权威来源，无论是在浏览器中，还是在服务器 Node.js，还是在 IoT 设备上。</p><p>JavaScript 引擎的所有开发人员都依赖于规范来确保其闪亮的新功能按预期工作，就像其他 JavaScript 引擎一样。</p><p>假设有一天在工作中发现了以下奇特的代码：</p><pre><code class="javascript">&gt; Array.prototype.push(42)1&gt; Array.prototype[ 42 ]&gt; Array.isArray(Array.prototype)true&gt; Set.prototype.add(42)TypeError: Method Set.prototype.add called on incompatible receiver #&lt;Set&gt;    at Set.add (&lt;anonymous&gt;)&gt; Set.prototypeSet {}</code></pre><p>为什么 Array 的原型上的 push 方法是可以直接调用的。而 Set 不行？</p><blockquote><p>不幸的是，Google 总是在你最需要的时候失败，一直有用的 Stack Overflow 也是如此。</p></blockquote><p>读规范可以解决。</p><p>或者，您可能想知道臭名昭着的松散相等运算符 <code>==</code> 实际上是如何运作的。勤奋的你在 MDN 上查找它，却发现它的解释段落给你带来的伤害比帮助更大。</p><p>另一方面，我不建议刚接触 JavaScript 的开发人员阅读 ECMAScript 规范。如果你是 JavaScript 的新手，那么就试试 Web 吧！</p><p>当你经历过足够多的 JavaScript 问题，不必担心 JavaScript 时，请考虑返回到本文档。</p><h3 id="哪些属于-or-不属于-ECMAScript-规范"><a href="#哪些属于-or-不属于-ECMAScript-规范" class="headerlink" title="哪些属于 or 不属于 ECMAScript 规范"></a>哪些属于 or 不属于 ECMAScript 规范</h3><table><thead><tr><th>描述</th><th>分类</th></tr></thead><tbody><tr><td>句法元素的语法（即，有效的 for 循环应该是什么样）</td><td>属于规范✔</td></tr><tr><td>句法元素的语义（例如，<code>typeof null</code> 应该返回什么，<code>{ a:b }</code> 应该返回什么</td><td>属于规范✔</td></tr><tr><td>Object, Array, Function, Number, Math, RegExp, Proxy, Map, Promise, ArrayBuffer, Uint8Array, <code>globalThis</code>, …</td><td>属于规范✔</td></tr><tr><td><code>import a from &#39;a&#39;;</code></td><td>规范指定了此类声明的语法以及它们的含义，<br > 但没有指定具体如何加载模块。</td></tr><tr><td>console, setTimeout(), setInterval(), clearTimeout(), clearInterval()</td><td>这些方法在浏览器端和 Node 里都可用，但是属于非标准。<br > 对于 Node，他们属于 Node 规范。对于浏览器，console 被 CONSOLE 标准规范，其余被 HTML 标准规范。</td></tr><tr><td>Buffer, process, global*</td><td>属于 Node 规范。</td></tr><tr><td>module, exports, require(), __dirname, __filename</td><td>这些是 Node.js 模块范围的 “全局变量”，由其文档记录</td></tr><tr><td>window, alert(), confirm(), DOM (document, HTMLElement, addEventListener(), Worker, …)</td><td>只在浏览器存在</td></tr></tbody></table><h3 id="ECMAScript-规范在哪"><a href="#ECMAScript-规范在哪" class="headerlink" title="ECMAScript 规范在哪"></a>ECMAScript 规范在哪</h3><p>[ECMA-262](<a href="https://tc39.es/ecma262/" target="_blank" rel="noopener">https://tc39.es/ecma262/</a>)</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>ECMA 包含巨量信息。尽管作者尽力分隔成单独的部分，但是仍然是巨量。</p><p>个人把规范分为五部分：</p><ul><li>约定和基础知识（什么是 Number？“throw a TypeError exception”是什么意思？）</li><li>语法（如何编写 for-in 循环？）</li><li>语言的静态语义（变量名称是如何在 var 语句中确定的？）</li><li>语言的运行时语义（for-in 循环是如何执行的？）</li><li>API（<code>String.prototype.substring()</code> 做了什么？）</li></ul><p>然而 ECMA 规范没有安装上面的划分。</p><p>第 1 部分在 <a href="https://tc39.es/ecma262/#sec-notational-conventions" target="_blank" rel="noopener">CH5 Notational Convention</a> 到<a href="https://tc39.es/ecma262/#sec-ordinary-and-exotic-objects-behaviours" target="_blank" rel="noopener">CH9 Ordinary and Exotic Objects Behaviours</a></p><p>第 2,3,4 部分以交错的形式在<a href="https://tc39.es/ecma262/#sec-ecmascript-language-source-code" target="_blank" rel="noopener">CH10 ECMAScript Language: Source Code</a> 到 <a href="https://tc39.es/ecma262/#sec-ecmascript-language-scripts-and-modules" target="_blank" rel="noopener">CH15  ECMAScript Language: Scripts and Modules</a></p><p>我想指出的是，绝对没有人从上到下阅读规范。</p><p>相反，只查看与您尝试查找的内容相对应的部分，并且在该部分中仅查看您需要的内容。尝试确定您的具体问题与五大部分中的哪一个相关; 如果你在确定它是哪一个时遇到困难，问问自己一个问题：”这个（无论你试图确认什么）在什么时候被评估？” 这可能会有所帮助。别担心，通过练习，导航规范只会变得更容易。</p><h2 id="运行时语义"><a href="#运行时语义" class="headerlink" title="运行时语义"></a>运行时语义</h2><p>下部分。。。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;如何读-ECMAScript-规范（一）&quot;&gt;&lt;a href=&quot;#如何读-ECMAScript-规范（一）&quot; class=&quot;headerlink&quot; title=&quot;如何读 ECMAScript 规范（一）&quot;&gt;&lt;/a&gt;如何读 ECMAScript 规范（一）&lt;/h1&gt;&lt;
      
    
    </summary>
    
    
      <category term="转载记录" scheme="https://kouder.cn/categories/%E8%BD%AC%E8%BD%BD%E8%AE%B0%E5%BD%95/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>深入理解 ES6-ch4 扩展对象的功能性</title>
    <link href="https://kouder.cn/2022/03/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-ch4%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/"/>
    <id>https://kouder.cn/2022/03/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-ch4%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/</id>
    <published>2022-03-31T14:04:20.000Z</published>
    <updated>2022-04-01T02:52:25.143Z</updated>
    
    <content type="html"><![CDATA[<h2 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h2><p>现在，属性可以在字面量中直接写</p><pre><code class="javascript">let p = &quot;a b c&quot;;let a = {[p]: &#39;123&#39;;}</code></pre><p>ES5 不能直接写，只能这么写：</p><pre><code class="javascript">var p = &quot;a b c&quot;;var a = { };a[p] = &#39;1 2 3&#39;;</code></pre><h2 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h2><h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>严格相等运算 <code>===</code> 不会触发强制类型转换，但是也有不准确的时候。</p><pre><code class="javascript">+0 === -0 // trueNaN === NaN // false</code></pre><p>在 JS 中，<code>-0</code> 和 <code>+0</code> 是不同的实体。应该是 false。NaN 与自身比较应该是 true。</p><p>ES6 引入了 <code>Object.is()</code> 弥补全局运算符的不准确。</p><p><code>===</code> 与 <code>Object.is()</code> 的唯一区别就是 <code>+0,-0 ,NaN</code> 这两种情况。</p><pre><code class="javascript">Object.is(+0, -0) //falseObject.is(NaN, NaN) // true</code></pre><p>当你的严格相等代码中，有可能出现以上两种情况，考虑使用 Object.is</p><h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h5><p>混合（mixin）是 JS 中对象组合的常见模式。</p><p>例如</p><pre><code class="javascript">function mixin(receiver, supplier){    Object.keys(supplier).forEach(function(key)) {        receiver[key] = supplier[key];    });    return receiver;}</code></pre><p>mixin 函数遍历 supplier 的自有属性并复制到 receiver 中（浅复制）。使得 receiver 可以不通过继承，获得属性。</p><pre><code class="javascript">function EventTarget() {}EventTarget.prototype = {    constructor: EventTarget,    emit: function(){},    on: function(){}};var myObj = {};mixin(myObj, EventTarget.prototype);myObj.emit(&quot;somethingChanged&quot;);</code></pre><p>这里，myObj 接收了 EventTarget.prototype 对象的所有行为，从而可以使用 emit 发布事件，可以通过 on 订阅事件。</p><p>ES6 的 <code>Object.assign</code> 方法实现了上面的 mixin 的功能</p><pre><code class="javascript">Object.assign(接收对象，源对象 1，源对象 2，源对象 3。。。)</code></pre><p>注意，assign 不能复制访问器属性（getter 和 setter），并且访问器属性的 <code>enumerable</code> 是 true 时才能被 assign 方法发现，如下所示：</p><pre><code class="javascript">// assign 不能复制访问器属性let supplier = {    age: 18,}Object.defineProperty(supplier, &#39;year&#39;, {    get() {        console.log(&#39;调用了 get&#39;);        return this.age;    },    set(value) {        console.log(&#39;set 被调用了&#39;);        this.age = value;    },    enumerable: true,})supplier.year = 2022;// 都改成了 2022console.log(supplier.age);console.log(supplier.year);let myObj = {};Object.assign(myObj, supplier);console.log(myObj.age);console.log(myObj.year);myObj.year = 2021;// age 没有变，说明 assign 没有复制访问器属性（getter 和 setter）console.log(myObj.age);console.log(myObj.year);</code></pre><p>supplier 的访问器属性会变为接收器对象的一个数据属性。不再是访问器属性。</p><p>assign 可以接 N 个源对象，排名靠后的对象会覆盖前面的同名属性。</p><h5 id="字面量对象的重复属性"><a href="#字面量对象的重复属性" class="headerlink" title="字面量对象的重复属性"></a>字面量对象的重复属性</h5><p>ES6 字面量中重复定义的属性，不会报错，不管是严格和非严格模式。</p><p>值取最后定义的。</p><h5 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h5><p>ES6 严格规定明确了自有属性被枚举时的返回顺序。</p><p>被影响的方法：Obejct.assign, Object.getOwnPropertyNames,Reflect.ownKeys 等等。</p><p>ES6 没有明确  <code>for-in</code> 循环的属性枚举顺序。Object.keys 和 JSON.stringify 与 for-in 顺序相同，因此 ES6 也没有明确。(Chrome V100 的顺序与 ES 的枚举顺序一致)</p><p>顺序规则：</p><ol><li>数字 key 按升序排序</li><li>字符串 key 按照 ** 被加入对象的顺序 ** 排序</li><li>所有 symbol 按照 ** 被加入对象的顺序 ** 排序</li></ol><pre><code class="javascript">let obj = {    0: 1,    3: 1,    bz: 1,    b: 1,    bb: 1,    az: 1,    ab: 1,    1: 1,    &quot;-2&quot;: 1,    &quot;-1&quot;: 1}obj[2] = 1;obj[-0] = 1;obj[-1] = 1;console.log(Object.getOwnPropertyNames(obj).join(&#39;-&#39;));// Chrome 100 结果：0-1-2-3-bz-b-bb-az-ab--2--1-a</code></pre><ul><li>对于数字，在枚举时被重新排序。</li><li>字符串键在数字键后面。顺序是声明顺序和插入对象的顺序。</li><li>负数只按照前面的 “-” 排序，视为字符串。</li></ul><h5 id="增强的对象原型"><a href="#增强的对象原型" class="headerlink" title="增强的对象原型"></a>增强的对象原型</h5><p>一般情况，无论是构造函数，还是 Object.create 方法创建的对象，原型都是在对象被创建时指定的。</p><p>ES5 的原则是，在实例化之后，对象原型保持不变。但是 ES5 缺少实例化后改变原型的标准方法。ES5 的 <code>Object.getPrototypeOf()</code> 用来返回指定对象的原型。</p><p>在 ES6，又新增了 <code>Obejct.setPrototypeOf()</code> 方法，用来改变指定对象的原型。</p><p>代码如下：</p><pre><code class="javascript">let person = {    getGreeting() {        return &#39;hello&#39;;    }}let dog = {    getGreeting() {        return &#39;baibai&#39;;    }}let friend = Object.create(person);console.log(friend.getGreeting());  // helloconsole.log(Object.getPrototypeOf(friend) === person);  //trueObject.setPrototypeOf(friend, dog);console.log(friend.getGreeting());  // baibaiconsole.log(Object.getPrototypeOf(friend) === dog);  //true</code></pre><h5 id="用来简化原型访问的-Super"><a href="#用来简化原型访问的-Super" class="headerlink" title="用来简化原型访问的 Super"></a>用来简化原型访问的 Super</h5><p>在 ES5，你想重写对象实例的方法，又需要调用与它同名的原型方法，代码如下：</p><pre><code class="javascript">// 在 ES5，你想重写对象实例的方法，又需要调用与它同名的原型方法，代码如下：let person = {    id: &#39;#human&#39;,    getGreeting() {        return this.id + &#39;hello&#39;;    }}let dog = {    id: &#39;animal&#39;,    getGreeting() {        return this.id + &#39;baibai&#39;;    }}let friend = {    id: &#39;#friend&#39;,    getGreeting() {        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;    }}Object.setPrototypeOf(friend, person);console.log(friend.getGreeting());  // #friend hello, hi!</code></pre><p><code>Object.getPrototypeOf(this)</code> 确保得到的是 this（friend）的原型 –person。后面的 call 可以确保 this 的指向的是 friend。如果不加 call，最后打印 <code>#human hello, hi!</code></p><p>ES6 的 super 引用相当于指向对象原型的指针，相当于 <code>Object.getPrototypeOf(this)，</code> 代码如下：</p><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting() {        return super.getGreeting() + &quot;, hi!&quot;;    }}Object.setPrototypeOf(friend, person);console.log(friend.getGreeting());  // #friend hello, hi!</code></pre><blockquote><p>super 不能在非简写方法中使用，会报错 <code>SyntaxError: &#39;super&#39; keyword unexpected here</code>：</p></blockquote><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting: function () {        return super.getGreeting() + &quot;, hi!&quot;;    }}</code></pre><p>多重继承时，用 ES5 的 Object.getPrototypeOf(this)会出现循环引用的问题，代码如下：</p><pre><code class="javascript">// super 对于多重继承很有用let friend = {    id: &#39;#friend&#39;,    getGreeting() {        // ES5 的方式在多重继承时会有问题，造成循环调用        console.log(this.id);        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;   }}Object.setPrototypeOf(friend, person);// relative 原型是 friendlet relative = Object.create(friend);console.log(relative.getGreeting());</code></pre><p>RangeError: Maximum call stack size exceeded。</p><p>因为 <code>relative.getGreeting()</code> 是调用的 <code>friend</code> 的 <code>getGreeting</code> 方法，<code>Object.getPrototypeOf(this)</code> 中的 <code>this</code> 指向的是 <code>relative</code>，调用 <code>Object.getPrototypeOf(this)</code> 的结果返回的就是 <code>friend</code> 对象，此时造成 <code>friend.getGreeting</code> 的循环调用。</p><p>使用 super，以上问题迎刃而解，代码如下：</p><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting() {        // ES5 的方式在多重继承时会有问题，造成循环调用        console.log(this.id);        return super.getGreeting() + &quot;, hi!&quot;;    }}</code></pre>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;可计算属性名&quot;&gt;&lt;a href=&quot;#可计算属性名&quot; class=&quot;headerlink&quot; title=&quot;可计算属性名&quot;&gt;&lt;/a&gt;可计算属性名&lt;/h2&gt;&lt;p&gt;现在，属性可以在字面量中直接写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;let 
      
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://kouder.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>ES6 的 Unicode</title>
    <link href="https://kouder.cn/2021/12/23/es6-de-unicode/"/>
    <id>https://kouder.cn/2021/12/23/es6-de-unicode/</id>
    <published>2021-12-23T01:47:23.000Z</published>
    <updated>2022-04-01T02:53:23.803Z</updated>
    
    <content type="html"><![CDATA[<p>在 ES6 之前，JS 字符串是基于 16 位的字符编码进行构建。每 16 位的序列是一个编码单元，代表一个字符。但是现在这 16 位满足不了字符数量的需求了。</p><a id="more"></a><h1 id="UTF-16-码位"><a href="#UTF-16-码位" class="headerlink" title="UTF-16 码位"></a>UTF-16 码位</h1><ul><li>Unicode 目的是给每一个字符提供唯一的数字标识，也称为码位（code point），从 0 开始。</li><li>用来表示字符的数字标识（码位），称为字符编码（character encode）。</li></ul><p>现在字符有两种表示，完全依照 UTF-16 的表示方式：</p><ul><li>16 位的字符，基本多文种平面（BMP），即只有一个编码单元</li><li>32 位的字符，也叫代理对，包含两个编码单元</li></ul><p>ES<code>5</code> 所有的字符串操作基于 16 位的字符（即使此字符使用 32 位表示的）。<br>ES5 代码，IE11 控制台的运行结果：</p><pre><code class="javascript">var e = &#39;😅&#39;;=&gt; undefinede.length=&gt; 2/^.$/.test(e)=&gt; falsee.charAt(0)=&gt; &quot;���&quot;e.charAt(1)=&gt; &quot;���&quot;e.char=&gt; undefinede.charCodeAt(0)=&gt; 55357e.charCodeAt(1)=&gt; 56837</code></pre><p>长度属性是 2，而且第一个和第二个编码单元不是一个 BMP，显示乱码。</p><h1 id="codePointAt-方法"><a href="#codePointAt-方法" class="headerlink" title="codePointAt 方法"></a>codePointAt 方法</h1><p>ES6 新增方法。完全支持 UTF-16。</p><pre><code>var e = &#39;😅a&#39;;=&gt; undefinede.length=&gt; 2e.codePointAt(0)=&gt; 128517e.codePointAt(1)=&gt; 56837e.codePointAt(2)=&gt; 97e.charCodeAt(0)=&gt; 55357e.charCodeAt(1)=&gt; 56837e.charCodeAt(2)=&gt; 97</code></pre><p>到了 ES6，长度属性依然是 2。<br>但是，<code>e.codePointAt(0)</code> 返回的是一个完整的 UTF-16 编码，而非半个 16 位编码，是大于 <code>0xFFFF</code> 的。因此，可以借此判断字符占用的编码单元数量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在 ES6 之前，JS 字符串是基于 16 位的字符编码进行构建。每 16 位的序列是一个编码单元，代表一个字符。但是现在这 16 位满足不了字符数量的需求了。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>循环中的作用域</title>
    <link href="https://kouder.cn/2021/12/21/xun-huan-zhong-de-zuo-yong-yu/"/>
    <id>https://kouder.cn/2021/12/21/xun-huan-zhong-de-zuo-yong-yu/</id>
    <published>2021-12-21T03:38:23.000Z</published>
    <updated>2022-04-01T02:56:24.755Z</updated>
    
    <content type="html"><![CDATA[<p>😕</p><a id="more"></a><h1 id="循环中的函数"><a href="#循环中的函数" class="headerlink" title="循环中的函数"></a>循环中的函数</h1><p>之前，只是知道 let 的块作用域和 var 的函数作用域，今天看了看书，发现自己的理解其实有偏差。<br>记住下面这句话：</p><blockquote><p>let 声明在循环内部的行为是 ES 标准中专门定义的，与 let 的变量提升没有直接关联。</p></blockquote><p>看代码：</p><pre><code class="javascript">var funcs = [];for (var i = 0; i &lt;= 10; i++) {    funcs.push(function () {        console.log(i);    })}funcs.forEach(function (ele) {    ele();})</code></pre><p>结果为，输出打印 10 个 11。<br>因为调用函数时，打印的 <code>i</code> 指向的都是一个 <code>i</code>。<br>不想使用那个变量 <code>i</code>？<br>可以使用 IIFE - 立即执行函数, 强制生成 <code>变量 i</code> 的一个副本。<br>看代码：</p><pre><code class="javascript">for (var i = 0; i &lt;= 10; i++) {    (function (i) {        funcs.push(function () {            console.log(i);        });    })(i)}// 也是 IIFEfor (var i = 0; i &lt;= 10; i++) {    funcs.push(        (function (value) {            return function () {                console.log(value);            }        })(i)    );}</code></pre><p>IIFE 表达式为自己接收的 <code>每一个变量 i</code> 都创建了一个 ** 副本 **。这个副本的值显然就是此时的变量 <code>i</code> 的值。</p><h1 id="循环中的-let-声明："><a href="#循环中的-let-声明：" class="headerlink" title="循环中的 let 声明："></a>循环中的 let 声明：</h1><p>每次循环, let 声明创建一个 <code>新变量 i</code>, 将其初始化 <code>i</code> 的当前值, 所以, 循环内部创建的函数都得到了 i 的副本。</p><pre><code class="javascript">// 输出 0-10for (let i = 0; i &lt;= 10; i++) {    funcs.push(function () {        console.log(i);    })}</code></pre><p><code>in</code> 和 <code>of</code> 循环也是一样的</p><pre><code class="javascript">let funcs = [];let arr = [&#39;a&#39;, &#39;v&#39;, &#39;e&#39;, &#39;d&#39;];// for (var e of arr) {//     funcs.push(function () {//         console.log(e);//     })// } // d d d d// for (let e of arr) {//     funcs.push(function () {//         console.log(e);//     })// }// a v e d// for (var e in arr) {//     funcs.push(function () {//         console.log(e);//     })// } // 3 3 3 3// for (let e in arr) {//     funcs.push(function () {//         console.log(e);//     })// } // 0 1 2 3funcs.forEach((e) =&gt; {    e();})</code></pre><h1 id="循环中的-const-声明"><a href="#循环中的-const-声明" class="headerlink" title="循环中的 const 声明"></a>循环中的 const 声明</h1><p>由于 const 声明的基本类型是不可变的，所以下面的代码报错：</p><pre><code class="javascript">for (const i = 0; i &lt; 9; i++) {    console.log(i);}</code></pre><p>具体是指 <code>i++ 时 TypeError: Assignment to constant variable.</code>。<br>对于 <code>for-in</code> 和 <code>for-of</code>，<code>const</code> 的使用效果与 <code>let</code> 一致, 只是不能在循环内手动修改迭代的值。</p><pre><code class="javascript">let arr2 = [[1, 3], [2, 4]];for (const i of arr2) {    console.log(i);    // i = [0]; // TypeError: Assignment to constant variable.}</code></pre><p>之所以可以这样，原因同前面的 let 一样，在 <code>for-in</code> 和 <code>for-of</code> 时，会创建一个新的 const 绑定。<br>相当于将值进行了复制，每次迭代时都从 <code>arr2</code> 中取出值赋值给迭代变量。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;😕&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>数值 - JS 悟道</title>
    <link href="https://kouder.cn/2021/10/24/shu-zhi-js-wu-dao/"/>
    <id>https://kouder.cn/2021/10/24/shu-zhi-js-wu-dao/</id>
    <published>2021-10-24T02:32:22.000Z</published>
    <updated>2022-04-01T02:55:31.597Z</updated>
    
    <content type="html"><![CDATA[<p>1+53+11 === 64</p><a id="more"></a><h1 id="零"><a href="#零" class="headerlink" title="零"></a>零</h1><p>现实里没有 <code>0</code> 和 <code>-0</code>，但是 JS 使用的 IEEE754 标准里有的，JS 里做了一些手脚😎使得直接比较两者是相同的。</p><pre><code>-0 === 0// true</code></pre><p>但是，最好 0 不要用来做除数，也不要使用 <code>Object.is()</code></p><pre><code>(1 / 0) === (1 / -0)// falseObject.is(0, -0);// false</code></pre><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>JS 内置很多不可变的 number 对象，每个数值字面量实质是对这些不可变 number 对象的引用。字面量值与 number 对象值很接近或者完全吻合。<br>Number 挂载了一些有用的常量。<br><code>Number.EPSILON</code> 保存的是最小的正数。当两数之差小于此数，JS 可以认为两数相等。<br>比如这个经典场景：</p><pre><code>0.1 + 0.2 - 0.3// 5.551115123125783e-170.1 + 0.2 - 0.3 &lt; Number.EPSILON// true</code></pre><p><code>Number.MAX_SAFE_INTEGER</code> 约 9000 万亿，就是 <code>2 ** 53 - 1</code> 打印的结果。<br>同理，<code>Number.MIN_SAFE_INTEGER</code> 是 <code>- (2 ** 53 - 1)</code>。<br>** 在一个期望为整数的运算中，只有所有参与运算的因子，运算结果，中间结果都是在安全整数范围内时，才可以进行精确的整数运算。**<code>Number.isSafeInteger</code> 可以判断是否是安全的整数。</p><p><code>Number.MAX_VALUE</code> 是 JS 的 Number 类型中最大的值，等于 <code>Number.MAX_SAFE_INTEGER * 2 ** 971</code>，其精度损失很大。<br><code>Number.MIN_VALUE</code> 是 JS 中无限逼近 0 的数，值是 <code>2 ** -1074</code>，其精度损失很大。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><blockquote><p>取余运算 <code>%</code> 取决于被除数，取模运算（JS 不支持）取决于除数。</p></blockquote><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>JS 做位运算时，有个坑：参与位运算的 number 类型会被转换为 32 位有符号整型（Java 的 int）进行计算，在得到计算结果后，再转换为 JS 的数值类型。虽然 JS 有 54 位安全整数，但是参与位运算时最高的 22 个位会被丢掉，没有任何警告信息。<br>所以，当你想用左移和右移代替乘除时，要注意这个坑。<br>当对负数进行右移时，使用带符号的右移 <code>&gt;&gt;</code> 而不是 <code>&gt;&gt;&gt;</code></p><pre><code>-2 &gt;&gt; 1// -1-2 &gt;&gt;&gt; 1// 2147483647</code></pre><h1 id="解析-Number-的函数"><a href="#解析-Number-的函数" class="headerlink" title="解析 Number 的函数"></a>解析 Number 的函数</h1><pre><code class="javascript">function deconstruct(number) {    // 数值 = 符号位 * 系数 * (2 ** 指数)    let sign = 1;  // 符号位    let coefficient = number;  // 系数    let exponent = 0;  // 2 ** 指数    if (coefficient &lt; 0) {        coefficient = -coefficient;        sign = -1;    }    if (Number.isFinite(number) &amp;&amp; number !== 0) {        exponent = -1128;        let reduction = coefficient;        // 系数不断除 2, 直到趋近于 0 为止, 将除 2 次数与 - 1128 相加, 结果即变量 exp 的值        while (reduction !== 0) {            exponent += 1;            reduction /= 2;        }        reduction = exponent;        // 当指数为 0 时, 可以认为这个值是整数了.        while (reduction &gt; 0) {            coefficient /= 2;            reduction -= 1;        }        while (reduction &lt; 0) {            coefficient *= 2;            reduction += 1;        }        return {            sign, coefficient, exponent, number        }    }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1+53+11 === 64&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://kouder.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>身份验证与授权</title>
    <link href="https://kouder.cn/2021/10/13/shen-fen-yan-zheng-yu-shou-quan/"/>
    <id>https://kouder.cn/2021/10/13/shen-fen-yan-zheng-yu-shou-quan/</id>
    <published>2021-10-13T06:58:01.000Z</published>
    <updated>2022-04-01T02:55:21.035Z</updated>
    
    <content type="html"><![CDATA[<p>外网教程，翻译过来看着玩玩，哈哈。</p><a id="more"></a><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h1 id="什么是验证-Authentication？"><a href="#什么是验证-Authentication？" class="headerlink" title="什么是验证 Authentication？"></a>什么是验证 Authentication？</h1><p>身份验证是验证给定用户或客户端身份的过程。换句话说，它涉及到确保他们真正是他们。</p><p>有三种身份验证因素可以对不同类型的身份验证进行分类：</p><ul><li>你独有的记忆 or 信息，例如，password 和安全问题（你的小学的名字）。这称为 “knowledge factors”</li><li>你独有的东西，例如，物理的，手机，安全令牌。称为 “possession factors”</li><li>你或者你的行为，例如，生物信息，行为信息。称为 “inherence factors”</li></ul><h1 id="验证和授权区别？"><a href="#验证和授权区别？" class="headerlink" title="验证和授权区别？"></a>验证和授权区别？</h1><p>身份验证是验证用户是否真实是他们声称的身份的过程，而授权则涉及验证用户是否被允许做某事。</p><p>验证：在网站或 Web 应用程序中，身份验证用来确定：尝试使用用户名 Carlos123 访问网站的人是否真的是创建帐户的同一个人。</p><p>授权：一旦 Carlos123 被验证，他的权限将决定他是否被授权访问有关其他用户的个人信息或执行删除其他用户帐户等操作。</p><h1 id="身份验证漏洞是如何产生的？"><a href="#身份验证漏洞是如何产生的？" class="headerlink" title="身份验证漏洞是如何产生的？"></a>身份验证漏洞是如何产生的？</h1><p>从广义上讲，身份验证机制中的大多数漏洞产生于两种方式之一：</p><ul><li>身份验证机制薄弱，因为它们无法充分防止暴力攻击。 </li><li>身份验证过程中的逻辑缺陷或编码不良使身份验证机制完全被攻击者绕过。这有时被称为 “损坏的身份验证 broken authentication”。<br>在 Web 开发中，逻辑缺陷只会导致网站行为出乎意料，这可能引发安全问题，也可能不会。但是，由于身份验证对安全性至关重要，有缺陷的身份验证逻辑会明显增加安全问题的可能性。</li></ul><h1 id="身份验证漏洞的影响？"><a href="#身份验证漏洞的影响？" class="headerlink" title="身份验证漏洞的影响？"></a>身份验证漏洞的影响？</h1><p>身份验证漏洞的影响可能非常严重。一旦攻击者绕过身份验证或强行进入其他用户的帐户，他们就可以访问被攻击的帐户所拥有的所有数据和功能。</p><p>如果他们能够侵入一个享有高度特权的帐户，如系统管理员，他们可以完全控制整个应用程序，并有可能获得对内部基础设施的访问权限。 </p><p>即使泄露低特权帐户，攻击者也可能访问他们本来不应该拥有的数据，例如商业敏感的商业信息。</p><p>即使帐户无法访问任何敏感数据，它也可能允许攻击者访问非直接公开的页面，从而进一步展开攻击。通常，某些高严重性的攻击无法从可公开访问的页面直接进行，但从一些内部页面中可能实现。</p><h1 id="身份验证机制中的漏洞"><a href="#身份验证机制中的漏洞" class="headerlink" title="身份验证机制中的漏洞"></a>身份验证机制中的漏洞</h1><p>网站的身份验证系统通常由几个可能发生漏洞的不同机制组成。某些漏洞在所有这些上下文中广泛适用，而另一些漏洞则更具体于所提供的功能。</p><h2 id="基于密码的登陆的漏洞"><a href="#基于密码的登陆的漏洞" class="headerlink" title="基于密码的登陆的漏洞"></a>基于密码的登陆的漏洞</h2><p>对于采用基于密码的登录过程的网站，用户要么自己注册帐户，要么由管理员分配帐户。此帐户与一个唯一的用户名和一个关联的密码，用户以登录形式输入该密码以验证确实是自己。</p><p>在这种情况下，只有用户自己知道密码的事实被视为用户身份的充分证明。</p><p>因此，如果攻击者能够获取或猜测用户的登录名与密码，网站的安全性将受到损害。</p><p>下面列出一些利用方法：</p><h3 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h3><p>暴力攻击是攻击者使用系统不断地猜测有效的用户凭据。这些攻击通常使用巨大的用户名和密码的字列字典进行自动化。使用专用工具自动化此过程，使攻击者能够高速进行大量登录尝试。</p><p>暴力攻击并不总是只是对用户名和密码进行完全随机猜测的情况。通过使用基本逻辑或公开的知识，攻击者可以微调攻击，以做出更多有根据的猜测。这大大提高了这种攻击的效率。如果网站不实施足够的暴力攻击防范措施，则基于密码对用户唯一身份验证的网站可能会非常脆弱。</p><p><strong>** 暴力破解用户名 **</strong></p><p>用户名如果符合可识别的模式，那么特别容易猜测，如学校的电子邮件地址 <code>姓名.@学校域名</code>。但是，即使没有明显的模式，有时甚至使用可预测的用户名（如 <code>admin</code> 或 <code>administrator</code>）创建高特权帐户。</p><p>在审查过程中，检查网站是否公开披露潜在用户名。</p><p>例如，能否在不登录的情况下访问用户配置文件？</p><p>即使隐藏了配置文件的实际内容，配置文件本身使用的名称有时也与登录用户名相同。</p><p>还应检查 HTTP 响应，看看是否有任何电子邮件地址被披露。有时，一些网站的响应包含了管理员和 IT 支持等高特权用户的电子邮件地址。</p><p>** 暴力破解密码 **</p><p>许多网站采用某种形式的密码策略，迫使用户创建高熵密码</p><p>然而，虽然高熵密码是很难单独计算机破解，我们可以使用人类行为的基本知识，以利用用户无意的加入的字符。用户通常不会使用随机组合的字符创建强密码，而是使用他们能够记住的密码，以配合密码策略。</p><p>例如，mypassword 不满足网站要求，会使用 <code>Mypasswprd1!</code> 或者 <code>Myp4$$w0rd</code> </p><p>如果该政策要求用户定期更改密码，用户也经常只是对其首选密码进行轻微的可预测更改。<code>Mypasswprd1!</code> 改为 <code>Mypasswprd2!,Mypasswprd1?</code></p><p>** 用户名枚举 **</p><p>用户名列举是攻击者能够观察网站行为的变化，以确定给定用户名是否有效。</p><p>用户名列举通常可以借助录页面，例如，当输入有效的用户名但密码不正确时（提示密码不正确），或在 ** 注册表单中输入已经被占用的用户名时 **。这大大减少了对登录进行暴力所需的时间和精力，因为攻击者能够快速生成有效用户名。</p><p>尝试暴力登陆页面时，下面几个需要留意：</p><ul><li><p>HTTP 状态码。绝大多数猜测的结果可能都是一样的，因为大多数猜测都是错误的。如果一个猜测返回一个不同的状态代码，很有可能表明用户名是正确的。不管结果如何，网站总是返回相同的状态代码是最佳实践，但这种实践并不总是被遵循。</p></li><li><p>错误信息。 有时返回的错误消息是不同的，这取决于用户名和密码是否都不正确，或者只是密码不正确。对于网站来说，最好的做法是在两种情况下使用相同的、通用的信息，但是有时会出现一些小的输入错误</p></li><li><p>响应时间。如果大多数请求都以相似的响应时间处理，那么任何偏离这一时间的请求都表明在幕后发生了不同的事情。这是猜测的用户名可能正确的另一个迹象。例如，一个网站可能只检查密码是否正确如果用户名是有效的。这个额外的步骤可能会稍微增加响应时间。这可能很微妙，但是攻击者可以通过输入一个过长的密码使延迟更加明显，而网站需要更长的时间来处理这个密码。<br>** 暴力破解时，可能会被封锁 IP，在一定时间内禁止登陆行为，此时可以尝试借助 HTTP 的 **<code>X-Forwarded-For:IP 地址</code> 来伪装。</p><p>原文这里给了三个 LAB，就是靶场，可以去试试。<br>用 Python 脚本就几行，这里贴个第三题吧：</p><pre><code class="python">import threadingimport requests</code></pre></li></ul><p>“””使用多线程加上 X-Forwarded-For 伪装 IP 来暴力破解”””</p><p>passwords = “””<br>123456<br>password<br>……<br>“””usernames =”””<br>carlos<br>root<br>……<br>“””passwords = passwords.split(“\n”)[1:-1]<br>usernames = usernames.split(“\n”)[1:-1]</p><p>def force(username, passwords, i):<br>    for idx, password in enumerate(passwords):<br>        # res = {}<br>        # for username in usernames:<br>        url = ‘https:// 靶场的登录 URL’<br>        r = requests.post(<br>            url, {“username”: username, “password”: password}, headers={ “X-Forwarded-For”:f’123.123.{i}.{idx}’ })<br>        if r.text.find(“Invalid username or password”) == -1:<br>            # if int(r.status_code) == 302:<br>            print(f’find: {username} ~ {password}’)<br>            return</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    start = 0<br>    while start &lt; len(usernames):<br>        start += 10<br>        if start &gt;= len(usernames):<br>            start = len(usernames)<br>        for i in range(start - 10, start):<br>            t = threading.Thread(target=force, args=(usernames[i], passwords, i))<br>            t.start()<br>            # if (i == start - 1):<br>            #     t.join()</p><pre><code></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;外网教程，翻译过来看着玩玩，哈哈。&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://kouder.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="网络安全" scheme="https://kouder.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>一步步实现 Promise</title>
    <link href="https://kouder.cn/2021/10/10/yi-bu-bu-shi-xian-promise/"/>
    <id>https://kouder.cn/2021/10/10/yi-bu-bu-shi-xian-promise/</id>
    <published>2021-10-10T08:42:46.000Z</published>
    <updated>2022-04-01T02:56:28.128Z</updated>
    
    <content type="html"><![CDATA[<p>实现了但没完全实现。。。</p><a id="more"></a><p>使用的 ES6 的 class 方式实现的。<br>参考掘金作者 <a href="https://juejin.cn/user/1292681407377624" target="_blank" rel="noopener">Sunshine_Lin</a> 的实现，链接在本文末尾。</p><h1 id="实现构造器"><a href="#实现构造器" class="headerlink" title="实现构造器"></a>实现构造器</h1><p>要点：</p><ol><li>promise 有三个状态，分别是 <code>pending fulfilled rejected</code>，所以实例需要一个保存这个状态的变量。</li><li>promise 需要保存执行后的结果，又需要一个变量保存。</li><li>执行器 exec 里报错时，抛出异常，promise 需要变为 <code>rejected</code> 状态</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    constructor(exec) {        this.promiseResult = undefined;        this.promiseState = &#39;pending&#39;;        try {            exec(this.resolve, this.reject);        } catch (e) {            this.reject(e)        }    }}</code></pre><h1 id="实现-resolve-和-reject"><a href="#实现-resolve-和-reject" class="headerlink" title="实现 resolve 和 reject"></a>实现 resolve 和 reject</h1><p>要点：</p><ol><li>promise 由 <code>pending</code> 变为 <code>fulfilled</code> 或者 <code>rejected</code> 后，就 <code>settle</code> 了不会再变了</li><li>要将 resolve 和 reject 的 this 绑定，防止跟随执行环境发生变化</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    constructor(exec) {       // ...    }    resolve = (value) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseResult = &#39;fulfilled&#39;            this.promiseState = value;        }    }    reject = (reason) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseResult = &#39;rejected&#39;;            this.promiseState = reason;        }    }}</code></pre><h1 id="实现同步的-then"><a href="#实现同步的-then" class="headerlink" title="实现同步的 then"></a>实现同步的 then</h1><p>要点：</p><ol><li>因为 then 的两个参数可以省略, 所以需要判断并设置默认值</li><li>根据 promise 的状态执行 then 的不同的函数</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    // ...    then = (onFulfilled, onRejected) =&gt; {        // 因为 then 的两个参数可以省略, 所以需要判断        onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : val =&gt; val;        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; { throw reason };        if (this.promiseState === &#39;fulfilled&#39;) {            onFulfilled(this.promiseResult)        }        if (this.promiseState === &#39;rejected&#39;) {            onRejected(this.promiseResult)        }    }}</code></pre><p>同步的 then，无法处理异步任务中的 resolve 和 reject，因为同步执行时 <code>promiseState</code> 还在 <code>pending</code> 状态。不会执行 onFulfilled 或者 onRejected 函数。</p><h1 id="实现异步的-then"><a href="#实现异步的-then" class="headerlink" title="实现异步的 then"></a>实现异步的 then</h1><p>如何保证 then 方法是在 resolve 或这 reject 后才执行?<br>还需要在 then 做功夫，既然同步执行时 <code>promiseState</code> 还在 <code>pending</code> 状态，就再加一个 if 判断，当 promise 状态为 <code>pending</code> 时执行 then，则将当前 then 方法传入的的 <code>onFulfilled</code> 函数和 <code>onRejected</code> 函数放入 promise 实例的所维护的数组中（我发现使用一个变量保存一个函数就可以，想不到为啥用数组，难道有多次 then，而且第二次 then 时，promise 还是 <code>pending</code> 状态？有这种场景？？？）。<br>放入数组的函数，在 resolve 或者 reject 真正执行的时候，才会被执行，此时就拿出数组的 <code>onFulfilled</code> 函数和 <code>onRejected</code> 函数，依次执行。<br>要点：</p><ol><li>添加实例变量，保存在 promise 为 <code>pending</code> 状态时，then 被调用时传入的函数参数</li><li>在 resolve 和 reject 内调用这些方法。</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    constructor(exec) {        this.promiseResult = undefined;        this.promiseState = &#39;pending&#39;;        // this.onFulFilledCallback = [];        // this.onRejectedCallback = [];        // 好像不用数组也行...        this.onFulFilledCallback = null;        this.onRejectedCallback = null;        try {            exec(this.resolve, this.reject);        } catch (e) {            this.reject(e)        }    }    resolve = (value) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseState = &#39;fulfilled&#39;            this.promiseResult = value;            // console.log(this.onFulFilledCallback.length);            // this.onFulFilledCallback.shift()(value)            if (this.onFulFilledCallback) {                this.onFulFilledCallback(value)            }        }    }    reject = (reason) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseState = &#39;rejected&#39;;            this.promiseResult = reason;            if (this.onRejectedCallback) {                this.onRejectedCallback(reason)            }        }    }    then = (onFulfilled, onRejected) =&gt; {        // 因为 then 的两个参数可以省略, 所以需要判断        onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : val =&gt; val;        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; { throw reason };        if (this.promiseState === &#39;fulfilled&#39;) {            onFulfilled(this.promiseResult);        }        if (this.promiseState === &#39;rejected&#39;) {            onRejected(this.promiseResult);        }        if (this.promiseState === &#39;pending&#39;) {            // this.onFulFilledCallback.push(onFulfilled);            // this.onRejectedCallback.push(onRejected);            this.onFulFilledCallback = onFulfilled;            this.onRejectedCallback = onRejected;        }    }}</code></pre><h1 id="实现可链式调用的-then"><a href="#实现可链式调用的-then" class="headerlink" title="实现可链式调用的 then"></a>实现可链式调用的 then</h1><p>要点：</p><ol><li>then 会返回一个新的 promise 实例</li><li>原来的 then 的处理需要 “通知” 到新的 promise 实例</li><li>如果 then 的函数参数的返回值是 promise, 那么新的 promise 实例返回的状态取决于这个 promise</li><li>如果返回值非 promise, 新 promise 对象就是 fulfilled, 且值为此返回值</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    constructor(exec) {        this.promiseResult = undefined;        this.promiseState = &#39;pending&#39;;        this.onFulFilledCallback = [];        this.onRejectedCallback = [];        try {            exec(this.resolve, this.reject);        } catch (e) {            this.reject(e)        }    }    resolve = (value) =&gt; {        console.log(&#39;resolve:&#39;, value, &#39;|&#39;, this.onFulFilledCallback);        if (this.promiseState === &#39;pending&#39;) {            this.promiseState = &#39;fulfilled&#39;            this.promiseResult = value;            while (this.onFulFilledCallback.length) {                console.log(&#39;this.onFulFilledCallback.length:&#39;, this.onFulFilledCallback.length);                this.onFulFilledCallback.shift()(this.promiseResult)            }        }    }    reject = (reason) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseState = &#39;rejected&#39;;            this.promiseResult = reason;            while (this.onRejectedCallback.length) {                this.onRejectedCallback.shift()(this.promiseResult)            }        }    }    then = (onFulfilled, onRejected) =&gt; {        // 因为 then 的两个参数可以省略, 所以需要判断并设置默认值        onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : val =&gt; val;        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; { throw reason };        // 放到 thenPromise 里了        // if (this.promiseState === &#39;fulfilled&#39;) {        //     onFulfilled(this.promiseResult);        // }        // if (this.promiseState === &#39;rejected&#39;) {        //     onRejected(this.promiseResult);        // }        // if (this.promiseState === &#39;pending&#39;) {        //     this.onFulFilledCallback.push(onFulfilled);        //     this.onRejectedCallback.push(onRejected);        // }        let thenPromise = new MyPromise((res, rej) =&gt; {            // console.log(this.promiseState);            // 此函数是一个箭头函数, exec 也是箭头函数, 所以 resolvePromise 声明时就会绑定到外面的 promise, 而不是这个 promise            const resolvePromise = tt =&gt; {                try {                    // 这个 this 是外面的, 而不是这个新建的 MyPromise 的                    const x = tt(this.promiseResult);  // 执行 tt 函数，拿到函数执行的结果，根据此结果进行判断。                    if (x === this.thenPromise) {  // 这个判断不懂。。。                        throw new Error(&quot;then 返回一个新的 promise 而不是自身&quot;)                    }                    if (x instanceof MyPromise) {                        // console.log(&#39;here&#39;);                        x.then(res, rej);                    } else {                        // 非 promise 时 primise 实例就是调用 resolve 的 fulfilled 的                        res(x);                    }                } catch (err) {                    rej(err)                }            }            if (this.promiseState === &#39;fulfilled&#39;) {                // onFulfilled(this.promiseResult);                resolvePromise(onFulfilled);            }            if (this.promiseState === &#39;rejected&#39;) {                // onRejected(this.promiseResult);                resolvePromise(onRejected);            }            // resolve 或者 reject 是被异步调用的            if (this.promiseState === &#39;pending&#39;) {                this.onFulFilledCallback.push(() =&gt; {                    resolvePromise(onFulfilled)                });                this.onRejectedCallback.push(() =&gt; {                    resolvePromise(onRejected)                });            }        })        return thenPromise;    }}</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/6994594642280857630" target="_blank" rel="noopener">https://juejin.cn/post/6994594642280857630</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;实现了但没完全实现。。。&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Git 文件泄露</title>
    <link href="https://kouder.cn/2021/09/30/git-wen-jian-xie-lu/"/>
    <id>https://kouder.cn/2021/09/30/git-wen-jian-xie-lu/</id>
    <published>2021-09-30T08:36:06.000Z</published>
    <updated>2022-04-01T02:53:38.038Z</updated>
    
    <content type="html"><![CDATA[<p>不要忽略. git 目录</p><a id="more"></a><p><code>.git</code> 目录如果在可访问的目录下，会造成源码等文件泄露。<br>因为，git 本身是一个数据库，每次 add 添加文件，就在 <code>.git/objects</code> 目录下保存了数据。<br>如果其他人可以随意访问 <code>.git</code> 目录，那么就可以从中取到并还原所有文件。<br>可以参考这个 <a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">Git 内部原理</a><br>在实际利用时，<a href="https://github.com/denny0223/scrabble" target="_blank" rel="noopener">这个 git 泄露利用工具</a> 就是使用了 git 命令把服务器上的 git 目录完整地搞下来。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;不要忽略. git 目录&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络安全" scheme="https://kouder.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>SQL 注入二</title>
    <link href="https://kouder.cn/2021/09/21/sql-zhu-ru-er/"/>
    <id>https://kouder.cn/2021/09/21/sql-zhu-ru-er/</id>
    <published>2021-09-21T09:26:16.000Z</published>
    <updated>2022-04-01T02:55:43.916Z</updated>
    
    <content type="html"><![CDATA[<p>续 - 注入实例</p><a id="more"></a><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>需要盲注的场景是，Web 应用不会在响应中返回 SQL 查询的结果，或者 SQL 的，数据库的错误。此时用前面的注入方式是无法看到查询结果的。<br>盲注比较复杂并且比较难执行。</p><p>根据漏洞的性质和所涉及的数据库，以下技术可用盲注：</p><ul><li>您可以更改查询语句的逻辑，从而根据单个条件的真实性来触发应用程序响应中的可以观察出的差异。这可能涉及将新条件注入某些 Boolean 逻辑，或有条件地触发错误，如除以零。</li><li>您可以设定条件去触发查询处理中的时间延迟，允许您根据应用程序响应所需的时间推断出条件的真实性。</li><li>您可以使用 <code>OAST</code> 技术触发带外网络交互(out-of-band)。这种技术非常强大，可以在其他技术不起作用的情况下工作。通常，您可以通过带外网络交互直接渗出数据，例如将数据放入您控制的域名的 DNS lookup。</li></ul><h3 id="触发有条件的响应"><a href="#触发有条件的响应" class="headerlink" title="触发有条件的响应"></a>触发有条件的响应</h3><p>考虑使用 Cookie 收集有关使用情况的分析的应用程序。<br>程序请求包括这样的 cookie：</p><pre><code class="SQL">Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4（用户可控制的）</code></pre><p>应用程序可能会根据这个 ID 判断用户：</p><pre><code class="SQL">SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;u5YD3PapBcR4lN3e7Tj4(用户可控制的)&#39;</code></pre><p>虽然这个查询可能有 SQL 注入，但是查询结果用户看不到。<br>例如，应用会根据 ID 存在与否判断用户是否登陆，并返回登陆成功与失败的原因。</p><p>** 总之，会根据你在 <strong><strong>AND</strong></strong> 后追加的条件的真假返回不同的信息即可。<strong>** 这就足够了。</strong></p><p>此响应足以用来盲注，并通过有条件地触发不同的响应来检索信息，具体取决于注射条件。<br>要了解其工作原理，请假设发送了两个请求，依次包含以下 “跟踪”Cookie 值：</p><pre><code class="SQL">...cookieid&#39;AND&#39;1&#39;=&#39;1拼接后的查询语句：SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;...cookieid&#39; AND &#39;1&#39;=&#39;1&#39;...cookieid&#39;AND&#39;1&#39;=&#39;2拼接后的查询语句：SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;...cookieid&#39; AND &#39;1&#39;=&#39;2&#39;</code></pre><p>第一个将导致查询返回结果，因为注入的 <code>AND &#39;1&#39;=&#39;1</code> 是 true, 因此将显示登陆成功的消息。</p><p>第二个导致查询不会返回任何值，因为注入的条件时 false</p><p>这两种操作可以让我们能够确定任何单一条件注入的答案，可以每次提取出一点数据。</p><p>举例来说，假设有一个称为 <code>Users</code> 的表，列是 <code>Username</code> 和 <code>Password</code> 有一个用户 Administrator</p><p>我们可以通过发送一系列输入逐渐地确定此用户的密码，以一次测试一个字符的密码。</p><pre><code class="SQL">abcd&#39;AND SUBSTRING((SELECT password FROM users where username=&#39;admin&#39;), 1, 1) &gt;&#39;m</code></pre><p>上述的 SUBSTREING 的意思是查询用户 admin 的密码，看其第一个 (从索引 1 开始截取一个字符) 字符是否大于字符 <code>m</code> </p><p>根据服务器返回的结果判断是否正确</p><p>然后，可以使用二分法判断到底是哪个字符</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;续 - 注入实例&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络安全" scheme="https://kouder.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>SQL 注入一</title>
    <link href="https://kouder.cn/2021/09/20/sql-zhu-ru/"/>
    <id>https://kouder.cn/2021/09/20/sql-zhu-ru/</id>
    <published>2021-09-20T09:57:04.000Z</published>
    <updated>2022-04-01T02:55:40.206Z</updated>
    
    <content type="html"><![CDATA[<p>First Blood</p><a id="more"></a><h1 id="SQL-注入是什么？"><a href="#SQL-注入是什么？" class="headerlink" title="SQL 注入是什么？"></a>SQL 注入是什么？</h1><p>SQL 注入是一种网络安全漏洞，允许攻击者干扰应用程序对其数据库的查询。它通常允许攻击者查看他们通常无法检索的数据。这可能包括属于其他用户的数据，或应用程序本身能够访问的任何其他数据。在许多情况下，攻击者可以修改或删除此数据，从而持续更改应用程序的内容或行为。<br>在某些情况下，攻击者可能会升级 SQL 注入攻击，以损害基础服务器或其他后端基础架构，或执行拒绝服务攻击。</p><h1 id="注入实例"><a href="#注入实例" class="headerlink" title="注入实例"></a>注入实例</h1><p>在不同情况下会出现各种各样的 SQL 注射漏洞、攻击和技术。一些常见的 SQL 注射示例包括：</p><h2 id="检索隐藏数据"><a href="#检索隐藏数据" class="headerlink" title="检索隐藏数据"></a>检索隐藏数据</h2><p>考虑显示不同类别产品的购物应用程序。<br>当用户单击页面中分类栏的 “Gift” 类别时，他们的浏览器会请求类似这种 URL：</p><pre><code>https://insecure-website.com/products?category=Gifts</code></pre><p>后台查询语句为：</p><pre><code>SELECT * FROM products WHERE category = &#39;Gifts AND released = 1</code></pre><p>语句返回 products 表中符合 WHERE 条件的记录的的所有字段。released=1 表示尚未上架的。</p><p>如果后台没有进行防护，直接使用 URL 的参数 <code>Gift</code> 这个字符串去查询，就有注入风险。<br>注入类似：</p><pre><code>https://insecure-website.com/products?category=Gifts&#39;--</code></pre><p>这可能导致后台执行下面的查询语句：</p><pre><code>SELECT * FROM products WHERE　categoty = &#39;Gifts&#39;-- AND released = 1</code></pre><p>** 关键是两个折线 <code>--</code> 在 SQL 中表示注释的意思，这样注释后面的” 查询语句 “就会作废 **。这意味着所有产品都显示在显示中，包括未上架的产品。<br>更进一步，还可以显示所有分类的商品</p><pre><code>https://insecure-website.com/products?category=Gifts&#39;+OR+1=1--</code></pre><p>可能导致后台执行下面的查询语句：</p><pre><code>SELECT * FROM products WHERE category = &#39;Gifts&#39; OR 1=1--&#39; AND released = 1</code></pre><p>因为是 OR，每一个记录都会满足 <code>1=1</code>，所以，会返回所有记录！</p><blockquote><p>注意，后台将 URL 参数作为 SQL 查询条件时，有没有自带引号，上述注入是假设，带了单引号。</p></blockquote><h2 id="覆盖应用逻辑"><a href="#覆盖应用逻辑" class="headerlink" title="覆盖应用逻辑"></a>覆盖应用逻辑</h2><p>有一个登陆逻辑是：直接根据用户的输入的用户名，密码去查询，有记录返回则登陆成功，否则视为失败。</p><pre><code>SELECT * FROM users WHERE username = &#39;wiener&#39; AND password = &#39;bluecheese&#39;</code></pre><p>此时，可以利用注释，去覆盖这个用逻辑。用户名填 <code>administrator&#39;--</code>，密码随便输入。</p><pre><code>SELECT * FROM users WHERE username = &#39;administrator&#39;--&#39;AND password =&#39;&#39;</code></pre><p>这个语句会返回 admin 这个用户的记录，符合上面登陆成功的逻辑！</p><h2 id="获取其他表的数据-UNION"><a href="#获取其他表的数据-UNION" class="headerlink" title="获取其他表的数据 - UNION"></a>获取其他表的数据 - UNION</h2><p>** 如果 SQL 查询的结果在应用程序的响应中返回，攻击者可以利用 SQL 注入漏洞从数据库中的其他表中检索数据。**<br>这是使用 <code>UNION</code> 关键字完成的，该关键字允许您执行额外的 <code>Select</code> 查询并将结果附加到原始查询中。<br>例如，如果软件完全根据用户的输入，执行下面的查询：</p><pre><code>SELECT name, description FROM products WHERE category = &#39;Gifts&#39;</code></pre><p>可以将输入构造为：</p><pre><code>&#39; UNION SELECT username,password FROM users--</code></pre><p>返回</p><p>注意，UNION 查询需要满足：</p><ol><li>UNION 后选择的记录的列数要与前面选择的列数，前后一致，否则 SQL 查询本身会报错！</li><li>每个列中的数据类型必须在各个查询之间兼容。</li></ol><p>要执行 SQL UNION 攻击，您需要确保您的攻击满足这两个 ** 前提条件 **。<br>这通常涉及找出</p><ol><li>从原始正常查询返回了多少列？</li><li>从原始查询返回的哪些列属于合适的数据类型，用来保存注入查询后的结果？</li></ol><p>下面进行解答</p><h3 id="find-列数"><a href="#find-列数" class="headerlink" title="find 列数"></a>find 列数</h3><p>有两种有效方法来确定从原始查询返回的列数。</p><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>第一种方法涉及注入一系列 <code>ORDER BY 索引</code> 子句并增加指定列索引，直到发生错误。</p><pre><code>&#39;ORDER BY 1--&#39; ORDER BY 2--&#39; ORDER BY 3--...</code></pre><p>此时，列数就是发生错误的 <code>ORDER BY</code> 的索引减一。</p><p>实际应用中，应用程序实际上可能在 HTTP 响应中的返回数据库错误，也可能返回通用错误，或者只是返回中没有任何结果。</p><p>只要能够检测到应用程序响应中的某些差异，则可以推断从查询返回的列数</p><h4 id="UNION-SELECT-NULL"><a href="#UNION-SELECT-NULL" class="headerlink" title="UNION SELECT NULL"></a>UNION SELECT NULL</h4><p>第二种方法，在 <code>UNION</code> 后 <code>SELECT</code> 一定数量的 <code>NULL</code></p><pre><code>&#39;UNION SELECT NULL--&#39; UNION SELECT NULL, NULL--&#39; UNION SELECT NULL, NULL, NULL--</code></pre><p>只有当 NULL 个数与前面的 SELECT 查询的列数一致，才会返回结果，否则 SQL 查询会报错。当查询的结果正确返回时，会多一条记录，每一列都是 NULL。<br>幸运的话，会在返回的结果中看出不同个数 NULL 的区别。</p><p>使用 NULL 获取列数需要注意：</p><ul><li>使用 <code>NULL</code> 作为从注入的 <code>SELECT</code> 查询返回的值的原因是，每个列中的数据类型必须在原始查询和注入查询之间兼容。由于 <code>NULL</code> 可转换为所有常用的数据类型，因此使用 <code>NULL</code> 可最大限度地提高列计数正确时有效载荷成功的可能性。</li><li>Oracle 数据库，每个 SQL 的 SELECT 都需要带着 FROM。Oracle 有一个内建的表 <code>dual</code>，所以针对 Oracle 数据库，使用 <code>&#39; UNION SELECT NULL FROM dual--</code></li><li>MySQL 数据库的注释后面可能需要再加一个空格</li></ul><p><a href="https://portswigger.net/web-security/sql-injection/cheat-sheet" target="_blank" rel="noopener">SQL 注入 cheat sheet</a></p><h3 id="find-具有指定数据类型的列"><a href="#find-具有指定数据类型的列" class="headerlink" title="find 具有指定数据类型的列"></a>find 具有指定数据类型的列</h3><p>执行 SQL UNION 注入攻击的原因是能够从注注入攻击的查询中检索结果。<br>通常，要检索的有趣数据将以字符串形式显示，因此您需要在原始查询结果中找到一个或多个列，其数据类型是或与字符串数据兼容。</p><p>在确定所需列数后，您可以通过提交一系列带有 payload 的 UNION 查询来检测每个列是否可以保留字符串数据，将字符串值依次放入每个列中。<br>例如，如果查询返回四列，您将提交：</p><pre><code>&#39;UNION SELECT&#39;a&#39;,NULL,NULL,NULL--&#39; UNION SELECT NULL,&#39;a&#39;,NULL,NULL--&#39;UNION SELECT NULL,NULL,&#39;a&#39;,NULL--&#39; UNION SELECT NULL,NULL,NULL,&#39;a&#39;--</code></pre><p>如果未发生错误，并且应用程序的响应包含一些其他内容（包括注入的字符串值），则相关列适用于检索字符串数据。</p><blockquote><p>我在 MYSQL8 试了一下，就算类型不对也不会报错。。。</p></blockquote><h3 id="在单列中获取多个值"><a href="#在单列中获取多个值" class="headerlink" title="在单列中获取多个值"></a>在单列中获取多个值</h3><p>假设查询只返回一列，你想要的查询又需要两列，怎么办？<br>您可以通过将值串联在一起，轻松地在此单列中检索多个值，最好包括一个合适的分离器，以便您区分组合值。例如，在 Oracle 数据库上，您可以提交输入：</p><pre><code>&#39;UNION SELECT username ||&#39;~~&#39; || password FROM users--</code></pre><p>在 Oracle 数据库中，<code>||</code> 作用是连接字符串。此注入会连接 username 和 password 字段，以 <code>~~</code> 分开。</p><p>不同数据库的字符串连接方式不同。<br>MYSQL 是：</p><pre><code>&#39;UNION SELECT concat(username,&#39;~&#39;, password) from users--</code></pre><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><ol><li>获取查询得到的具体列数（UNION SELECT NULL 或者 ORDER BY 123）</li><li>确定哪些列的数据类型是可利用的（UNION SELECT ‘a’,NULL,NULL,NULL）</li><li>联合查询，可利用的列数不足则进行字符串拼接。</li></ol><h2 id="直接检索数据库信息"><a href="#直接检索数据库信息" class="headerlink" title="直接检索数据库信息"></a>直接检索数据库信息</h2><p>在初步识别到存在 SQL 注入漏洞后，获取有关 ** 数据库本身 ** 的一些信息通常很有用。这些信息往往可以为进一步利用铺平道路。</p><p>您可以查询数据库的版本详细信息。这样做的方式取决于数据库类型，因此您可以从任何技术中推断出 ** 数据库类型 **。<br>对于 Oracle 数据库：</p><pre><code>SELECT * FROM v$version;</code></pre><p>您还可以确定存在哪些数据库表，以及它们包含哪些列。<br>例如，在大多数数据库中，您可以执行以下查询来列出表：</p><pre><code>SELECT * FROM information_schema.tables</code></pre><h3 id="查询数据库版本和类型"><a href="#查询数据库版本和类型" class="headerlink" title="查询数据库版本和类型"></a>查询数据库版本和类型</h3><p>在利用 SQL 注入漏洞时，通常需要收集有关数据库本身的一些信息。这包括数据库软件的类型和版本，以及数据库的内容，包括它包含的表格和列。</p><ul><li>MySQL: <code>select @@version</code></li><li>Oracle: <code>select * from v@version</code>，此表只有一行记录，包含 <code>banner</code> 等字段。</li></ul><h3 id="数据库内容"><a href="#数据库内容" class="headerlink" title="数据库内容"></a>数据库内容</h3><p>大多数数据库（** 甲骨文除外 **）都有一组称为 <code>information schema</code> 的视图，提供有关数据库的信息。<br>具体就是表 <code>information_schema.tables</code><br>查询到表后，可以查询表 <code>information_schema.columns</code> 来继续查询指定的表的列</p><p>至于 Oracle，使用 <code>SELECT * FROM all_tables</code> 获得所有表<br>再继续使用 <code>SELECT * FROM all_tab_columns WHERE table_name = &quot;USERS&quot;</code></p><p><a href="https://portswigger.net/web-security/sql-injection" target="_blank" rel="noopener">课程源地址</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;First Blood&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="网络安全" scheme="https://kouder.cn/tags/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>JSX 的由来与语法</title>
    <link href="https://kouder.cn/2021/09/17/jsx-yu-react/"/>
    <id>https://kouder.cn/2021/09/17/jsx-yu-react/</id>
    <published>2021-09-17T08:50:47.000Z</published>
    <updated>2022-04-01T02:54:15.828Z</updated>
    
    <content type="html"><![CDATA[<p>为什么 React 需要 JSX</p><a id="more"></a><h1 id="JSX-由来"><a href="#JSX-由来" class="headerlink" title="JSX 由来"></a>JSX 由来</h1><h2 id="React-通过创建虚拟元素来管理整个虚拟-DOM"><a href="#React-通过创建虚拟元素来管理整个虚拟-DOM" class="headerlink" title="React 通过创建虚拟元素来管理整个虚拟 DOM"></a>React 通过创建虚拟元素来管理整个虚拟 DOM</h2><p>虚拟元素与真实元素是对应的，它的构建和更新在内存中完成（废，过程不会反映给真实 DOM。<br>React 的虚拟元素分为：1-DOM 类。2 - 组件类。这些元素与 JSX 密切联系。<br>在 JSX 代码中，组件的 tag 名是大写字母开头，而那些 DOM 标签的 tag 名则以小写字母开头。</p><h3 id="1-DOM-元素"><a href="#1-DOM-元素" class="headerlink" title="1 DOM 元素"></a>1 DOM 元素</h3><p>一个 Web 页面由 HTML 元素嵌套组合，使用 JS 怎么描述这个嵌套？<br>我们可以使用简单的 JSON 完成。<br>例如，一个按钮的 HTML 代码：</p><pre><code class="html">&lt;button class=&quot;btn btn-blue&quot;&gt;    &lt;em&gt;Confirm&lt;/em&gt;&lt;/button&gt;</code></pre><p>使用 JSON 表示这个按钮：</p><pre><code class="javascript">{    type: &#39;button&#39;,    props: {        className: &#39;btn btn-blue&#39;,        // 子元素可以是一个数组        children: [            {            type: &#39;em&#39;,            props: {                children: &#39;Confirm&#39;            }            },        ]    }}</code></pre><p>这样就可以在 JS 中创建虚拟 DOM 元素了。<br>这些对象表示的元素就可以指示 React 如何去显示真实的 DOM。</p><h3 id="2-组件元素"><a href="#2-组件元素" class="headerlink" title="2 组件元素"></a>2 组件元素</h3><p>既然可以用 JS 代码表示 DOM 元素了，那就可以进一步封装上面的” 虚拟 DOM“按钮。</p><pre><code class="javascript">const Button = ({ color, text }) =&gt; {    return {        type: &#39;button&#39;,        // 属性又是一个对象        props: {            className: `btn btn-${color}`,            // 按钮的子元素是一个字符串            children: {                type: &#39;em&#39;,                props: {                    children: text                }            }        }    }}</code></pre><p>我们可以很方便地调用 <code>Button({ color:&#39;red&#39;, text:&#39;ENG&#39; })</code> 生成一个按钮实例。<br>再想一想，其实还可以通过 ** 标签的方式 ** 创建一个按钮实例，标签名就是 Button，标签的元素属性就是参数，此时就具备了标签名，属性这两大条件，这样的方式构建的元素称为 <code>组件元素</code>。</p><p>这也是 React 的核心思想之一。因为有公共的表达方法，我们就可以让元素们彼此嵌套或混合。这些层层封装的组件元素，就是所谓的 React 组件，最终我们可以用递归渲染的方式构建出完全的 DOM 元素树。</p><p>可以以这个按钮最为原型，继承出更多按钮。<br>例如，封装一个表示危险操作的按钮：</p><pre><code class="javascript">const DangerButton = ({ text }) =&gt; (    {        type: Button,        props: {            // 红色的按钮            color: &#39;red&#39;,            children: text        }    })</code></pre><p>接着，我们可以很轻松地运用它，继续封装新的组件元素：</p><pre><code class="javascript">const DeleteAccount = () =&gt; {    type: &#39;div&#39;,    props: {        className: &#39;delete-account&#39;,        children: [            {                type: &#39;p&#39;,                props: {                    children: &#39;确定吗？&#39;                }            },            {                type: Deletebutton,                props: {                    children: &#39;确定&#39;                }            }        ]    }}</code></pre><p>这个 DeleteAccount 只有两个子元素，就显得比较冗余，当遇到更大的组件，就难以阅读了。<br>这让我们想起使用 HTML 书写结构时的畅快感受，JSX 语法为此应运而生。假如我们使用 JSX 语法来重新表达上述组件元素，只需这么写：</p><pre><code class="html">const DeleteAccount = () =&gt; {    &lt;div&gt;        &lt;p &gt; 确定吗？&lt;/p&gt;        &lt;DangerButton &gt; 确定 &lt;/DangerButton&gt;        &lt;/div&gt;}</code></pre><p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器（babel）转换到纯 JavaScript 后由浏览器执行。<br>JSX 的出现为我们省去了这个烦琐过程，使用 JSX 写法的代码更易于阅读与开发。</p><hr><h1 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h1><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li>定义标签时，有且只能有一个标签包裹 JSX 结构。因为这些 JSX 要被使用 React.createElement 调用，最外层没有被包裹，显然无法转译成方法调用。</li><li>标签必须闭合</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>HTML 存在的那些标签，在 JSX 里的属性不变，class 和 for 除外。</p><blockquote><p>由于 JSX 内可以写 JS 代码和 HTML 代码，但是 HTML 的 <code>for class</code> 和 JS 关键字冲突，所以将 HTML 代码的 <code>for class</code> 改为 <code>htmlFor className</code></p></blockquote><p>HTML 类标签的 <code>data-</code> 自定义属性也是有效的。</p><p>组件标签的属性是完全自定义的属性，也可以理解为实现组件所需要的参数。</p><h3 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h3><p>布尔属性如果缺值，则默认是 true<br>例如，<code>&lt;CheckBox checked={true} /&gt;</code> 可以简写属性为 <code>&lt;CheckBox checked/&gt;</code></p><h2 id="组件名的命名空间"><a href="#组件名的命名空间" class="headerlink" title="组件名的命名空间"></a>组件名的命名空间</h2><ul><li>JSX 可以使用命名空间，解决组件名称相同问题。<pre><code class="javascript">const App = () =&gt; (  &lt;MUI.PaisedButton label=&quot;Default&quot; /&gt;);</code></pre></li></ul><h2 id="JSX-内的注释"><a href="#JSX-内的注释" class="headerlink" title="JSX 内的注释"></a>JSX 内的注释</h2><p>虽然 JSX 里可以写 JS，但是与 JSX 注释与 JS 不同。<br>在标签外，可以在 <code>{ /**/ }</code> 内写那种多行注释，不能写单行注释。<br>在组件标签内，可以直接写多行注释</p><pre><code class="javascript">const App = (    &lt;Nav&gt;        {/* 节点注释 */}        &lt;Person            /* 多行            注释 */            name={window.isLoggedIn ? window.name : &#39;&#39;}        /&gt;    &lt;/Nav&gt;);</code></pre><h2 id="HTML-转义"><a href="#HTML-转义" class="headerlink" title="HTML 转义"></a>HTML 转义</h2><p>一些 HTML 实体字符无法被正确显示。例如 <code>&amp;copy;</code><br>有几种解决办法：</p><ul><li>直接使用 UTF-8 字符 ©；</li><li>使用对应字符的 Unicode 编码查询编码；</li><li>使用数组组装 <code>&lt;div&gt;{[&#39;cc&#39;, &lt;span&gt;&amp;copy;&lt;/span&gt;, &#39;2015&#39;]}&lt;/div&gt;；</code></li><li>直接插入原始的 HTML</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;为什么 React 需要 JSX&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
      <category term="React" scheme="https://kouder.cn/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>排序稳定性有什么用</title>
    <link href="https://kouder.cn/2021/09/05/pai-xu-wen-ding-xing-you-shi-me-yong/"/>
    <id>https://kouder.cn/2021/09/05/pai-xu-wen-ding-xing-you-shi-me-yong/</id>
    <published>2021-09-05T11:38:25.000Z</published>
    <updated>2022-04-01T02:55:02.335Z</updated>
    
    <content type="html"><![CDATA[<p>稳定性还是有用的。</p><a id="more"></a><h1 id="什么是排序算法稳定性"><a href="#什么是排序算法稳定性" class="headerlink" title="什么是排序算法稳定性"></a>什么是排序算法稳定性</h1><p>两个相等元素的相对位置不变，在前的在排序后还是在前，后前的在排序后还是在后。</p><h1 id="稳定性有什么用"><a href="#稳定性有什么用" class="headerlink" title="稳定性有什么用"></a>稳定性有什么用</h1><p>直接举个例子：<br>有四个同学站一起，身高已经按照升序排列：</p><pre><code>zhang san 1.7zhang wu 1.8 li san 1.7li wu 1.8</code></pre><p>此时，你想将这四个同学再按照姓氏的拼音首字母安装升序排序，同时保持身高排序不变。<br>要达到的最终的排序结果应该是：</p><pre><code>li san 1.7li wu 1.8zhang san 1.7zhang wu 1.8</code></pre><p>如果使用非稳定排序算法，例如选择排序，进行排序的结果为：</p><pre><code>li san 1.7li wu 1.8zhang wu 1.8zhang san 1.7</code></pre><p>你会发现，<code>zhang san 1.7</code> 跑到了 <code>zhang wu 1.8</code> 后面去了。<br>而稳定排序就不会出现这种情况。</p><p>总得来说，这个稳定性排序的作用就是在当前排序规则下，不破坏之前的排序规则产生的对当前规则而言相同的元素的相对顺序。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;稳定性还是有用的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="算法笔记" scheme="https://kouder.cn/categories/%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>前端面试题汇总之计算机网络篇</title>
    <link href="https://kouder.cn/2021/08/31/qian-duan-mian-shi-ti-hui-zong-zhi-ji-suan-ji-wang-luo-pian/"/>
    <id>https://kouder.cn/2021/08/31/qian-duan-mian-shi-ti-hui-zong-zhi-ji-suan-ji-wang-luo-pian/</id>
    <published>2021-08-31T01:11:50.000Z</published>
    <updated>2022-04-01T02:55:13.126Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6908327746473033741" target="_blank" rel="noopener">掘金文章</a></p><a id="more"></a><h1 id="1-GET-与-POST-区别"><a href="#1-GET-与-POST-区别" class="headerlink" title="1 GET 与 POST 区别"></a>1 GET 与 POST 区别</h1><ul><li>应用场景不同：GET 是幂等的（幂等的特点是任意次执行产生的影响与只执行一次的影响相同）。POST 不是幂等的。</li><li>是否缓存：浏览器一般自动缓存 GET 请求，很少对 POST 缓存</li><li>发送数据的方式：GET 请求的实体是空的，POST 请求实体就是要发送的数据</li><li>安全性：GET 请求可以将请求的参数放入 URL 地址发送，而 URL 会保存在浏览的历史记录中</li><li>参数类型：GET 会进行 URL 编码, GET 请求内参数只能出现 ASCII 字符，而 POST 支持更对的参数类型。</li></ul><h1 id="2-常见的-Content-Type"><a href="#2-常见的-Content-Type" class="headerlink" title="2 常见的 Content-Type"></a>2 常见的 Content-Type</h1><ul><li><code>text/html</code> 表示数据是 XML 格式文本数据</li><li><code>application/json</code> 表示数据是 json 数据</li><li><code>application/x-www-form-urlencoded</code> 是表单的默认提交方式。该种方式提交的数据放在 body 里面，数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，<code>key</code> 和 <code>val</code> 都进行了 URL 转码。<ul><li>对于中文，有多种编码方式，UTF-8，gbk 等等。中文编码不同，最终的 URL 编码也不同。一般浏览器是 UTF-8 编码中文，再转 URL 编码。以 <code>我</code> 字为例，它的 utf-8 编码是 <code>E6 88 91</code>，再转换为 URL 编码是 <code>%E6%88%91</code></li></ul></li><li><code>multipart/form-data</code> 通常表单上传文件时使用该种方式</li></ul><h1 id="3-HTTP-状态码-304"><a href="#3-HTTP-状态码-304" class="headerlink" title="3 HTTP 状态码 304"></a>3 HTTP 状态码 304</h1><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端再次对这些页面进行请求，<br>服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回 304，此时客户端调用本地缓存内容，不必从服务器进对页面二次下载。</p><h1 id="4-GET-方法的-URL-长度受限的原因"><a href="#4-GET-方法的-URL-长度受限的原因" class="headerlink" title="4 GET 方法的 URL 长度受限的原因"></a>4 GET 方法的 URL 长度受限的原因</h1><p>实际上 HTTP 协议规范并没有对 get 方法请求的 url 长度进行限制，这个限制是特定的 <code>浏览器及服务器</code> 对它的限制。 IE 对 URL 长度的限制是 2083 字节 (2K+35)。由于 IE 浏览器对 URL 长度的允许值是最小的，所以开发过程中，只要 URL 不超过 <code>2083 字节</code>，那么在所有浏览器中工作都不会有问题。<br>nginx 默认是 8K 字节的请求头部大小</p><h1 id="5-当在浏览器中输入-URL-并且按下回车之后发生了什么"><a href="#5-当在浏览器中输入-URL-并且按下回车之后发生了什么" class="headerlink" title="5 当在浏览器中输入 URL 并且按下回车之后发生了什么"></a>5 当在浏览器中输入 URL 并且按下回车之后发生了什么</h1><ol><li>解析 URL。分析传输协议和请求的资源路径。如果协议或者主机名不符合规范，会作为关键字进行搜索引擎搜索。如果包含中文等字符，会进行 URL 编码（chrome 对中文是先 UTF-8 再 URL 编码），转义后再进行下一过程。</li><li>缓存判断。浏览器判断请求资源是否再缓存，并且是否有效，存在且有效直接使用，否则向服务器发送请求。</li><li>DNS 解析。目的是获取 URL 中的域名的 IP 地址。<ol><li>判断本地是否有域名的 IP 地址缓存，有则使用</li><li>本地无缓存，向本地 DNS 服务器发送请求，有缓存则使用</li><li>本地 DNS 服务器检查是否有缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。</li><li>用户向本地 DNS 服务器发起请求属于递归请求</li><li>本地 DNS 服务器向各级域名服务器发起请求属于迭代请求</li></ol></li><li>获取 MAC 地址。当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址<ol><li>因为应用层下发数据给传输层中的 TCP 协议，TCP 需要指定源端口号和目的端口号，</li><li>然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。</li><li>然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。<ol><li>通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，</li><li>如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，</li><li>如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时可以通过 ARP 协议来获取网关的 MAC 地址，而前面需要的目的主机的 MAC 地址就是网关的地址。</li></ol></li></ol></li><li>TCP 三次握手。</li><li>HTTPS 握手</li><li>返回数据。当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响<br>应后，开始对 html 文件进行解析，开始页面的渲染过程</li><li>页面渲染。浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了</li><li>TCP 四次挥手</li></ol><h1 id="6-HTTP-明文的缺点"><a href="#6-HTTP-明文的缺点" class="headerlink" title="6 HTTP 明文的缺点"></a>6 HTTP 明文的缺点</h1><ul><li>窃听。明文内容会被窃听，账号信息容易泄漏，那你号没了。</li><li>冒充。无法验证通信双方身份，可能遇到伪装。访问假的淘宝、拼多多，那你钱没了。</li><li>篡改。无法保证报文完整性，可能遭到篡改。网页上植⼊垃圾广告，视觉污染，眼没了</li></ul><h1 id="7-HTTPS-如何解决上述问题？"><a href="#7-HTTPS-如何解决上述问题？" class="headerlink" title="7 HTTPS 如何解决上述问题？"></a>7 HTTPS 如何解决上述问题？</h1><p>HTTPS 在 HTTP 与 TCP 之间加入 SSL/TLS 协议。</p><ul><li>防窃听：非对称和对称加密算法保证了信息被窃取也不会导致通信原文被泄露。</li><li>防篡改：摘要算法实现完整性，为数据生成唯一的指纹。</li><li>防冒充：将服务器公钥放入 CA 办法的数字证书中。第三方权威机构保证公钥不被篡改和信任度。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6908327746473033741&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;掘金文章&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="计算机基础" scheme="https://kouder.cn/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="网络" scheme="https://kouder.cn/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>可迭代对象 - 你不知道的 JS</title>
    <link href="https://kouder.cn/2021/08/21/ke-die-dai-dui-xiang-ni-bu-zhi-dao-de-js/"/>
    <id>https://kouder.cn/2021/08/21/ke-die-dai-dui-xiang-ni-bu-zhi-dao-de-js/</id>
    <published>2021-08-21T12:10:02.000Z</published>
    <updated>2022-04-01T02:54:23.284Z</updated>
    
    <content type="html"><![CDATA[<p>似曾相识</p><a id="more"></a><h2 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h2><p>一个 range 对象，它代表了一个数字区间:</p><pre><code>let range = {    from: 1,    to: 5,}</code></pre><p><code>for ... in</code> 可以遍历得到此对象属性 from,to<br><code>for ... of</code> 无法用在此对象上，因为不可迭代。<br>为了让 <code>range</code> 对象可迭代，我们需要为对象添加名为 <code>Symbol.iterator</code> 方法。此 symbol 乃专门用于使对象可迭代的 <code>内置 symbol</code></p><ul><li>此方法调用后，返回值时迭代器，它是一个对象，带有 <code>next</code> 方法</li><li><code>for ... of</code> 尝试搜寻此方法，拿到此迭代器对象。(存不存在原型继承？存在)</li><li>当 <code>for..of</code> 循环希望取得下一个数值，它就调用这个对象的 <code>next()</code> 方法</li><li>next 方法返回格式：<code>{done:Boolean, value:any}</code>。当 <code>done=true</code>，迭代结束。</li></ul><p>NOTE： 用了 ES6 的对象内方法的简写</p><pre><code>let range = {  from: 1,  to: 5,}// 是一个函数range[Symbol.iterator] = function（） {    // 函数返回迭代器对象  return {    current: this.from,    last: this.to,    next() {      if (this.current &lt;= this.last) {      // 返回｛done:...,value:...｝格式对象        return {          done: false,          value: this.current++        };      } else {        return {          done: true;  // 不需要有 value 了        }      }    }  }}</code></pre><p>现在 <code>for ... of</code> 可以运行了！<br>注意包含 next 方法的对象，里面直接用 this 并不能使用 range 的 this</p><pre><code>for (let num of range) {    alert(num); // 1, 然后是 2, 3, 4, 5}</code></pre><p>可以看出，迭代器对象和与其进行迭代的对象可以是分开的。<br><code>for ... of</code> 拿到的是 <code>range[Symbol.iterator]</code> 函数返回的对象，迭代的就是这个对象</p><p>但是调用迭代器时，通过 range 对象调用的，因为如果 <code>range[Symbol.iterator]</code> 是箭头函数，this 会丢失</p><p>可以把迭代器直接写到对象里面。</p><pre><code>// 写在里面的版本let range = {    from: 1,    to: 5,    [Symbol.iterator]: function () {        // 函数返回一个对象, 对象必须包含一个 next 函数        let cur = this.from;        let last = this.to;        // 这里的 this        return {            // 对象包含一个 next 方法, next 方法返回具有固定格式的对象            next: () =&gt; {                // this 就是 return 的对象 外层 的 this                // console.log(this.to);                if (cur &lt;= last) {                    return {                        done: false,                        value: cur++,                    }                } else {                    return {                        done: true,                    }                }            }        }    }}</code></pre><p>更进一步，把迭代器对象的 next 剥离出来，直接放到需要迭代的对象中</p><pre><code>// 剥离 next 函数let range = {    from: 1,    to: 5,    [Symbol.iterator]() {        this.cur = this.from;        return this;    },    next() {        {            if (this.cur &lt;= this.to) {                return {                    done: false,                    value: this.cur++,                }            } else {                return {                    done: true,                }            }        }    }}</code></pre><p>既然我们可以定义迭代器，那么，什么时候停止迭代，我们说了算。所以可以把迭代终止条件设为无限</p><h2 id="字符串可迭代"><a href="#字符串可迭代" class="headerlink" title="字符串可迭代"></a>字符串可迭代</h2><p>代码验证：</p><pre><code>Array.prototype.hasOwnProperty(Symbol.iterator)trueString.prototype.hasOwnProperty(Symbol.iterator)true</code></pre><p>因此字符串也可以像数组一样使用 <code>for...of</code></p><pre><code>for (let char of &quot;test&quot;) {    // 触发 4 次，每个字符一次    alert( char ); // t, then e, then s, then t}</code></pre><h2 id="显示调用迭代器方法"><a href="#显示调用迭代器方法" class="headerlink" title="显示调用迭代器方法"></a>显示调用迭代器方法</h2><p>这样做比 for。。。of 更加灵活</p><pre><code>let str = &quot;WORLD&quot;;// 拿到迭代器let iterator = str[Symbol.iterator];while (true) {  let result = iterator.next();  if (result.done) break;  console.log(result.value);}</code></pre><h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><ul><li>类数组对象指：有索引，有 length 属性的对象</li><li>可迭代对象：实现了 <code>Symbol.iterator</code> 的对象</li></ul><p>确保正确地掌握它们，以免造成混淆</p><p><img src="/images/post-images/1629640685412.png" alt=""></p><p>下面这个对象则是类数组的，但是不可迭代：</p><pre><code>let arrayLike = { // 有索引和 length 属性 =&gt; 类数组对象    0: &quot;Hello&quot;,    1: &quot;World&quot;,    length: 2};// Error (no Symbol.iterator)for (let item of arrayLike) {}</code></pre><h3 id="Array-from😀"><a href="#Array-from😀" class="headerlink" title="Array.from😀"></a>Array.from😀</h3><p>有一个全局方法 <code>Array.from</code> 可以接受一个 ** 可迭代或类数组 ** 的值，并从中获取一个 “真正的” 数组。然后我们就可以对其调用数组方法</p><p>对于上面那个类数组但是不可迭代的对象：</p><pre><code>let arrayLike = {    0: &quot;Hello&quot;,    1: &quot;World&quot;,    length: 2};let arr = Array.from(arrayLike); // (*)alert(arr.pop()); // World（pop 方法有效）</code></pre><p>对于可迭代，但是没有索引，没有 length 属性的对象：</p><pre><code>// 假设 range 来自上文的例子中let arr = Array.from(range);alert(arr); // 1,2,3,4,5 （数组的 toString 转化方法生效）</code></pre><p><code>Array.from</code> 的完整语法允许我们提供一个可选的 “映射（mapping）” 函数</p><pre><code>Array.from(obj, 映射函数, 映射函数的 this 参数)</code></pre><p>例如：</p><pre><code>// 假设 range 来自上文例子中// 求每个数的平方let arr = Array.from(range, num =&gt; num * num);alert(arr); // 1,4,9,16,25</code></pre><p>使用此方法处理字符串，相比使用字符串的 <code>split</code> 方法更方便处理 UTF-16 扩展字符</p><p><img src="/images/post-images/1629640812721.png" alt=""></p><p>使用 Array.from 处理字符串相当于调用字符串的迭代器：</p><pre><code>let str = &#39;😂😂&#39;;let chars = []; // Array.from 内部执行相同的循环for (let char of str) {    chars.push(char);}alert(chars);</code></pre><p>有时，原生方法不支持 UTF16 扩展字符时，可以使用 Array.from</p><pre><code>// 套一个 Array.fromfunction slice(str, start, end) {    return Array.from(str).slice(start, end).join(&#39;&#39;);}let str = &#39;𝒳😂𩷶&#39;;alert( slice(str, 1, 3) ); // 😂𩷶// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）alert( str.slice(1, 3) ); // 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>可迭代对象必须实现 <code>Symbol.iterator</code> 方法，此方法返回一个迭代器对象，对象包含 next 方法，方法返回 <code>{done: Boolean, value: any}</code> 对<br>象，这里 <code>done:true</code> 表明迭代结束, value 是一个值</li><li><code>Symbol.iterator</code> 方法会被 <code>for..of</code> 自动调用，但我们也可以直接调用它</li><li>内置的可迭代对象例如字符串和数组，都实现了 <code>Symbol.iterator</code></li><li>字符串迭代器可以正确识别 UTF-16 扩展字符😂</li></ul><p>仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是 “真正的” 数组，因为这样抽象度更高</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;似曾相识&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://kouder.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>2048 游戏</title>
    <link href="https://kouder.cn/2021/08/19/2048-you-xi/"/>
    <id>https://kouder.cn/2021/08/19/2048-you-xi/</id>
    <published>2021-08-19T07:43:10.000Z</published>
    <updated>2022-04-01T02:52:33.315Z</updated>
    
    <content type="html"><![CDATA[<p>自己心血来潮，写的一个 2048。<br>仓库地址：<a href="https://github.com/Anakinliu/2048_Game" target="_blank" rel="noopener">https://github.com/Anakinliu/2048_Game</a><br>在线 Play：/images/game/2048/</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;自己心血来潮，写的一个 2048。&lt;br&gt;仓库地址：&lt;a href=&quot;https://github.com/Anakinliu/2048_Game&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/Anakinliu/20
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>继承的 6 种实现方式 - 转</title>
    <link href="https://kouder.cn/2021/08/14/ji-cheng-de-6-chong-shi-xian-fang-shi-zhuan/"/>
    <id>https://kouder.cn/2021/08/14/ji-cheng-de-6-chong-shi-xian-fang-shi-zhuan/</id>
    <published>2021-08-14T08:36:49.000Z</published>
    <updated>2022-04-01T02:54:05.234Z</updated>
    
    <content type="html"><![CDATA[<p>转自 ： <a href="https://github.com/sisterAn/blog/issues/41" target="_blank" rel="noopener">https://github.com/sisterAn/blog/issues/41</a></p><a id="more"></a><h1 id="ES5-继承"><a href="#ES5-继承" class="headerlink" title="ES5 继承"></a>ES5 继承</h1><p>先定义一个父类：</p><pre><code>function SuperType () {  // 属性  this.name = &#39;SuperType&#39;;}// 原型方法SuperType.prototype.sayName = function() {  return this.name;};</code></pre><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1 原型链继承"></a>1 原型链继承</h2><p>做法：子类的原型直接被赋值为一个父类的实例</p><pre><code>// 父类function SuperType () {  this.name = &#39;SuperType&#39;; // 父类属性}SuperType.prototype.sayName = function () { // 父类原型方法  return this.name;};// 子类function SubType () {  this.subName = &quot;SubType&quot;; // 子类属性};SubType.prototype = new SuperType(); // 重写原型对象，代之以一个新类型的实例// 这里实例化一个 SuperType 时， 实际上执行了两步// 1，新创建的对象复制了父类构造函数内的所有属性及方法// 2，并将原型 __proto__ 指向了父类的原型对象SubType.prototype.saySubName = function () { // 子类原型方法  return this.subName;}// 子类实例let instance = new SubType();// instanceof 通过判断对象的 prototype 链来确定对象是否是某个类的实例instance instanceof SubType; // trueinstance instanceof SuperType; // true// 注意这里SubType instanceof SuperType; // falseSubType.prototype instanceof SuperType ; // true</code></pre><p>优点： 继承了父类的构造函数模板中的属性，又继承了父类的原型对象。<br>子类要新增原型属性和方法，则必须放在 <code>SubType.prototype = new SuperType(&#39;SubType&#39;);</code> 这样的语句之后执行。<br>缺点：</p><ol><li>无法多继承</li><li>父类的所有属性被子类所有实例共享，一个子类实例修改，其他子类属性都可以看到。</li><li>创建子类实例时，无法向父类构造函数传参</li></ol><h2 id="2-构造函数内继承"><a href="#2-构造函数内继承" class="headerlink" title="2 构造函数内继承"></a>2 构造函数内继承</h2><p>做法：在子类型的构造函数内部调用父类型构造函数。<br>没有用到原型。只是把父类的实例属性赋值给子类</p><pre><code>// 父类function SuperType (name) {  this.name = name; // 父类属性}SuperType.prototype.sayName = function () { // 父类原型方法  return this.name;};// 子类function SubType () {  // 调用 SuperType 构造函数  SuperType.call(this, &#39;SuperType&#39;); // 在子类构造函数中，向父类构造函数传参  // 为了保证子父类的构造函数不会重写子类的属性，需要在调用父类构造函数后，定义子类的属性  this.subName = &quot;SubType&quot;; // 子类属性};// 子类实例let instance = new SubType(); // 运行子类构造函数，并在子类构造函数中运行父类构造函数，this 绑定到子类console.log(instance instanceof SuperType); // false, 子类实例并不是父类的实例，只是子类的实例console.log(instance.sayName());  // 报错</code></pre><p>优点：相比直接的原形链继承，解决了：多继承问题，父类传递参数问题，子类实例对象之间共享父类属性问题<br>缺点：</p><ol><li>由于没有使用原型，所以不能继承原型的属性和方法。</li><li>每个子类都有父类实例函数的副本，影响性能</li></ol><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3 组合继承"></a>3 组合继承</h2><p>将上面的两个，原型链继承与构造函数继承组合在一起<br>做法：使用原型链继承使用对原型属性和方法的继承，通过构造函数继承来实现对实例属性的继承。这样既能通过在原型上定义方法实现函数复用，又能保证每个实例都有自己的属性。</p><pre><code>// 父类function SuperType (name) {  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];  this.name = name; // 父类属性}SuperType.prototype.sayName = function () { // 父类原型方法  return this.name;};// 子类function SubType (name, subName) {  // 调用 SuperType 构造函数  SuperType.call(this, name); // ---- 第二次调用 SuperType----  this.subName = subName;};// ---- 第一次调用 SuperType----SubType.prototype = new SuperType(); // 重写原型对象，代之以一个新类型的实例SubType.prototype.constructor = SubType; // 组合继承需要修复构造函数指向SubType.prototype.saySubName = function () { // 子类原型方法  return this.subName;}// 子类实例let instance = new SubType(&#39;An&#39;, &#39;sisterAn&#39;)instance.colors.push(&#39;black&#39;)console.log(instance.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]instance.sayName() // Aninstance.saySubName() // sisterAnlet instance1 = new SubType(&#39;An1&#39;, &#39;sisterAn1&#39;)console.log(instance1.colors) //  [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]instance1.sayName() // An1instance1.saySubName() // sisterAn1</code></pre><p><img src="/images/post-images/1628931638492.png" alt=""></p><p><code>SubType.prototype = new SuperType()</code> 这行代码调用父类 SuperType 构造函数时，子类的原型 <code>SubType.prototype</code> 会得到两个属性 <code>name</code> 和 <code>colors</code>；当调用子类 <code>SubType</code> 构造函数时，会第二次调用父类 SuperType 构造函数，这一次又在新对象属性上在再次创建了名为 name 和 colors 的属性，这两个属性就会屏蔽前面子类的原型对象上的同名属性。</p><pre><code>// instanceof：instance 的原型链是针对 SuperType.prototype 进行检查的instance instanceof SuperType // trueinstance instanceof SubType // true// isPrototypeOf：instance 的原型链是针对 SuperType 本身进行检查的SuperType.prototype.isPrototypeOf(instance) // trueSubType.prototype.isPrototypeOf(instance) // true</code></pre><p>优点：可继承原型的属性和方法，也可继承实例属性和方法，不存在属性共享，父类可以传参<br>缺点：调用了两次父类构造函数，虽然够杂子类实例时，将原型上的属性同名属性覆盖</p><h2 id="4-寄生组合继承"><a href="#4-寄生组合继承" class="headerlink" title="4 寄生组合继承"></a>4 寄生组合继承</h2><p>组合继承中，调用了两次父类构造函数，这里 通过通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法 / 属性，避免的组合继承的缺点。<br>做法：借用 构造函数 继承 属性 ，通过 原型链的混成形式 来继承 方法</p><pre><code>// 父类function SuperType (name) {  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];  this.name = name; // 父类属性}SuperType.prototype.sayName = function () { // 父类原型方法  return this.name;};// 子类function SubType (name, subName) {  // 调用 SuperType 构造函数  SuperType.call(this, name); // ---- 第二次调用 SuperType，继承实例属性 ----  this.subName = subName;};// ---- 第一次调用 SuperType，继承原型属性 ----SubType.prototype = Object.create(SuperType.prototype)SubType.prototype.constructor = SubType; // 注意：增强对象let instance = new SubType(&#39;An&#39;, &#39;sisterAn&#39;)console.log(Son.prototype.__proto__ == Father.prototype);  // true</code></pre><p>弥补了组合继承的缺点。注意和组合继承比较一下，子类原型的 <code>[[Prototype]]</code> 是谁</p><h1 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h1><pre><code>class People {    constructor(name) {        this.name = name    }    run() { }}// extends 相当于方法的继承// 替换了上面的 3 行代码class Man extends People {    constructor(name) {        // super 相当于属性的继承        // 替换了 People.call(this, name)        super(name)        this.gender = &#39;男&#39;    }    fight() { }}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;转自 ： &lt;a href=&quot;https://github.com/sisterAn/blog/issues/41&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/sisterAn/blog/issues/41&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="日常编程" scheme="https://kouder.cn/categories/%E6%97%A5%E5%B8%B8%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>类 - 你不知道的 JS</title>
    <link href="https://kouder.cn/2021/08/14/lei-ni-bu-zhi-dao-de-js/"/>
    <id>https://kouder.cn/2021/08/14/lei-ni-bu-zhi-dao-de-js/</id>
    <published>2021-08-14T07:28:04.000Z</published>
    <updated>2022-04-01T02:54:30.630Z</updated>
    
    <content type="html"><![CDATA[<p>未完待续</p><a id="more"></a><h1 id="class-语法"><a href="#class-语法" class="headerlink" title="class 语法"></a>class 语法</h1><pre><code>class MyClass {    // class 方法    constructor() { ... }    method1() { ... }    method2() { ... }    method3() { ... }    ...}</code></pre><p>然后使用 <code>new MyClass()</code> 来创建具有上述列出的所有方法的新对象。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;未完待续&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://kouder.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>原型 &amp; 继承三 - 你不知道的 JS</title>
    <link href="https://kouder.cn/2021/08/13/yuan-xing-andji-cheng-san/"/>
    <id>https://kouder.cn/2021/08/13/yuan-xing-andji-cheng-san/</id>
    <published>2021-08-13T12:25:39.000Z</published>
    <updated>2022-04-01T02:56:53.380Z</updated>
    
    <content type="html"><![CDATA[<p>原生原型</p><a id="more"></a><h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><pre><code>let obj = {};obj.toString(); // &quot;[object Object]&quot; ?</code></pre><p><code>toString</code> 方法是内建的 ，但是它到底在哪里呢？ obj 是空的！</p><ol><li>表达式 <code>obj = {}</code> 和 <code>obj = new Object()</code> 是一个意思</li><li>Object 是内建的对象构造函数，其 prototype 指向一个巨大对象，这个巨大对象包含 toString 和其他很多方法</li></ol><p><img src="/images/post-images/1628857974976.png" alt=""></p><p>当 <code>new Object</code> 调用执行（或者创建字面量对象），这个被创建的对象的 <code>[[Prototype]]</code> 属性就被设置为 <code>Object.prototype</code></p><p><img src="/images/post-images/1628858082348.png" alt=""></p><p>所以，一开始的代码的 <code>obj.toString();</code> 就是从 <code>Object.prototype</code> 中获取的。</p><pre><code>let obj = {};alert(obj.__proto__ === Object.prototype); // truealert(obj.toString === obj.__proto__.toString); //truealert(obj.toString === Object.prototype.toString); //true</code></pre><blockquote><p>Object.prototype 上方的链中没有更多的 <code>[[Prototype]]</code>，所以 <code>Object.prototype.__proto__</code> 指向 <code>null</code></p></blockquote><h2 id="其他的内建的原型"><a href="#其他的内建的原型" class="headerlink" title="其他的内建的原型"></a>其他的内建的原型</h2><p>Date，Array，Function，String，Number 等，都在各自的 <code>prototy[e</code> 表示的巨大对象上挂载了大量方法。</p><p>例如，当我们创建一个数组 <code>[1, 2, 3]</code>，在内部会默认使用 <code>new Array()</code> 构造器。因此 <code>Array.prototype</code> 变成了这个数组的 <code>prototype</code>，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。</p><p>按照规范，所有的内建原型顶端都是 <code>Object.prototype</code> 。这就是为什么有人说 “一切都从对象<br>继承而来”。</p><p>完整的示意图</p><p><img src="/images/post-images/1628858379792.png" alt=""></p><p>代码验证：</p><pre><code>let arr = [1, 2, 3];// 它继承自 Array.prototypealert( arr.__proto__ === Array.prototype ); // true// 接下来继承自 Object.prototypealert( arr.__proto__.__proto__ === Object.prototype ); // true// 原型链的顶端为 null。alert( arr.__proto__.__proto__.__proto__ ); // null</code></pre><p>很多方法在原型上可能会发生重叠，例如， Array.prototype 有自己的 toString 方法来列举出来数组的所有元素并用逗号分隔每一个元素。Object.prototype 也有 toString 方法，但是 Array.prototype 在原型链上更近（最先被找到），所以数组对象原型上的方法会被使用。</p><p>函数都是内建构造器 Function 的对象，并且它们的方法（call，apply 等）都取自 <code>Function.prototype</code></p><h2 id="更改原生原型"><a href="#更改原生原型" class="headerlink" title="更改原生原型"></a>更改原生原型</h2><p>原型是全局的，所以很容易造成冲突。<br>通常来说，修改原生原型被认为是一个很不好的想法。</p><p>只有一种情况下允许修改原生原型。那就是 <strong>polyfilling</strong></p><p>Polyfilling 是一个术语，表示某个方法在 *<em>JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法 *</em>，那么我们可以通过手动实现它，并用以填充内建原型</p><pre><code>if (!String.prototype.repeat) { // 如果这儿没有这个方法// 那就在 prototype 中添加它String.prototype.repeat = function(n) {// 重复传入的字符串 n 次// 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）// 但即使是不够完美的 polyfill 也常常被认为是足够好的return new Array(n + 1).join(this);};}alert( &quot;La&quot;.repeat(3) ); // LaLaLa</code></pre><h2 id="从原型中借用"><a href="#从原型中借用" class="headerlink" title="从原型中借用"></a>从原型中借用</h2><p>一些原生原型的方法通常会被借用。<br>例如，如果我们要创建类数组对象，则可能需要向其中复制一些 Array 方法。</p><pre><code>let obj = {    0: &quot;Hello&quot;,    1: &quot;world!&quot;,    length: 2,};obj.join = Array.prototype.join;alert( obj.join(&#39;,&#39;) ); // Hello,world!</code></pre><p>上面这段代码有效，是因为内建的方法 join 的内部算法只关心正确的索引和 length 属性。它<br>不会检查这个对象是否是真正的数组。许多内建方法就是这样。</p><p>另一种方式是通过继承，就是将 <code>obj.__proto__</code> 设置为 <code>Array.prototype</code> ，这样 Array 中的所有方法都自动地可以在 obj 中使用了。</p><blockquote><p>方法借用很灵活，它允许在需要时混合来自不同对象的方法。</p></blockquote><h2 id="不要使用-proto"><a href="#不要使用-proto" class="headerlink" title="不要使用 __proto__"></a>不要使用 <code>__proto__</code></h2><p>现代的方法有:</p><ol><li><code>Object.create()</code> 方法创建一个新对象，使用现有的对象作为新创建的对象的 <code>__proto__</code></li><li><code>Object.getPrototypeOf(obj)</code> 返回对象 obj 的 <code>[[Prototype]]</code>。</li><li><code>Object.setPrototypeOf(obj, proto)</code> 将参数 obj 的 <code>[[Prototype]]</code> 设置为参数 <code>proto</code>。</li></ol><blockquote><p>如果速度很重要，就请不要修改已存在的对象的 <code>[[Prototype]]</code></p></blockquote><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="proto不是-prototype-本身"><a href="#proto不是-prototype-本身" class="headerlink" title="proto不是 [[prototype]] 本身"></a><strong>proto</strong>不是 <code>[[prototype]]</code> 本身</h2><p><code>__proto__</code> 不是一个对象的属性，只是 <code>Object.prototype</code> 的访问器属性</p><p><img src="/images/post-images/1628859778698.png" alt=""></p><p><img src="/images/post-images/1628859790434.png" alt=""></p><p>因此，如果 <code>obj.__proto__</code> 被读取或者赋值，那么对应的 getter/setter 会被从它的原型中调<br>用，它会 set/get [[Prototype]] 。<br>就像在本部分教程的开头所说的那样： <code>__proto__</code> 是一种访问 <code>[[Prototype]]</code> 的方式，而<br>不是 <code>[[prototype]]</code> 本身!!!</p><h2 id="纯对象，纯字典"><a href="#纯对象，纯字典" class="headerlink" title="纯对象，纯字典"></a>纯对象，纯字典</h2><p><code>Object.create(null)</code> 创建了一个空对象，这个对象没有原型，因为 <code>[[Prototype]]</code> 是 <code>null</code>.<br><img src="/images/post-images/1628859943894.png" alt=""></p><p>因此，它没有继承 <code>__proto__</code> 的 <code>getter/setter</code> 方法。<br>一般的对象的 <code>__proto__</code> 是不能被设置为对象的键。但是纯对象可以使用这个键。</p><pre><code>&gt; let j1 = {}undefined&gt; j1[&quot;__proto__&quot;] = 66&gt; j1[&quot;__proto__&quot;]{}&gt; let j2 = Object.create(null);undefined&gt; j2[&quot;__proto__&quot;] = 9;9&gt; j2[&quot;__proto__&quot;]9</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;原生原型&lt;/p&gt;
    
    </summary>
    
    
      <category term="读书笔记" scheme="https://kouder.cn/categories/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="JavaScript" scheme="https://kouder.cn/tags/JavaScript/"/>
    
  </entry>
  
</feed>
